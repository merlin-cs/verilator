// Generated by astgen // -*- mode: C++; c-file-style: "cc-mode" -*-
const char* AstAcosD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstAcosD::broken();
}
bool AstAcosD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAcosD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstAcosD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstAcosD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstAcoshD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstAcoshD::broken();
}
bool AstAcoshD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAcoshD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstAcoshD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstAcoshD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstActive::brokenGen() const {
    BROKEN_RTN(m_sentreep && !m_sentreep->brokeExists());
    BROKEN_RTN(m_sentreep && !(privateTypeTest<AstSenTree>(m_sentreep)));
    BROKEN_RTN(senTreeStorep() && !(privateTypeTest<AstSenTree>(senTreeStorep())));
    return AstActive::broken();
}
bool AstActive::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstActive::cloneRelinkGen() {
    if (m_sentreep && m_sentreep->clonep()) m_sentreep = m_sentreep->clonep();
}
void AstActive::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_sentreep), "sentreep");}
void AstActive::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "sentreep", m_sentreep);
}
void AstActive::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, senTreeStorep(), "senTreeStorep", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstAdd::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiComAsv::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstAdd::broken();
}
bool AstAdd::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAdd::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiComAsv::foreachLink(f);
}
void AstAdd::dumpJsonGen(std::ostream& str) const {
    AstNodeBiComAsv::dumpJson(str);
}
void AstAdd::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstAddD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiComAsv::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstAddD::broken();
}
bool AstAddD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAddD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiComAsv::foreachLink(f);
}
void AstAddD::dumpJsonGen(std::ostream& str) const {
    AstNodeBiComAsv::dumpJson(str);
}
void AstAddD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstAddrOfCFunc::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(!m_funcp);
    BROKEN_RTN(!m_funcp->brokeExists());
    BROKEN_RTN(m_funcp && !(privateTypeTest<AstCFunc>(m_funcp)));
    return AstAddrOfCFunc::broken();
}
bool AstAddrOfCFunc::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstAddrOfCFunc::cloneRelinkGen() {
    AstNodeExpr::cloneRelinkGen();
    if (m_funcp && m_funcp->clonep()) m_funcp = m_funcp->clonep();
}
void AstAddrOfCFunc::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_funcp), "funcp");}
void AstAddrOfCFunc::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
    dumpJsonPtr(str, "funcp", m_funcp);
}
void AstAddrOfCFunc::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstAlias::brokenGen() const {
    BROKEN_RTN(itemsp() && !(privateTypeTest<AstNodeExpr>(itemsp())));
    return AstAlias::broken();
}
bool AstAlias::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAlias::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstAlias::dumpJsonGen(std::ostream& str) const {
}
void AstAlias::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
}
const char* AstAliasScope::brokenGen() const {
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstAliasScope::broken();
}
bool AstAliasScope::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAliasScope::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstAliasScope::dumpJsonGen(std::ostream& str) const {
}
void AstAliasScope::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstAlways::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeProcedure::brokenGen());
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstAlways::broken();
}
bool AstAlways::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstAlways::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeProcedure::foreachLink(f);
}
void AstAlways::dumpJsonGen(std::ostream& str) const {
    AstNodeProcedure::dumpJson(str);
}
void AstAlways::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstAlwaysObserved::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeProcedure::brokenGen());
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstAlwaysObserved::broken();
}
bool AstAlwaysObserved::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstAlwaysObserved::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeProcedure::foreachLink(f);
}
void AstAlwaysObserved::dumpJsonGen(std::ostream& str) const {
    AstNodeProcedure::dumpJson(str);
}
void AstAlwaysObserved::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstAlwaysPost::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeProcedure::brokenGen());
    return AstAlwaysPost::broken();
}
bool AstAlwaysPost::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstAlwaysPost::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeProcedure::foreachLink(f);
}
void AstAlwaysPost::dumpJsonGen(std::ostream& str) const {
    AstNodeProcedure::dumpJson(str);
}
void AstAlwaysPost::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstAlwaysPostponed::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeProcedure::brokenGen());
    return AstAlwaysPostponed::broken();
}
bool AstAlwaysPostponed::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstAlwaysPostponed::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeProcedure::foreachLink(f);
}
void AstAlwaysPostponed::dumpJsonGen(std::ostream& str) const {
    AstNodeProcedure::dumpJson(str);
}
void AstAlwaysPostponed::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstAlwaysPre::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeProcedure::brokenGen());
    return AstAlwaysPre::broken();
}
bool AstAlwaysPre::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstAlwaysPre::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeProcedure::foreachLink(f);
}
void AstAlwaysPre::dumpJsonGen(std::ostream& str) const {
    AstNodeProcedure::dumpJson(str);
}
void AstAlwaysPre::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstAlwaysReactive::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeProcedure::brokenGen());
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstAlwaysReactive::broken();
}
bool AstAlwaysReactive::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstAlwaysReactive::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeProcedure::foreachLink(f);
}
void AstAlwaysReactive::dumpJsonGen(std::ostream& str) const {
    AstNodeProcedure::dumpJson(str);
}
void AstAlwaysReactive::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstAnd::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiComAsv::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstAnd::broken();
}
bool AstAnd::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAnd::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiComAsv::foreachLink(f);
}
void AstAnd::dumpJsonGen(std::ostream& str) const {
    AstNodeBiComAsv::dumpJson(str);
}
void AstAnd::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstArg::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    return AstArg::broken();
}
bool AstArg::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstArg::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstArg::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstArg::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstArraySel::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSel::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(bitp() && !(privateTypeTest<AstNodeExpr>(bitp())));
    return AstArraySel::broken();
}
bool AstArraySel::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstArraySel::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSel::foreachLink(f);
}
void AstArraySel::dumpJsonGen(std::ostream& str) const {
    AstNodeSel::dumpJson(str);
}
void AstArraySel::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, bitp(), "bitp", indent);
}
const char* AstAsinD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstAsinD::broken();
}
bool AstAsinD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAsinD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstAsinD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstAsinD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstAsinhD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstAsinhD::broken();
}
bool AstAsinhD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAsinhD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstAsinhD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstAsinhD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstAssert::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeCoverOrAssert::brokenGen());
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstAssert::broken();
}
bool AstAssert::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstAssert::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeCoverOrAssert::foreachLink(f);
}
void AstAssert::dumpJsonGen(std::ostream& str) const {
    AstNodeCoverOrAssert::dumpJson(str);
}
void AstAssert::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, propp(), "propp", indent);
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
    dumpNodeListJson(str, failsp(), "failsp", indent);
    dumpNodeListJson(str, passsp(), "passsp", indent);
}
const char* AstAssertCtl::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(controlTypep() && !(privateTypeTest<AstNodeExpr>(controlTypep())));
    BROKEN_RTN(assertTypesp() && !(privateTypeTest<AstNodeExpr>(assertTypesp())));
    BROKEN_RTN(directiveTypesp() && !(privateTypeTest<AstNodeExpr>(directiveTypesp())));
    return AstAssertCtl::broken();
}
bool AstAssertCtl::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAssertCtl::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstAssertCtl::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstAssertCtl::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, controlTypep(), "controlTypep", indent);
    dumpNodeListJson(str, assertTypesp(), "assertTypesp", indent);
    dumpNodeListJson(str, directiveTypesp(), "directiveTypesp", indent);
}
const char* AstAssertIntrinsic::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeCoverOrAssert::brokenGen());
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstAssertIntrinsic::broken();
}
bool AstAssertIntrinsic::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstAssertIntrinsic::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeCoverOrAssert::foreachLink(f);
}
void AstAssertIntrinsic::dumpJsonGen(std::ostream& str) const {
    AstNodeCoverOrAssert::dumpJson(str);
}
void AstAssertIntrinsic::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, propp(), "propp", indent);
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
    dumpNodeListJson(str, failsp(), "failsp", indent);
    dumpNodeListJson(str, passsp(), "passsp", indent);
}
const char* AstAssign::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeAssign::brokenGen());
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstAssign::broken();
}
bool AstAssign::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAssign::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeAssign::foreachLink(f);
}
void AstAssign::dumpJsonGen(std::ostream& str) const {
    AstNodeAssign::dumpJson(str);
}
void AstAssign::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, timingControlp(), "timingControlp", indent);
}
const char* AstAssignCont::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeAssign::brokenGen());
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstAssignCont::broken();
}
bool AstAssignCont::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAssignCont::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeAssign::foreachLink(f);
}
void AstAssignCont::dumpJsonGen(std::ostream& str) const {
    AstNodeAssign::dumpJson(str);
}
void AstAssignCont::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, timingControlp(), "timingControlp", indent);
}
const char* AstAssignDly::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeAssign::brokenGen());
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstAssignDly::broken();
}
bool AstAssignDly::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAssignDly::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeAssign::foreachLink(f);
}
void AstAssignDly::dumpJsonGen(std::ostream& str) const {
    AstNodeAssign::dumpJson(str);
}
void AstAssignDly::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, timingControlp(), "timingControlp", indent);
}
const char* AstAssignForce::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeAssign::brokenGen());
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstAssignForce::broken();
}
bool AstAssignForce::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAssignForce::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeAssign::foreachLink(f);
}
void AstAssignForce::dumpJsonGen(std::ostream& str) const {
    AstNodeAssign::dumpJson(str);
}
void AstAssignForce::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, timingControlp(), "timingControlp", indent);
}
const char* AstAssignW::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeAssign::brokenGen());
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(strengthSpecp() && !(privateTypeTest<AstStrengthSpec>(strengthSpecp())));
    return AstAssignW::broken();
}
bool AstAssignW::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstStrengthSpec>(newp))) return true;
    return false;
}
void AstAssignW::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeAssign::foreachLink(f);
}
void AstAssignW::dumpJsonGen(std::ostream& str) const {
    AstNodeAssign::dumpJson(str);
}
void AstAssignW::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, timingControlp(), "timingControlp", indent);
    dumpNodeListJson(str, strengthSpecp(), "strengthSpecp", indent);
}
const char* AstAssocArrayDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_refDTypep && !m_refDTypep->brokeExists());
    BROKEN_RTN(m_refDTypep && !(privateTypeTest<AstNodeDType>(m_refDTypep)));
    BROKEN_RTN(m_keyDTypep && !m_keyDTypep->brokeExists());
    BROKEN_RTN(m_keyDTypep && !(privateTypeTest<AstNodeDType>(m_keyDTypep)));
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    BROKEN_RTN(keyChildDTypep() && !(privateTypeTest<AstNodeDType>(keyChildDTypep())));
    return AstAssocArrayDType::broken();
}
bool AstAssocArrayDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstAssocArrayDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_refDTypep && m_refDTypep->clonep()) m_refDTypep = m_refDTypep->clonep();
    if (m_keyDTypep && m_keyDTypep->clonep()) m_keyDTypep = m_keyDTypep->clonep();
}
void AstAssocArrayDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_refDTypep), "refDTypep");    f(reinterpret_cast<AstNode**>(&m_keyDTypep), "keyDTypep");}
void AstAssocArrayDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "refDTypep", m_refDTypep);
    dumpJsonPtr(str, "keyDTypep", m_keyDTypep);
}
void AstAssocArrayDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
    dumpNodeListJson(str, keyChildDTypep(), "keyChildDTypep", indent);
}
const char* AstAssocSel::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSel::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(bitp() && !(privateTypeTest<AstNodeExpr>(bitp())));
    return AstAssocSel::broken();
}
bool AstAssocSel::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAssocSel::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSel::foreachLink(f);
}
void AstAssocSel::dumpJsonGen(std::ostream& str) const {
    AstNodeSel::dumpJson(str);
}
void AstAssocSel::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, bitp(), "bitp", indent);
}
const char* AstAtan2D::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemBiopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstAtan2D::broken();
}
bool AstAtan2D::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAtan2D::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemBiopD::foreachLink(f);
}
void AstAtan2D::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemBiopD::dumpJson(str);
}
void AstAtan2D::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstAtanD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstAtanD::broken();
}
bool AstAtanD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAtanD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstAtanD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstAtanD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstAtanhD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstAtanhD::broken();
}
bool AstAtanhD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAtanhD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstAtanhD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstAtanhD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstAtoN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstAtoN::broken();
}
bool AstAtoN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAtoN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstAtoN::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstAtoN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstAttrOf::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp()) || privateTypeTest<AstNodeDType>(fromp())));
    BROKEN_RTN(dimp() && !(privateTypeTest<AstNodeExpr>(dimp())));
    return AstAttrOf::broken();
}
bool AstAttrOf::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstNodeDType>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstAttrOf::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstAttrOf::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstAttrOf::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, dimp(), "dimp", indent);
}
const char* AstBasicDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(rangep() && !(privateTypeTest<AstRange>(rangep())));
    return AstBasicDType::broken();
}
bool AstBasicDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstRange>(newp))) return true;
    return false;
}
void AstBasicDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
}
void AstBasicDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
}
void AstBasicDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rangep(), "rangep", indent);
}
const char* AstBegin::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBlock::brokenGen());
    return AstBegin::broken();
}
bool AstBegin::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstBegin::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBlock::foreachLink(f);
}
void AstBegin::dumpJsonGen(std::ostream& str) const {
    AstNodeBlock::dumpJson(str);
}
void AstBegin::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, declsp(), "declsp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstBind::brokenGen() const {
    return AstBind::broken();
}
bool AstBind::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstBind::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstBind::dumpJsonGen(std::ostream& str) const {
}
void AstBind::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, cellsp(), "cellsp", indent);
}
const char* AstBitsToRealD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstBitsToRealD::broken();
}
bool AstBitsToRealD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstBitsToRealD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstBitsToRealD::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstBitsToRealD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstBracketArrayDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    return AstBracketArrayDType::broken();
}
bool AstBracketArrayDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstBracketArrayDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
}
void AstBracketArrayDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
}
void AstBracketArrayDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
    dumpNodeListJson(str, elementsp(), "elementsp", indent);
}
const char* AstBracketRange::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeRange::brokenGen());
    BROKEN_RTN(elementsp() && !(privateTypeTest<AstNodeExpr>(elementsp()) || privateTypeTest<AstNodeDType>(elementsp())));
    return AstBracketRange::broken();
}
bool AstBracketRange::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstBracketRange::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeRange::foreachLink(f);
}
void AstBracketRange::dumpJsonGen(std::ostream& str) const {
    AstNodeRange::dumpJson(str);
}
void AstBracketRange::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, elementsp(), "elementsp", indent);
}
const char* AstBreak::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstBreak::broken();
}
bool AstBreak::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstBreak::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstBreak::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstBreak::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstBufIf1::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstBufIf1::broken();
}
bool AstBufIf1::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstBufIf1::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstBufIf1::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstBufIf1::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstCAwait::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(m_sentreep && !m_sentreep->brokeExists());
    BROKEN_RTN(m_sentreep && !(privateTypeTest<AstSenTree>(m_sentreep)));
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    return AstCAwait::broken();
}
bool AstCAwait::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCAwait::cloneRelinkGen() {
    AstNodeUniop::cloneRelinkGen();
    if (m_sentreep && m_sentreep->clonep()) m_sentreep = m_sentreep->clonep();
}
void AstCAwait::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_sentreep), "sentreep");}
void AstCAwait::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
    dumpJsonPtr(str, "sentreep", m_sentreep);
}
void AstCAwait::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstCCall::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeCCall::brokenGen());
    BROKEN_RTN(argsp() && !(privateTypeTest<AstNodeExpr>(argsp())));
    return AstCCall::broken();
}
bool AstCCall::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCCall::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeCCall::foreachLink(f);
}
void AstCCall::dumpJsonGen(std::ostream& str) const {
    AstNodeCCall::dumpJson(str);
}
void AstCCall::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, argsp(), "argsp", indent);
}
const char* AstCCast::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstCCast::broken();
}
bool AstCCast::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCCast::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstCCast::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstCCast::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstCDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    return AstCDType::broken();
}
bool AstCDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstCDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
}
void AstCDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
}
void AstCDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstCExpr::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(nodesp() && !(privateTypeTest<AstNodeExpr>(nodesp()) || privateTypeTest<AstText>(nodesp())));
    return AstCExpr::broken();
}
bool AstCExpr::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstText>(newp))) return true;
    return false;
}
void AstCExpr::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstCExpr::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstCExpr::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, nodesp(), "nodesp", indent);
}
const char* AstCExprUser::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(nodesp() && !(privateTypeTest<AstNodeExpr>(nodesp()) || privateTypeTest<AstText>(nodesp())));
    return AstCExprUser::broken();
}
bool AstCExprUser::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstText>(newp))) return true;
    return false;
}
void AstCExprUser::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstCExprUser::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstCExprUser::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, nodesp(), "nodesp", indent);
}
const char* AstCFile::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeFile::brokenGen());
    BROKEN_RTN(tblockp() && !(privateTypeTest<AstTextBlock>(tblockp())));
    return AstCFile::broken();
}
bool AstCFile::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstTextBlock>(newp))) return true;
    return false;
}
void AstCFile::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeFile::foreachLink(f);
}
void AstCFile::dumpJsonGen(std::ostream& str) const {
    AstNodeFile::dumpJson(str);
}
void AstCFile::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, tblockp(), "tblockp", indent);
}
const char* AstCFunc::brokenGen() const {
    BROKEN_RTN(m_scopep && !m_scopep->brokeExists());
    BROKEN_RTN(m_scopep && !(privateTypeTest<AstScope>(m_scopep)));
    BROKEN_RTN(argsp() && !(privateTypeTest<AstVar>(argsp())));
    BROKEN_RTN(varsp() && !(privateTypeTest<AstVar>(varsp())));
    return AstCFunc::broken();
}
bool AstCFunc::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstVar>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstVar>(newp))) return true;
    return false;
}
void AstCFunc::cloneRelinkGen() {
    if (m_scopep && m_scopep->clonep()) m_scopep = m_scopep->clonep();
}
void AstCFunc::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_scopep), "scopep");}
void AstCFunc::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "scopep", m_scopep);
}
void AstCFunc::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, argsp(), "argsp", indent);
    dumpNodeListJson(str, varsp(), "varsp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstCLocalScope::brokenGen() const {
    return AstCLocalScope::broken();
}
bool AstCLocalScope::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstCLocalScope::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstCLocalScope::dumpJsonGen(std::ostream& str) const {
}
void AstCLocalScope::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstCLog2::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstCLog2::broken();
}
bool AstCLog2::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCLog2::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstCLog2::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstCLog2::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstCMethodCall::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeCCall::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(argsp() && !(privateTypeTest<AstNodeExpr>(argsp())));
    return AstCMethodCall::broken();
}
bool AstCMethodCall::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCMethodCall::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeCCall::foreachLink(f);
}
void AstCMethodCall::dumpJsonGen(std::ostream& str) const {
    AstNodeCCall::dumpJson(str);
}
void AstCMethodCall::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, argsp(), "argsp", indent);
}
const char* AstCMethodHard::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(pinsp() && !(privateTypeTest<AstNodeExpr>(pinsp())));
    return AstCMethodHard::broken();
}
bool AstCMethodHard::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCMethodHard::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstCMethodHard::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstCMethodHard::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, pinsp(), "pinsp", indent);
}
const char* AstCNew::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeCCall::brokenGen());
    BROKEN_RTN(argsp() && !(privateTypeTest<AstNodeExpr>(argsp())));
    return AstCNew::broken();
}
bool AstCNew::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCNew::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeCCall::foreachLink(f);
}
void AstCNew::dumpJsonGen(std::ostream& str) const {
    AstNodeCCall::dumpJson(str);
}
void AstCNew::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, argsp(), "argsp", indent);
}
const char* AstCReset::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(varrefp() && !(privateTypeTest<AstVarRef>(varrefp())));
    return AstCReset::broken();
}
bool AstCReset::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstVarRef>(newp))) return true;
    return false;
}
void AstCReset::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstCReset::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstCReset::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, varrefp(), "varrefp", indent);
}
const char* AstCReturn::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstCReturn::broken();
}
bool AstCReturn::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCReturn::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstCReturn::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstCReturn::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstCStmt::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(nodesp() && !(privateTypeTest<AstNodeStmt>(nodesp()) || privateTypeTest<AstNodeExpr>(nodesp()) || privateTypeTest<AstText>(nodesp())));
    return AstCStmt::broken();
}
bool AstCStmt::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeStmt>(newp) || privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstText>(newp))) return true;
    return false;
}
void AstCStmt::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstCStmt::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstCStmt::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, nodesp(), "nodesp", indent);
}
const char* AstCStmtUser::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(nodesp() && !(privateTypeTest<AstNodeExpr>(nodesp()) || privateTypeTest<AstText>(nodesp())));
    return AstCStmtUser::broken();
}
bool AstCStmtUser::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstText>(newp))) return true;
    return false;
}
void AstCStmtUser::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstCStmtUser::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstCStmtUser::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, nodesp(), "nodesp", indent);
}
const char* AstCUse::brokenGen() const {
    return AstCUse::broken();
}
bool AstCUse::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstCUse::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstCUse::dumpJsonGen(std::ostream& str) const {
}
void AstCUse::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstCase::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    BROKEN_RTN(itemsp() && !(privateTypeTest<AstCaseItem>(itemsp())));
    return AstCase::broken();
}
bool AstCase::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstCaseItem>(newp))) return true;
    return false;
}
void AstCase::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstCase::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstCase::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
    dumpNodeListJson(str, notParallelp(), "notParallelp", indent);
}
const char* AstCaseItem::brokenGen() const {
    BROKEN_RTN(condsp() && !(privateTypeTest<AstNodeExpr>(condsp())));
    return AstCaseItem::broken();
}
bool AstCaseItem::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCaseItem::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstCaseItem::dumpJsonGen(std::ostream& str) const {
}
void AstCaseItem::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, condsp(), "condsp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstCast::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    return AstCast::broken();
}
bool AstCast::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstCast::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstCast::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstCast::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
}
const char* AstCastDynamic::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(top() && !(privateTypeTest<AstNodeExpr>(top())));
    return AstCastDynamic::broken();
}
bool AstCastDynamic::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCastDynamic::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstCastDynamic::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstCastDynamic::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, top(), "top", indent);
}
const char* AstCastParse::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstCastParse::broken();
}
bool AstCastParse::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCastParse::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstCastParse::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstCastParse::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, dtp(), "dtp", indent);
}
const char* AstCastSize::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstConst>(rhsp())));
    return AstCastSize::broken();
}
bool AstCastSize::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstConst>(newp))) return true;
    return false;
}
void AstCastSize::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstCastSize::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstCastSize::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstCastWrap::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstCastWrap::broken();
}
bool AstCastWrap::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCastWrap::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstCastWrap::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstCastWrap::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstCeilD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstCeilD::broken();
}
bool AstCeilD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCeilD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstCeilD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstCeilD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstCell::brokenGen() const {
    BROKEN_RTN(m_modp && !m_modp->brokeExists());
    BROKEN_RTN(m_modp && !(privateTypeTest<AstNodeModule>(m_modp)));
    BROKEN_RTN(pinsp() && !(privateTypeTest<AstPin>(pinsp())));
    BROKEN_RTN(paramsp() && !(privateTypeTest<AstPin>(paramsp())));
    BROKEN_RTN(rangep() && !(privateTypeTest<AstRange>(rangep())));
    BROKEN_RTN(intfRefsp() && !(privateTypeTest<AstIntfRef>(intfRefsp())));
    return AstCell::broken();
}
bool AstCell::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstPin>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstPin>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstRange>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstIntfRef>(newp))) return true;
    return false;
}
void AstCell::cloneRelinkGen() {
    if (m_modp && m_modp->clonep()) m_modp = m_modp->clonep();
}
void AstCell::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_modp), "modp");}
void AstCell::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "modp", m_modp);
}
void AstCell::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, pinsp(), "pinsp", indent);
    dumpNodeListJson(str, paramsp(), "paramsp", indent);
    dumpNodeListJson(str, rangep(), "rangep", indent);
    dumpNodeListJson(str, intfRefsp(), "intfRefsp", indent);
}
const char* AstCellArrayRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(selp() && !(privateTypeTest<AstNodeExpr>(selp())));
    return AstCellArrayRef::broken();
}
bool AstCellArrayRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCellArrayRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstCellArrayRef::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstCellArrayRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, selp(), "selp", indent);
}
const char* AstCellInline::brokenGen() const {
    BROKEN_RTN(m_scopep && !m_scopep->brokeExists());
    BROKEN_RTN(m_scopep && !(privateTypeTest<AstScope>(m_scopep)));
    return AstCellInline::broken();
}
bool AstCellInline::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstCellInline::cloneRelinkGen() {
    if (m_scopep && m_scopep->clonep()) m_scopep = m_scopep->clonep();
}
void AstCellInline::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_scopep), "scopep");}
void AstCellInline::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "scopep", m_scopep);
}
void AstCellInline::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstCellInlineScope::brokenGen() const {
    BROKEN_RTN(m_scopep && !m_scopep->brokeExists());
    BROKEN_RTN(m_scopep && !(privateTypeTest<AstScope>(m_scopep)));
    BROKEN_RTN(m_cellp && !m_cellp->brokeExists());
    BROKEN_RTN(m_cellp && !(privateTypeTest<AstCellInline>(m_cellp)));
    return AstCellInlineScope::broken();
}
bool AstCellInlineScope::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstCellInlineScope::cloneRelinkGen() {
    if (m_scopep && m_scopep->clonep()) m_scopep = m_scopep->clonep();
    if (m_cellp && m_cellp->clonep()) m_cellp = m_cellp->clonep();
}
void AstCellInlineScope::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_scopep), "scopep");    f(reinterpret_cast<AstNode**>(&m_cellp), "cellp");}
void AstCellInlineScope::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "scopep", m_scopep);
    dumpJsonPtr(str, "cellp", m_cellp);
}
void AstCellInlineScope::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstCellRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp()) || privateTypeTest<AstNodeDType>(exprp())));
    return AstCellRef::broken();
}
bool AstCellRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstCellRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstCellRef::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstCellRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, cellp(), "cellp", indent);
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstCgOptionAssign::brokenGen() const {
    BROKEN_RTN(valuep() && !(privateTypeTest<AstNodeExpr>(valuep())));
    return AstCgOptionAssign::broken();
}
bool AstCgOptionAssign::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCgOptionAssign::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstCgOptionAssign::dumpJsonGen(std::ostream& str) const {
}
void AstCgOptionAssign::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, valuep(), "valuep", indent);
}
const char* AstClass::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeModule::brokenGen());
    BROKEN_RTN(m_classOrPackagep && !m_classOrPackagep->brokeExists());
    BROKEN_RTN(m_classOrPackagep && !(privateTypeTest<AstClassPackage>(m_classOrPackagep)));
    BROKEN_RTN(extendsp() && !(privateTypeTest<AstClassExtends>(extendsp())));
    return AstClass::broken();
}
bool AstClass::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op4p() && !(privateTypeTest<AstClassExtends>(newp))) return true;
    return false;
}
void AstClass::cloneRelinkGen() {
    AstNodeModule::cloneRelinkGen();
    if (m_classOrPackagep && m_classOrPackagep->clonep()) m_classOrPackagep = m_classOrPackagep->clonep();
}
void AstClass::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeModule::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_classOrPackagep), "classOrPackagep");}
void AstClass::dumpJsonGen(std::ostream& str) const {
    AstNodeModule::dumpJson(str);
    dumpJsonPtr(str, "classOrPackagep", m_classOrPackagep);
}
void AstClass::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, inlinesp(), "inlinesp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
    dumpNodeListJson(str, extendsp(), "extendsp", indent);
}
const char* AstClassExtends::brokenGen() const {
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    BROKEN_RTN(argsp() && !(privateTypeTest<AstNodeExpr>(argsp())));
    return AstClassExtends::broken();
}
bool AstClassExtends::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstClassExtends::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstClassExtends::dumpJsonGen(std::ostream& str) const {
}
void AstClassExtends::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
    dumpNodeListJson(str, classOrPkgsp(), "classOrPkgsp", indent);
    dumpNodeListJson(str, argsp(), "argsp", indent);
}
const char* AstClassOrPackageRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(m_classOrPackageNodep && !m_classOrPackageNodep->brokeExists());
    BROKEN_RTN(paramsp() && !(privateTypeTest<AstPin>(paramsp())));
    return AstClassOrPackageRef::broken();
}
bool AstClassOrPackageRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstPin>(newp))) return true;
    return false;
}
void AstClassOrPackageRef::cloneRelinkGen() {
    AstNodeExpr::cloneRelinkGen();
    if (m_classOrPackageNodep && m_classOrPackageNodep->clonep()) m_classOrPackageNodep = m_classOrPackageNodep->clonep();
}
void AstClassOrPackageRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_classOrPackageNodep), "classOrPackageNodep");}
void AstClassOrPackageRef::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
    dumpJsonPtr(str, "classOrPackageNodep", m_classOrPackageNodep);
}
void AstClassOrPackageRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, paramsp(), "paramsp", indent);
}
const char* AstClassPackage::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeModule::brokenGen());
    BROKEN_RTN(m_classp && !m_classp->brokeExists());
    BROKEN_RTN(m_classp && !(privateTypeTest<AstClass>(m_classp)));
    return AstClassPackage::broken();
}
bool AstClassPackage::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstClassPackage::cloneRelinkGen() {
    AstNodeModule::cloneRelinkGen();
    if (m_classp && m_classp->clonep()) m_classp = m_classp->clonep();
}
void AstClassPackage::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeModule::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_classp), "classp");}
void AstClassPackage::dumpJsonGen(std::ostream& str) const {
    AstNodeModule::dumpJson(str);
    dumpJsonPtr(str, "classp", m_classp);
}
void AstClassPackage::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, inlinesp(), "inlinesp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstClassRefDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_classp && !m_classp->brokeExists());
    BROKEN_RTN(m_classp && !(privateTypeTest<AstClass>(m_classp)));
    BROKEN_RTN(m_classOrPackagep && !m_classOrPackagep->brokeExists());
    BROKEN_RTN(m_classOrPackagep && !(privateTypeTest<AstNodeModule>(m_classOrPackagep)));
    BROKEN_RTN(paramsp() && !(privateTypeTest<AstPin>(paramsp())));
    return AstClassRefDType::broken();
}
bool AstClassRefDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstPin>(newp))) return true;
    return false;
}
void AstClassRefDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_classp && m_classp->clonep()) m_classp = m_classp->clonep();
    if (m_classOrPackagep && m_classOrPackagep->clonep()) m_classOrPackagep = m_classOrPackagep->clonep();
}
void AstClassRefDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_classp), "classp");    f(reinterpret_cast<AstNode**>(&m_classOrPackagep), "classOrPackagep");}
void AstClassRefDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "classp", m_classp);
    dumpJsonPtr(str, "classOrPackagep", m_classOrPackagep);
}
void AstClassRefDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, paramsp(), "paramsp", indent);
}
const char* AstClocking::brokenGen() const {
    BROKEN_RTN(sensesp() && !(privateTypeTest<AstSenItem>(sensesp())));
    BROKEN_RTN(eventp() && !(privateTypeTest<AstVar>(eventp())));
    return AstClocking::broken();
}
bool AstClocking::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstSenItem>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstVar>(newp))) return true;
    return false;
}
void AstClocking::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstClocking::dumpJsonGen(std::ostream& str) const {
}
void AstClocking::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, sensesp(), "sensesp", indent);
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
    dumpNodeListJson(str, eventp(), "eventp", indent);
}
const char* AstClockingItem::brokenGen() const {
    BROKEN_RTN(m_outputp && !m_outputp->brokeExists());
    BROKEN_RTN(m_outputp && !(privateTypeTest<AstClockingItem>(m_outputp)));
    BROKEN_RTN(skewp() && !(privateTypeTest<AstNodeExpr>(skewp())));
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    BROKEN_RTN(assignp() && !(privateTypeTest<AstAssign>(assignp())));
    BROKEN_RTN(varp() && !(privateTypeTest<AstVar>(varp())));
    return AstClockingItem::broken();
}
bool AstClockingItem::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstAssign>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstVar>(newp))) return true;
    return false;
}
void AstClockingItem::cloneRelinkGen() {
    if (m_outputp && m_outputp->clonep()) m_outputp = m_outputp->clonep();
}
void AstClockingItem::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_outputp), "outputp");}
void AstClockingItem::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "outputp", m_outputp);
}
void AstClockingItem::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, skewp(), "skewp", indent);
    dumpNodeListJson(str, exprp(), "exprp", indent);
    dumpNodeListJson(str, assignp(), "assignp", indent);
    dumpNodeListJson(str, varp(), "varp", indent);
}
const char* AstComment::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstComment::broken();
}
bool AstComment::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstComment::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstComment::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstComment::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstCompareNN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstCompareNN::broken();
}
bool AstCompareNN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCompareNN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstCompareNN::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstCompareNN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstConcat::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstConcat::broken();
}
bool AstConcat::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstConcat::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstConcat::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstConcat::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstConcatN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstConcatN::broken();
}
bool AstConcatN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstConcatN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstConcatN::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstConcatN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstCond::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeTriop::brokenGen());
    BROKEN_RTN(condp() && !(privateTypeTest<AstNodeExpr>(condp())));
    BROKEN_RTN(thenp() && !(privateTypeTest<AstNodeExpr>(thenp())));
    BROKEN_RTN(elsep() && !(privateTypeTest<AstNodeExpr>(elsep())));
    return AstCond::broken();
}
bool AstCond::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCond::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeTriop::foreachLink(f);
}
void AstCond::dumpJsonGen(std::ostream& str) const {
    AstNodeTriop::dumpJson(str);
}
void AstCond::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, condp(), "condp", indent);
    dumpNodeListJson(str, thenp(), "thenp", indent);
    dumpNodeListJson(str, elsep(), "elsep", indent);
}
const char* AstConfig::brokenGen() const {
    BROKEN_RTN(designp() && !(privateTypeTest<AstConfigCell>(designp())));
    return AstConfig::broken();
}
bool AstConfig::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstConfigCell>(newp))) return true;
    return false;
}
void AstConfig::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstConfig::dumpJsonGen(std::ostream& str) const {
}
void AstConfig::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, designp(), "designp", indent);
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
}
const char* AstConfigCell::brokenGen() const {
    return AstConfigCell::broken();
}
bool AstConfigCell::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstConfigCell::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstConfigCell::dumpJsonGen(std::ostream& str) const {
}
void AstConfigCell::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstConfigRule::brokenGen() const {
    return AstConfigRule::broken();
}
bool AstConfigRule::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstConfigRule::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstConfigRule::dumpJsonGen(std::ostream& str) const {
}
void AstConfigRule::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, cellp(), "cellp", indent);
    dumpNodeListJson(str, usep(), "usep", indent);
}
const char* AstConfigUse::brokenGen() const {
    BROKEN_RTN(paramsp() && !(privateTypeTest<AstPin>(paramsp())));
    return AstConfigUse::broken();
}
bool AstConfigUse::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstPin>(newp))) return true;
    return false;
}
void AstConfigUse::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstConfigUse::dumpJsonGen(std::ostream& str) const {
}
void AstConfigUse::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, paramsp(), "paramsp", indent);
}
const char* AstConsAssoc::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstConsAssoc::broken();
}
bool AstConsAssoc::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstConsAssoc::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstConsAssoc::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstConsAssoc::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, defaultp(), "defaultp", indent);
}
const char* AstConsDynArray::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstConsDynArray::broken();
}
bool AstConsDynArray::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstConsDynArray::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstConsDynArray::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstConsDynArray::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstConsPackMember::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstConsPackMember::broken();
}
bool AstConsPackMember::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstConsPackMember::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstConsPackMember::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstConsPackMember::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstConsPackUOrStruct::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(membersp() && !(privateTypeTest<AstConsPackMember>(membersp())));
    return AstConsPackUOrStruct::broken();
}
bool AstConsPackUOrStruct::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstConsPackMember>(newp))) return true;
    return false;
}
void AstConsPackUOrStruct::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstConsPackUOrStruct::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstConsPackUOrStruct::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, membersp(), "membersp", indent);
}
const char* AstConsQueue::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstConsQueue::broken();
}
bool AstConsQueue::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstConsQueue::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstConsQueue::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstConsQueue::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstConsWildcard::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstConsWildcard::broken();
}
bool AstConsWildcard::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstConsWildcard::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstConsWildcard::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstConsWildcard::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, defaultp(), "defaultp", indent);
}
const char* AstConst::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstConst::broken();
}
bool AstConst::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstConst::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstConst::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstConst::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstConstDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_refDTypep && !m_refDTypep->brokeExists());
    BROKEN_RTN(m_refDTypep && !(privateTypeTest<AstNodeDType>(m_refDTypep)));
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    return AstConstDType::broken();
}
bool AstConstDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstConstDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_refDTypep && m_refDTypep->clonep()) m_refDTypep = m_refDTypep->clonep();
}
void AstConstDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_refDTypep), "refDTypep");}
void AstConstDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "refDTypep", m_refDTypep);
}
void AstConstDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
}
const char* AstConstPool::brokenGen() const {
    BROKEN_RTN(!m_modp);
    BROKEN_RTN(!m_modp->brokeExists());
    BROKEN_RTN(m_modp && !(privateTypeTest<AstModule>(m_modp)));
    BROKEN_RTN(!m_scopep);
    BROKEN_RTN(!m_scopep->brokeExists());
    BROKEN_RTN(m_scopep && !(privateTypeTest<AstScope>(m_scopep)));
    BROKEN_RTN(modulep() && !(privateTypeTest<AstModule>(modulep())));
    return AstConstPool::broken();
}
bool AstConstPool::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstModule>(newp))) return true;
    return false;
}
void AstConstPool::cloneRelinkGen() {
    if (m_modp && m_modp->clonep()) m_modp = m_modp->clonep();
    if (m_scopep && m_scopep->clonep()) m_scopep = m_scopep->clonep();
}
void AstConstPool::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_modp), "modp");    f(reinterpret_cast<AstNode**>(&m_scopep), "scopep");}
void AstConstPool::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "modp", m_modp);
    dumpJsonPtr(str, "scopep", m_scopep);
}
void AstConstPool::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, modulep(), "modulep", indent);
}
const char* AstConstraint::brokenGen() const {
    return AstConstraint::broken();
}
bool AstConstraint::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstConstraint::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstConstraint::dumpJsonGen(std::ostream& str) const {
}
void AstConstraint::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
    dumpNodeListJson(str, classOrPackagep(), "classOrPackagep", indent);
}
const char* AstConstraintBefore::brokenGen() const {
    BROKEN_RTN(lhssp() && !(privateTypeTest<AstNodeExpr>(lhssp())));
    BROKEN_RTN(rhssp() && !(privateTypeTest<AstNodeExpr>(rhssp())));
    return AstConstraintBefore::broken();
}
bool AstConstraintBefore::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstConstraintBefore::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstConstraintBefore::dumpJsonGen(std::ostream& str) const {
}
void AstConstraintBefore::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhssp(), "lhssp", indent);
    dumpNodeListJson(str, rhssp(), "rhssp", indent);
}
const char* AstConstraintExpr::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    return AstConstraintExpr::broken();
}
bool AstConstraintExpr::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstConstraintExpr::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstConstraintExpr::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstConstraintExpr::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstConstraintForeach::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeForeach::brokenGen());
    return AstConstraintForeach::broken();
}
bool AstConstraintForeach::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstConstraintForeach::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeForeach::foreachLink(f);
}
void AstConstraintForeach::dumpJsonGen(std::ostream& str) const {
    AstNodeForeach::dumpJson(str);
}
void AstConstraintForeach::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, arrayp(), "arrayp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstConstraintIf::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeIf::brokenGen());
    BROKEN_RTN(condp() && !(privateTypeTest<AstNodeExpr>(condp())));
    return AstConstraintIf::broken();
}
bool AstConstraintIf::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstConstraintIf::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeIf::foreachLink(f);
}
void AstConstraintIf::dumpJsonGen(std::ostream& str) const {
    AstNodeIf::dumpJson(str);
}
void AstConstraintIf::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, condp(), "condp", indent);
    dumpNodeListJson(str, thensp(), "thensp", indent);
    dumpNodeListJson(str, elsesp(), "elsesp", indent);
}
const char* AstConstraintRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(!m_constrp);
    BROKEN_RTN(!m_constrp->brokeExists());
    BROKEN_RTN(m_constrp && !(privateTypeTest<AstConstraint>(m_constrp)));
    BROKEN_RTN(m_classOrPackagep && !m_classOrPackagep->brokeExists());
    BROKEN_RTN(m_classOrPackagep && !(privateTypeTest<AstNodeModule>(m_classOrPackagep)));
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    return AstConstraintRef::broken();
}
bool AstConstraintRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstConstraintRef::cloneRelinkGen() {
    AstNodeExpr::cloneRelinkGen();
    if (m_constrp && m_constrp->clonep()) m_constrp = m_constrp->clonep();
    if (m_classOrPackagep && m_classOrPackagep->clonep()) m_classOrPackagep = m_classOrPackagep->clonep();
}
void AstConstraintRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_constrp), "constrp");    f(reinterpret_cast<AstNode**>(&m_classOrPackagep), "classOrPackagep");}
void AstConstraintRef::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
    dumpJsonPtr(str, "constrp", m_constrp);
    dumpJsonPtr(str, "classOrPackagep", m_classOrPackagep);
}
void AstConstraintRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
}
const char* AstConstraintRefDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    return AstConstraintRefDType::broken();
}
bool AstConstraintRefDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstConstraintRefDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
}
void AstConstraintRefDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
}
void AstConstraintRefDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstConstraintUnique::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstConstraintUnique::broken();
}
bool AstConstraintUnique::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstConstraintUnique::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstConstraintUnique::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstConstraintUnique::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rangesp(), "rangesp", indent);
}
const char* AstContinue::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstContinue::broken();
}
bool AstContinue::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstContinue::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstContinue::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstContinue::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstCosD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstCosD::broken();
}
bool AstCosD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCosD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstCosD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstCosD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstCoshD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstCoshD::broken();
}
bool AstCoshD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCoshD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstCoshD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstCoshD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstCountBits::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeQuadop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    BROKEN_RTN(fhsp() && !(privateTypeTest<AstNodeExpr>(fhsp())));
    return AstCountBits::broken();
}
bool AstCountBits::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCountBits::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeQuadop::foreachLink(f);
}
void AstCountBits::dumpJsonGen(std::ostream& str) const {
    AstNodeQuadop::dumpJson(str);
}
void AstCountBits::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
    dumpNodeListJson(str, fhsp(), "fhsp", indent);
}
const char* AstCountOnes::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstCountOnes::broken();
}
bool AstCountOnes::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCountOnes::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstCountOnes::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstCountOnes::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstCover::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeCoverOrAssert::brokenGen());
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstCover::broken();
}
bool AstCover::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstCover::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeCoverOrAssert::foreachLink(f);
}
void AstCover::dumpJsonGen(std::ostream& str) const {
    AstNodeCoverOrAssert::dumpJson(str);
}
void AstCover::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, propp(), "propp", indent);
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
    dumpNodeListJson(str, coverincsp(), "coverincsp", indent);
    dumpNodeListJson(str, passsp(), "passsp", indent);
}
const char* AstCoverInc::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(!m_declp);
    BROKEN_RTN(!m_declp->brokeExists());
    BROKEN_RTN(m_declp && !(privateTypeTest<AstNodeCoverDecl>(m_declp)));
    BROKEN_RTN(toggleExprp() && !(privateTypeTest<AstNodeExpr>(toggleExprp())));
    BROKEN_RTN(toggleCovExprp() && !(privateTypeTest<AstNodeExpr>(toggleCovExprp())));
    return AstCoverInc::broken();
}
bool AstCoverInc::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCoverInc::cloneRelinkGen() {
    AstNodeStmt::cloneRelinkGen();
    if (m_declp && m_declp->clonep()) m_declp = m_declp->clonep();
}
void AstCoverInc::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_declp), "declp");}
void AstCoverInc::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
    dumpJsonPtr(str, "declp", m_declp);
}
void AstCoverInc::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, toggleExprp(), "toggleExprp", indent);
    dumpNodeListJson(str, toggleCovExprp(), "toggleCovExprp", indent);
}
const char* AstCoverOtherDecl::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeCoverDecl::brokenGen());
    return AstCoverOtherDecl::broken();
}
bool AstCoverOtherDecl::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstCoverOtherDecl::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeCoverDecl::foreachLink(f);
}
void AstCoverOtherDecl::dumpJsonGen(std::ostream& str) const {
    AstNodeCoverDecl::dumpJson(str);
}
void AstCoverOtherDecl::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstCoverToggle::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(incp() && !(privateTypeTest<AstCoverInc>(incp())));
    BROKEN_RTN(origp() && !(privateTypeTest<AstNodeExpr>(origp())));
    BROKEN_RTN(changep() && !(privateTypeTest<AstNodeExpr>(changep())));
    return AstCoverToggle::broken();
}
bool AstCoverToggle::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstCoverInc>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCoverToggle::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstCoverToggle::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstCoverToggle::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, incp(), "incp", indent);
    dumpNodeListJson(str, origp(), "origp", indent);
    dumpNodeListJson(str, changep(), "changep", indent);
}
const char* AstCoverToggleDecl::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeCoverDecl::brokenGen());
    return AstCoverToggleDecl::broken();
}
bool AstCoverToggleDecl::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstCoverToggleDecl::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeCoverDecl::foreachLink(f);
}
void AstCoverToggleDecl::dumpJsonGen(std::ostream& str) const {
    AstNodeCoverDecl::dumpJson(str);
}
void AstCoverToggleDecl::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstCvtArrayToArray::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    return AstCvtArrayToArray::broken();
}
bool AstCvtArrayToArray::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCvtArrayToArray::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstCvtArrayToArray::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstCvtArrayToArray::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
}
const char* AstCvtArrayToPacked::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    return AstCvtArrayToPacked::broken();
}
bool AstCvtArrayToPacked::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCvtArrayToPacked::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstCvtArrayToPacked::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstCvtArrayToPacked::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
}
const char* AstCvtPackString::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstCvtPackString::broken();
}
bool AstCvtPackString::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCvtPackString::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstCvtPackString::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstCvtPackString::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstCvtPackedToArray::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    return AstCvtPackedToArray::broken();
}
bool AstCvtPackedToArray::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCvtPackedToArray::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstCvtPackedToArray::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstCvtPackedToArray::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
}
const char* AstCvtUnpackedToQueue::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    return AstCvtUnpackedToQueue::broken();
}
bool AstCvtUnpackedToQueue::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstCvtUnpackedToQueue::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstCvtUnpackedToQueue::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstCvtUnpackedToQueue::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
}
const char* AstDefImplicitDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    return AstDefImplicitDType::broken();
}
bool AstDefImplicitDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstDefImplicitDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
}
void AstDefImplicitDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
}
void AstDefImplicitDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
}
const char* AstDefParam::brokenGen() const {
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstDefParam::broken();
}
bool AstDefParam::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDefParam::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstDefParam::dumpJsonGen(std::ostream& str) const {
}
void AstDefParam::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstDefaultDisable::brokenGen() const {
    BROKEN_RTN(condp() && !(privateTypeTest<AstNodeExpr>(condp())));
    return AstDefaultDisable::broken();
}
bool AstDefaultDisable::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDefaultDisable::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstDefaultDisable::dumpJsonGen(std::ostream& str) const {
}
void AstDefaultDisable::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, condp(), "condp", indent);
}
const char* AstDelay::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstDelay::broken();
}
bool AstDelay::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDelay::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstDelay::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstDelay::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstDisable::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(m_targetp && !m_targetp->brokeExists());
    BROKEN_RTN(targetRefp() && !(privateTypeTest<AstNodeExpr>(targetRefp())));
    return AstDisable::broken();
}
bool AstDisable::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDisable::cloneRelinkGen() {
    AstNodeStmt::cloneRelinkGen();
    if (m_targetp && m_targetp->clonep()) m_targetp = m_targetp->clonep();
}
void AstDisable::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_targetp), "targetp");}
void AstDisable::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
    dumpJsonPtr(str, "targetp", m_targetp);
}
void AstDisable::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, targetRefp(), "targetRefp", indent);
}
const char* AstDisableFork::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstDisableFork::broken();
}
bool AstDisableFork::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstDisableFork::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstDisableFork::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstDisableFork::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstDisplay::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(fmtp() && !(privateTypeTest<AstSFormatF>(fmtp())));
    BROKEN_RTN(filep() && !(privateTypeTest<AstNodeExpr>(filep())));
    return AstDisplay::broken();
}
bool AstDisplay::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstSFormatF>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDisplay::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstDisplay::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstDisplay::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fmtp(), "fmtp", indent);
    dumpNodeListJson(str, filep(), "filep", indent);
}
const char* AstDist::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    BROKEN_RTN(itemsp() && !(privateTypeTest<AstDistItem>(itemsp())));
    return AstDist::broken();
}
bool AstDist::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstDistItem>(newp))) return true;
    return false;
}
void AstDist::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstDist::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstDist::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
}
const char* AstDistChiSquare::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDistBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstDistChiSquare::broken();
}
bool AstDistChiSquare::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDistChiSquare::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDistBiop::foreachLink(f);
}
void AstDistChiSquare::dumpJsonGen(std::ostream& str) const {
    AstNodeDistBiop::dumpJson(str);
}
void AstDistChiSquare::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstDistErlang::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDistTriop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    return AstDistErlang::broken();
}
bool AstDistErlang::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDistErlang::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDistTriop::foreachLink(f);
}
void AstDistErlang::dumpJsonGen(std::ostream& str) const {
    AstNodeDistTriop::dumpJson(str);
}
void AstDistErlang::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
}
const char* AstDistExponential::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDistBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstDistExponential::broken();
}
bool AstDistExponential::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDistExponential::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDistBiop::foreachLink(f);
}
void AstDistExponential::dumpJsonGen(std::ostream& str) const {
    AstNodeDistBiop::dumpJson(str);
}
void AstDistExponential::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstDistItem::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(rangep() && !(privateTypeTest<AstNodeExpr>(rangep())));
    BROKEN_RTN(weightp() && !(privateTypeTest<AstNodeExpr>(weightp())));
    return AstDistItem::broken();
}
bool AstDistItem::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDistItem::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstDistItem::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstDistItem::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rangep(), "rangep", indent);
    dumpNodeListJson(str, weightp(), "weightp", indent);
}
const char* AstDistNormal::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDistTriop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    return AstDistNormal::broken();
}
bool AstDistNormal::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDistNormal::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDistTriop::foreachLink(f);
}
void AstDistNormal::dumpJsonGen(std::ostream& str) const {
    AstNodeDistTriop::dumpJson(str);
}
void AstDistNormal::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
}
const char* AstDistPoisson::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDistBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstDistPoisson::broken();
}
bool AstDistPoisson::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDistPoisson::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDistBiop::foreachLink(f);
}
void AstDistPoisson::dumpJsonGen(std::ostream& str) const {
    AstNodeDistBiop::dumpJson(str);
}
void AstDistPoisson::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstDistT::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDistBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstDistT::broken();
}
bool AstDistT::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDistT::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDistBiop::foreachLink(f);
}
void AstDistT::dumpJsonGen(std::ostream& str) const {
    AstNodeDistBiop::dumpJson(str);
}
void AstDistT::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstDistUniform::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDistTriop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    return AstDistUniform::broken();
}
bool AstDistUniform::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDistUniform::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDistTriop::foreachLink(f);
}
void AstDistUniform::dumpJsonGen(std::ostream& str) const {
    AstNodeDistTriop::dumpJson(str);
}
void AstDistUniform::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
}
const char* AstDiv::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstDiv::broken();
}
bool AstDiv::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDiv::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstDiv::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstDiv::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstDivD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstDivD::broken();
}
bool AstDivD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDivD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstDivD::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstDivD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstDivS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstDivS::broken();
}
bool AstDivS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDivS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstDivS::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstDivS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstDot::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp()) || privateTypeTest<AstNodeDType>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp()) || privateTypeTest<AstNodeDType>(rhsp())));
    return AstDot::broken();
}
bool AstDot::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstNodeDType>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstDot::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstDot::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstDot::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstDpiExport::brokenGen() const {
    return AstDpiExport::broken();
}
bool AstDpiExport::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstDpiExport::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstDpiExport::dumpJsonGen(std::ostream& str) const {
}
void AstDpiExport::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstDumpCtl::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    return AstDumpCtl::broken();
}
bool AstDumpCtl::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstDumpCtl::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstDumpCtl::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstDumpCtl::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstDynArrayDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_refDTypep && !m_refDTypep->brokeExists());
    BROKEN_RTN(m_refDTypep && !(privateTypeTest<AstNodeDType>(m_refDTypep)));
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    return AstDynArrayDType::broken();
}
bool AstDynArrayDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstDynArrayDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_refDTypep && m_refDTypep->clonep()) m_refDTypep = m_refDTypep->clonep();
}
void AstDynArrayDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_refDTypep), "refDTypep");}
void AstDynArrayDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "refDTypep", m_refDTypep);
}
void AstDynArrayDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
}
const char* AstElabDisplay::brokenGen() const {
    BROKEN_RTN(fmtp() && !(privateTypeTest<AstSFormatF>(fmtp())));
    return AstElabDisplay::broken();
}
bool AstElabDisplay::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstSFormatF>(newp))) return true;
    return false;
}
void AstElabDisplay::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstElabDisplay::dumpJsonGen(std::ostream& str) const {
}
void AstElabDisplay::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fmtp(), "fmtp", indent);
}
const char* AstEmpty::brokenGen() const {
    return AstEmpty::broken();
}
bool AstEmpty::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstEmpty::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstEmpty::dumpJsonGen(std::ostream& str) const {
}
void AstEmpty::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstEmptyQueue::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstEmptyQueue::broken();
}
bool AstEmptyQueue::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstEmptyQueue::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstEmptyQueue::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstEmptyQueue::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstEmptyQueueDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    return AstEmptyQueueDType::broken();
}
bool AstEmptyQueueDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstEmptyQueueDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
}
void AstEmptyQueueDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
}
void AstEmptyQueueDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstEnumDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_refDTypep && !m_refDTypep->brokeExists());
    BROKEN_RTN(m_refDTypep && !(privateTypeTest<AstNodeDType>(m_refDTypep)));
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    BROKEN_RTN(itemsp() && !(privateTypeTest<AstEnumItem>(itemsp())));
    return AstEnumDType::broken();
}
bool AstEnumDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstEnumItem>(newp))) return true;
    return false;
}
void AstEnumDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_refDTypep && m_refDTypep->clonep()) m_refDTypep = m_refDTypep->clonep();
}
void AstEnumDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_refDTypep), "refDTypep");}
void AstEnumDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "refDTypep", m_refDTypep);
}
void AstEnumDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
}
const char* AstEnumItem::brokenGen() const {
    BROKEN_RTN(rangep() && !(privateTypeTest<AstRange>(rangep())));
    BROKEN_RTN(valuep() && !(privateTypeTest<AstNodeExpr>(valuep())));
    return AstEnumItem::broken();
}
bool AstEnumItem::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstRange>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstEnumItem::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstEnumItem::dumpJsonGen(std::ostream& str) const {
}
void AstEnumItem::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rangep(), "rangep", indent);
    dumpNodeListJson(str, valuep(), "valuep", indent);
}
const char* AstEnumItemRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(m_itemp && !m_itemp->brokeExists());
    BROKEN_RTN(m_itemp && !(privateTypeTest<AstEnumItem>(m_itemp)));
    BROKEN_RTN(m_classOrPackagep && !m_classOrPackagep->brokeExists());
    BROKEN_RTN(m_classOrPackagep && !(privateTypeTest<AstNodeModule>(m_classOrPackagep)));
    return AstEnumItemRef::broken();
}
bool AstEnumItemRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstEnumItemRef::cloneRelinkGen() {
    AstNodeExpr::cloneRelinkGen();
    if (m_itemp && m_itemp->clonep()) m_itemp = m_itemp->clonep();
    if (m_classOrPackagep && m_classOrPackagep->clonep()) m_classOrPackagep = m_classOrPackagep->clonep();
}
void AstEnumItemRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_itemp), "itemp");    f(reinterpret_cast<AstNode**>(&m_classOrPackagep), "classOrPackagep");}
void AstEnumItemRef::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
    dumpJsonPtr(str, "itemp", m_itemp);
    dumpJsonPtr(str, "classOrPackagep", m_classOrPackagep);
}
void AstEnumItemRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstEq::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiCom::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstEq::broken();
}
bool AstEq::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstEq::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiCom::foreachLink(f);
}
void AstEq::dumpJsonGen(std::ostream& str) const {
    AstNodeBiCom::dumpJson(str);
}
void AstEq::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstEqCase::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiCom::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstEqCase::broken();
}
bool AstEqCase::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstEqCase::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiCom::foreachLink(f);
}
void AstEqCase::dumpJsonGen(std::ostream& str) const {
    AstNodeBiCom::dumpJson(str);
}
void AstEqCase::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstEqD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiCom::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstEqD::broken();
}
bool AstEqD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstEqD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiCom::foreachLink(f);
}
void AstEqD::dumpJsonGen(std::ostream& str) const {
    AstNodeBiCom::dumpJson(str);
}
void AstEqD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstEqN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiCom::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstEqN::broken();
}
bool AstEqN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstEqN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiCom::foreachLink(f);
}
void AstEqN::dumpJsonGen(std::ostream& str) const {
    AstNodeBiCom::dumpJson(str);
}
void AstEqN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstEqT::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiCom::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstEqT::broken();
}
bool AstEqT::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstEqT::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiCom::foreachLink(f);
}
void AstEqT::dumpJsonGen(std::ostream& str) const {
    AstNodeBiCom::dumpJson(str);
}
void AstEqT::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstEqWild::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstEqWild::broken();
}
bool AstEqWild::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstEqWild::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstEqWild::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstEqWild::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstEventControl::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstEventControl::broken();
}
bool AstEventControl::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstEventControl::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstEventControl::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstEventControl::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstExecGraph::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstExecGraph::broken();
}
bool AstExecGraph::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstExecGraph::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstExecGraph::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstExecGraph::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstExpD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstExpD::broken();
}
bool AstExpD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstExpD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstExpD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstExpD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstExprStmt::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(resultp() && !(privateTypeTest<AstNodeExpr>(resultp())));
    return AstExprStmt::broken();
}
bool AstExprStmt::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstExprStmt::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstExprStmt::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstExprStmt::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
    dumpNodeListJson(str, resultp(), "resultp", indent);
}
const char* AstExtend::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstExtend::broken();
}
bool AstExtend::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstExtend::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstExtend::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstExtend::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstExtendS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstExtendS::broken();
}
bool AstExtendS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstExtendS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstExtendS::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstExtendS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstFClose::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(filep() && !(privateTypeTest<AstNodeExpr>(filep())));
    return AstFClose::broken();
}
bool AstFClose::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstFClose::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstFClose::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstFClose::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, filep(), "filep", indent);
}
const char* AstFEof::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstFEof::broken();
}
bool AstFEof::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstFEof::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstFEof::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstFEof::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstFError::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstFError::broken();
}
bool AstFError::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstFError::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstFError::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstFError::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, filep(), "filep", indent);
    dumpNodeListJson(str, strp(), "strp", indent);
}
const char* AstFFlush::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(filep() && !(privateTypeTest<AstNodeExpr>(filep())));
    return AstFFlush::broken();
}
bool AstFFlush::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstFFlush::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstFFlush::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstFFlush::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, filep(), "filep", indent);
}
const char* AstFGetC::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstFGetC::broken();
}
bool AstFGetC::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstFGetC::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstFGetC::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstFGetC::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstFGetS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstFGetS::broken();
}
bool AstFGetS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstFGetS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstFGetS::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstFGetS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstFOpen::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(filenamep() && !(privateTypeTest<AstNodeExpr>(filenamep())));
    BROKEN_RTN(modep() && !(privateTypeTest<AstNodeExpr>(modep())));
    return AstFOpen::broken();
}
bool AstFOpen::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstFOpen::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstFOpen::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstFOpen::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, filenamep(), "filenamep", indent);
    dumpNodeListJson(str, modep(), "modep", indent);
}
const char* AstFOpenMcd::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(filenamep() && !(privateTypeTest<AstNodeExpr>(filenamep())));
    return AstFOpenMcd::broken();
}
bool AstFOpenMcd::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstFOpenMcd::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstFOpenMcd::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstFOpenMcd::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, filenamep(), "filenamep", indent);
}
const char* AstFRead::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstFRead::broken();
}
bool AstFRead::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstFRead::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstFRead::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstFRead::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, memp(), "memp", indent);
    dumpNodeListJson(str, filep(), "filep", indent);
    dumpNodeListJson(str, startp(), "startp", indent);
    dumpNodeListJson(str, countp(), "countp", indent);
}
const char* AstFRewind::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstFRewind::broken();
}
bool AstFRewind::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstFRewind::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstFRewind::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstFRewind::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, filep(), "filep", indent);
}
const char* AstFScanF::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstFScanF::broken();
}
bool AstFScanF::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstFScanF::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstFScanF::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstFScanF::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprsp(), "exprsp", indent);
    dumpNodeListJson(str, filep(), "filep", indent);
}
const char* AstFSeek::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstFSeek::broken();
}
bool AstFSeek::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstFSeek::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstFSeek::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstFSeek::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, filep(), "filep", indent);
    dumpNodeListJson(str, offset(), "offset", indent);
    dumpNodeListJson(str, operation(), "operation", indent);
}
const char* AstFTell::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstFTell::broken();
}
bool AstFTell::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstFTell::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstFTell::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstFTell::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, filep(), "filep", indent);
}
const char* AstFUngetC::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstFUngetC::broken();
}
bool AstFUngetC::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstFUngetC::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstFUngetC::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstFUngetC::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstFalling::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    return AstFalling::broken();
}
bool AstFalling::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstFalling::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstFalling::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstFalling::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstFell::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstFell::broken();
}
bool AstFell::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstFell::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstFell::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstFell::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
}
const char* AstFinal::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeProcedure::brokenGen());
    return AstFinal::broken();
}
bool AstFinal::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstFinal::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeProcedure::foreachLink(f);
}
void AstFinal::dumpJsonGen(std::ostream& str) const {
    AstNodeProcedure::dumpJson(str);
}
void AstFinal::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstFinish::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstFinish::broken();
}
bool AstFinish::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstFinish::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstFinish::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstFinish::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstFinishFork::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstFinishFork::broken();
}
bool AstFinishFork::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstFinishFork::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstFinishFork::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstFinishFork::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstFireEvent::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(operandp() && !(privateTypeTest<AstNodeExpr>(operandp())));
    return AstFireEvent::broken();
}
bool AstFireEvent::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstFireEvent::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstFireEvent::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstFireEvent::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, operandp(), "operandp", indent);
}
const char* AstFloorD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstFloorD::broken();
}
bool AstFloorD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstFloorD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstFloorD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstFloorD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstForeach::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeForeach::brokenGen());
    return AstForeach::broken();
}
bool AstForeach::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstForeach::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeForeach::foreachLink(f);
}
void AstForeach::dumpJsonGen(std::ostream& str) const {
    AstNodeForeach::dumpJson(str);
}
void AstForeach::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, arrayp(), "arrayp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstFork::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBlock::brokenGen());
    BROKEN_RTN(forksp() && !(privateTypeTest<AstBegin>(forksp())));
    BROKEN_RTN(parentProcessp() && !(privateTypeTest<AstVarRef>(parentProcessp())));
    return AstFork::broken();
}
bool AstFork::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op3p() && !(privateTypeTest<AstBegin>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstVarRef>(newp))) return true;
    return false;
}
void AstFork::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBlock::foreachLink(f);
}
void AstFork::dumpJsonGen(std::ostream& str) const {
    AstNodeBlock::dumpJson(str);
}
void AstFork::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, declsp(), "declsp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
    dumpNodeListJson(str, forksp(), "forksp", indent);
    dumpNodeListJson(str, parentProcessp(), "parentProcessp", indent);
}
const char* AstFunc::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeFTask::brokenGen());
    BROKEN_RTN(scopeNamep() && !(privateTypeTest<AstScopeName>(scopeNamep())));
    return AstFunc::broken();
}
bool AstFunc::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op4p() && !(privateTypeTest<AstScopeName>(newp))) return true;
    return false;
}
void AstFunc::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeFTask::foreachLink(f);
}
void AstFunc::dumpJsonGen(std::ostream& str) const {
    AstNodeFTask::dumpJson(str);
}
void AstFunc::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fvarp(), "fvarp", indent);
    dumpNodeListJson(str, classOrPackagep(), "classOrPackagep", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
    dumpNodeListJson(str, scopeNamep(), "scopeNamep", indent);
}
const char* AstFuncRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeFTaskRef::brokenGen());
    BROKEN_RTN(pinsp() && !(privateTypeTest<AstNodeExpr>(pinsp())));
    BROKEN_RTN(scopeNamep() && !(privateTypeTest<AstScopeName>(scopeNamep())));
    return AstFuncRef::broken();
}
bool AstFuncRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstScopeName>(newp))) return true;
    return false;
}
void AstFuncRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeFTaskRef::foreachLink(f);
}
void AstFuncRef::dumpJsonGen(std::ostream& str) const {
    AstNodeFTaskRef::dumpJson(str);
}
void AstFuncRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, namep(), "namep", indent);
    dumpNodeListJson(str, pinsp(), "pinsp", indent);
    dumpNodeListJson(str, scopeNamep(), "scopeNamep", indent);
}
const char* AstFuture::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstFuture::broken();
}
bool AstFuture::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstFuture::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstFuture::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstFuture::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
}
const char* AstGatePin::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    BROKEN_RTN(rangep() && !(privateTypeTest<AstRange>(rangep())));
    return AstGatePin::broken();
}
bool AstGatePin::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstRange>(newp))) return true;
    return false;
}
void AstGatePin::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstGatePin::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstGatePin::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
    dumpNodeListJson(str, rangep(), "rangep", indent);
}
const char* AstGenBlock::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeGen::brokenGen());
    return AstGenBlock::broken();
}
bool AstGenBlock::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstGenBlock::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeGen::foreachLink(f);
}
void AstGenBlock::dumpJsonGen(std::ostream& str) const {
    AstNodeGen::dumpJson(str);
}
void AstGenBlock::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, genforp(), "genforp", indent);
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
}
const char* AstGenCase::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeGen::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    BROKEN_RTN(itemsp() && !(privateTypeTest<AstGenCaseItem>(itemsp())));
    return AstGenCase::broken();
}
bool AstGenCase::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstGenCaseItem>(newp))) return true;
    return false;
}
void AstGenCase::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeGen::foreachLink(f);
}
void AstGenCase::dumpJsonGen(std::ostream& str) const {
    AstNodeGen::dumpJson(str);
}
void AstGenCase::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
}
const char* AstGenCaseItem::brokenGen() const {
    BROKEN_RTN(condsp() && !(privateTypeTest<AstNodeExpr>(condsp())));
    return AstGenCaseItem::broken();
}
bool AstGenCaseItem::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGenCaseItem::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstGenCaseItem::dumpJsonGen(std::ostream& str) const {
}
void AstGenCaseItem::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, condsp(), "condsp", indent);
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
}
const char* AstGenFor::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeGen::brokenGen());
    BROKEN_RTN(condp() && !(privateTypeTest<AstNodeExpr>(condp())));
    return AstGenFor::broken();
}
bool AstGenFor::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGenFor::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeGen::foreachLink(f);
}
void AstGenFor::dumpJsonGen(std::ostream& str) const {
    AstNodeGen::dumpJson(str);
}
void AstGenFor::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, initsp(), "initsp", indent);
    dumpNodeListJson(str, condp(), "condp", indent);
    dumpNodeListJson(str, incsp(), "incsp", indent);
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
}
const char* AstGenIf::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeGen::brokenGen());
    BROKEN_RTN(condp() && !(privateTypeTest<AstNodeExpr>(condp())));
    return AstGenIf::broken();
}
bool AstGenIf::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGenIf::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeGen::foreachLink(f);
}
void AstGenIf::dumpJsonGen(std::ostream& str) const {
    AstNodeGen::dumpJson(str);
}
void AstGenIf::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, condp(), "condp", indent);
    dumpNodeListJson(str, thensp(), "thensp", indent);
    dumpNodeListJson(str, elsesp(), "elsesp", indent);
}
const char* AstGetcN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstGetcN::broken();
}
bool AstGetcN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGetcN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstGetcN::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstGetcN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstGetcRefN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstGetcRefN::broken();
}
bool AstGetcRefN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGetcRefN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstGetcRefN::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstGetcRefN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstGt::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstGt::broken();
}
bool AstGt::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGt::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstGt::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstGt::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstGtD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstGtD::broken();
}
bool AstGtD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGtD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstGtD::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstGtD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstGtN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstGtN::broken();
}
bool AstGtN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGtN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstGtN::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstGtN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstGtS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstGtS::broken();
}
bool AstGtS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGtS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstGtS::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstGtS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstGte::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstGte::broken();
}
bool AstGte::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGte::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstGte::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstGte::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstGteD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstGteD::broken();
}
bool AstGteD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGteD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstGteD::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstGteD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstGteN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstGteN::broken();
}
bool AstGteN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGteN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstGteN::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstGteN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstGteS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstGteS::broken();
}
bool AstGteS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstGteS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstGteS::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstGteS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstHypotD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemBiopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstHypotD::broken();
}
bool AstHypotD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstHypotD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemBiopD::foreachLink(f);
}
void AstHypotD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemBiopD::dumpJson(str);
}
void AstHypotD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstISToRD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstISToRD::broken();
}
bool AstISToRD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstISToRD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstISToRD::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstISToRD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstIToRD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstIToRD::broken();
}
bool AstIToRD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstIToRD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstIToRD::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstIToRD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstIf::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeIf::brokenGen());
    BROKEN_RTN(condp() && !(privateTypeTest<AstNodeExpr>(condp())));
    return AstIf::broken();
}
bool AstIf::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstIf::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeIf::foreachLink(f);
}
void AstIf::dumpJsonGen(std::ostream& str) const {
    AstNodeIf::dumpJson(str);
}
void AstIf::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, condp(), "condp", indent);
    dumpNodeListJson(str, thensp(), "thensp", indent);
    dumpNodeListJson(str, elsesp(), "elsesp", indent);
}
const char* AstIface::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeModule::brokenGen());
    return AstIface::broken();
}
bool AstIface::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstIface::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeModule::foreachLink(f);
}
void AstIface::dumpJsonGen(std::ostream& str) const {
    AstNodeModule::dumpJson(str);
}
void AstIface::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, inlinesp(), "inlinesp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstIfaceGenericDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    return AstIfaceGenericDType::broken();
}
bool AstIfaceGenericDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstIfaceGenericDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
}
void AstIfaceGenericDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
}
void AstIfaceGenericDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstIfaceRefDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_ifacep && !m_ifacep->brokeExists());
    BROKEN_RTN(m_ifacep && !(privateTypeTest<AstIface>(m_ifacep)));
    BROKEN_RTN(m_cellp && !m_cellp->brokeExists());
    BROKEN_RTN(m_cellp && !(privateTypeTest<AstCell>(m_cellp)));
    BROKEN_RTN(m_modportp && !m_modportp->brokeExists());
    BROKEN_RTN(m_modportp && !(privateTypeTest<AstModport>(m_modportp)));
    BROKEN_RTN(paramsp() && !(privateTypeTest<AstPin>(paramsp())));
    return AstIfaceRefDType::broken();
}
bool AstIfaceRefDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstPin>(newp))) return true;
    return false;
}
void AstIfaceRefDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_ifacep && m_ifacep->clonep()) m_ifacep = m_ifacep->clonep();
    if (m_cellp && m_cellp->clonep()) m_cellp = m_cellp->clonep();
    if (m_modportp && m_modportp->clonep()) m_modportp = m_modportp->clonep();
}
void AstIfaceRefDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_ifacep), "ifacep");    f(reinterpret_cast<AstNode**>(&m_cellp), "cellp");    f(reinterpret_cast<AstNode**>(&m_modportp), "modportp");}
void AstIfaceRefDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "ifacep", m_ifacep);
    dumpJsonPtr(str, "cellp", m_cellp);
    dumpJsonPtr(str, "modportp", m_modportp);
}
void AstIfaceRefDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, paramsp(), "paramsp", indent);
}
const char* AstImplication::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstImplication::broken();
}
bool AstImplication::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstImplication::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstImplication::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstImplication::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
}
const char* AstImplicit::brokenGen() const {
    return AstImplicit::broken();
}
bool AstImplicit::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstImplicit::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstImplicit::dumpJsonGen(std::ostream& str) const {
}
void AstImplicit::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprsp(), "exprsp", indent);
}
const char* AstInferredDisable::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeTermop::brokenGen());
    return AstInferredDisable::broken();
}
bool AstInferredDisable::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstInferredDisable::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeTermop::foreachLink(f);
}
void AstInferredDisable::dumpJsonGen(std::ostream& str) const {
    AstNodeTermop::dumpJson(str);
}
void AstInferredDisable::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstInitArray::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(defaultp() && !(privateTypeTest<AstNodeExpr>(defaultp())));
    return AstInitArray::broken();
}
bool AstInitArray::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstInitArray::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstInitArray::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstInitArray::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, defaultp(), "defaultp", indent);
    dumpNodeListJson(str, initsp(), "initsp", indent);
}
const char* AstInitItem::brokenGen() const {
    BROKEN_RTN(valuep() && !(privateTypeTest<AstNodeExpr>(valuep())));
    return AstInitItem::broken();
}
bool AstInitItem::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstInitItem::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstInitItem::dumpJsonGen(std::ostream& str) const {
}
void AstInitItem::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, valuep(), "valuep", indent);
}
const char* AstInitial::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeProcedure::brokenGen());
    return AstInitial::broken();
}
bool AstInitial::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstInitial::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeProcedure::foreachLink(f);
}
void AstInitial::dumpJsonGen(std::ostream& str) const {
    AstNodeProcedure::dumpJson(str);
}
void AstInitial::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstInitialAutomatic::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeProcedure::brokenGen());
    return AstInitialAutomatic::broken();
}
bool AstInitialAutomatic::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstInitialAutomatic::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeProcedure::foreachLink(f);
}
void AstInitialAutomatic::dumpJsonGen(std::ostream& str) const {
    AstNodeProcedure::dumpJson(str);
}
void AstInitialAutomatic::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstInitialStatic::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeProcedure::brokenGen());
    return AstInitialStatic::broken();
}
bool AstInitialStatic::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstInitialStatic::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeProcedure::foreachLink(f);
}
void AstInitialStatic::dumpJsonGen(std::ostream& str) const {
    AstNodeProcedure::dumpJson(str);
}
void AstInitialStatic::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstInside::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    BROKEN_RTN(itemsp() && !(privateTypeTest<AstNodeExpr>(itemsp())));
    return AstInside::broken();
}
bool AstInside::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstInside::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstInside::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstInside::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
}
const char* AstInsideRange::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstInsideRange::broken();
}
bool AstInsideRange::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstInsideRange::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstInsideRange::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstInsideRange::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstIntfRef::brokenGen() const {
    return AstIntfRef::broken();
}
bool AstIntfRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstIntfRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstIntfRef::dumpJsonGen(std::ostream& str) const {
}
void AstIntfRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstIsUnbounded::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstIsUnbounded::broken();
}
bool AstIsUnbounded::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstIsUnbounded::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstIsUnbounded::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstIsUnbounded::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstIsUnknown::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstIsUnknown::broken();
}
bool AstIsUnknown::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstIsUnknown::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstIsUnknown::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstIsUnknown::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstJumpBlock::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstJumpBlock::broken();
}
bool AstJumpBlock::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstJumpBlock::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstJumpBlock::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstJumpBlock::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstJumpGo::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(!m_blockp);
    BROKEN_RTN(!m_blockp->brokeExists());
    BROKEN_RTN(m_blockp && !(privateTypeTest<AstJumpBlock>(m_blockp)));
    return AstJumpGo::broken();
}
bool AstJumpGo::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstJumpGo::cloneRelinkGen() {
    AstNodeStmt::cloneRelinkGen();
    if (m_blockp && m_blockp->clonep()) m_blockp = m_blockp->clonep();
}
void AstJumpGo::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_blockp), "blockp");}
void AstJumpGo::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
    dumpJsonPtr(str, "blockp", m_blockp);
}
void AstJumpGo::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstLambdaArgRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstLambdaArgRef::broken();
}
bool AstLambdaArgRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstLambdaArgRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstLambdaArgRef::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstLambdaArgRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstLenN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstLenN::broken();
}
bool AstLenN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLenN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstLenN::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstLenN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstLet::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeFTask::brokenGen());
    BROKEN_RTN(scopeNamep() && !(privateTypeTest<AstScopeName>(scopeNamep())));
    return AstLet::broken();
}
bool AstLet::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op4p() && !(privateTypeTest<AstScopeName>(newp))) return true;
    return false;
}
void AstLet::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeFTask::foreachLink(f);
}
void AstLet::dumpJsonGen(std::ostream& str) const {
    AstNodeFTask::dumpJson(str);
}
void AstLet::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fvarp(), "fvarp", indent);
    dumpNodeListJson(str, classOrPackagep(), "classOrPackagep", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
    dumpNodeListJson(str, scopeNamep(), "scopeNamep", indent);
}
const char* AstLibrary::brokenGen() const {
    BROKEN_RTN(filesp() && !(privateTypeTest<AstNodeExpr>(filesp())));
    BROKEN_RTN(incdirsp() && !(privateTypeTest<AstNodeExpr>(incdirsp())));
    return AstLibrary::broken();
}
bool AstLibrary::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLibrary::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstLibrary::dumpJsonGen(std::ostream& str) const {
}
void AstLibrary::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, filesp(), "filesp", indent);
    dumpNodeListJson(str, incdirsp(), "incdirsp", indent);
}
const char* AstLog10D::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstLog10D::broken();
}
bool AstLog10D::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLog10D::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstLog10D::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstLog10D::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstLogAnd::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstLogAnd::broken();
}
bool AstLogAnd::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLogAnd::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstLogAnd::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstLogAnd::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstLogD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstLogD::broken();
}
bool AstLogD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLogD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstLogD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstLogD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstLogEq::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiCom::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstLogEq::broken();
}
bool AstLogEq::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLogEq::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiCom::foreachLink(f);
}
void AstLogEq::dumpJsonGen(std::ostream& str) const {
    AstNodeBiCom::dumpJson(str);
}
void AstLogEq::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstLogIf::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstLogIf::broken();
}
bool AstLogIf::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLogIf::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstLogIf::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstLogIf::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstLogNot::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstLogNot::broken();
}
bool AstLogNot::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLogNot::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstLogNot::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstLogNot::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstLogOr::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstLogOr::broken();
}
bool AstLogOr::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLogOr::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstLogOr::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstLogOr::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstLoop::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstLoop::broken();
}
bool AstLoop::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstLoop::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstLoop::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstLoop::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
    dumpNodeListJson(str, contsp(), "contsp", indent);
}
const char* AstLoopTest::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(!m_loopp);
    BROKEN_RTN(!m_loopp->brokeExists());
    BROKEN_RTN(m_loopp && !(privateTypeTest<AstLoop>(m_loopp)));
    BROKEN_RTN(condp() && !(privateTypeTest<AstNodeExpr>(condp())));
    return AstLoopTest::broken();
}
bool AstLoopTest::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLoopTest::cloneRelinkGen() {
    AstNodeStmt::cloneRelinkGen();
    if (m_loopp && m_loopp->clonep()) m_loopp = m_loopp->clonep();
}
void AstLoopTest::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_loopp), "loopp");}
void AstLoopTest::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
    dumpJsonPtr(str, "loopp", m_loopp);
}
void AstLoopTest::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, condp(), "condp", indent);
}
const char* AstLt::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstLt::broken();
}
bool AstLt::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLt::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstLt::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstLt::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstLtD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstLtD::broken();
}
bool AstLtD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLtD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstLtD::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstLtD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstLtN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstLtN::broken();
}
bool AstLtN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLtN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstLtN::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstLtN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstLtS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstLtS::broken();
}
bool AstLtS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLtS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstLtS::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstLtS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstLte::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstLte::broken();
}
bool AstLte::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLte::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstLte::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstLte::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstLteD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstLteD::broken();
}
bool AstLteD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLteD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstLteD::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstLteD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstLteN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstLteN::broken();
}
bool AstLteN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLteN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstLteN::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstLteN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstLteS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstLteS::broken();
}
bool AstLteS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstLteS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstLteS::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstLteS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstMemberDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_refDTypep && !m_refDTypep->brokeExists());
    BROKEN_RTN(m_refDTypep && !(privateTypeTest<AstNodeDType>(m_refDTypep)));
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    return AstMemberDType::broken();
}
bool AstMemberDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstMemberDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_refDTypep && m_refDTypep->clonep()) m_refDTypep = m_refDTypep->clonep();
}
void AstMemberDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_refDTypep), "refDTypep");}
void AstMemberDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "refDTypep", m_refDTypep);
}
void AstMemberDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
    dumpNodeListJson(str, valuep(), "valuep", indent);
}
const char* AstMemberSel::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(m_varp && !m_varp->brokeExists());
    BROKEN_RTN(m_varp && !(privateTypeTest<AstVar>(m_varp)));
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    return AstMemberSel::broken();
}
bool AstMemberSel::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstMemberSel::cloneRelinkGen() {
    AstNodeExpr::cloneRelinkGen();
    if (m_varp && m_varp->clonep()) m_varp = m_varp->clonep();
}
void AstMemberSel::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_varp), "varp");}
void AstMemberSel::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
    dumpJsonPtr(str, "varp", m_varp);
}
void AstMemberSel::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
}
const char* AstMethodCall::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeFTaskRef::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(pinsp() && !(privateTypeTest<AstNodeExpr>(pinsp())));
    BROKEN_RTN(scopeNamep() && !(privateTypeTest<AstScopeName>(scopeNamep())));
    return AstMethodCall::broken();
}
bool AstMethodCall::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstScopeName>(newp))) return true;
    return false;
}
void AstMethodCall::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeFTaskRef::foreachLink(f);
}
void AstMethodCall::dumpJsonGen(std::ostream& str) const {
    AstNodeFTaskRef::dumpJson(str);
}
void AstMethodCall::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, namep(), "namep", indent);
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, pinsp(), "pinsp", indent);
    dumpNodeListJson(str, scopeNamep(), "scopeNamep", indent);
}
const char* AstModDiv::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstModDiv::broken();
}
bool AstModDiv::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstModDiv::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstModDiv::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstModDiv::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstModDivS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstModDivS::broken();
}
bool AstModDivS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstModDivS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstModDivS::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstModDivS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstModport::brokenGen() const {
    return AstModport::broken();
}
bool AstModport::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstModport::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstModport::dumpJsonGen(std::ostream& str) const {
}
void AstModport::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, varsp(), "varsp", indent);
}
const char* AstModportClockingRef::brokenGen() const {
    BROKEN_RTN(m_clockingp && !m_clockingp->brokeExists());
    BROKEN_RTN(m_clockingp && !(privateTypeTest<AstClocking>(m_clockingp)));
    return AstModportClockingRef::broken();
}
bool AstModportClockingRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstModportClockingRef::cloneRelinkGen() {
    if (m_clockingp && m_clockingp->clonep()) m_clockingp = m_clockingp->clonep();
}
void AstModportClockingRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_clockingp), "clockingp");}
void AstModportClockingRef::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "clockingp", m_clockingp);
}
void AstModportClockingRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstModportFTaskRef::brokenGen() const {
    BROKEN_RTN(m_ftaskp && !m_ftaskp->brokeExists());
    BROKEN_RTN(m_ftaskp && !(privateTypeTest<AstNodeFTask>(m_ftaskp)));
    return AstModportFTaskRef::broken();
}
bool AstModportFTaskRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstModportFTaskRef::cloneRelinkGen() {
    if (m_ftaskp && m_ftaskp->clonep()) m_ftaskp = m_ftaskp->clonep();
}
void AstModportFTaskRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_ftaskp), "ftaskp");}
void AstModportFTaskRef::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "ftaskp", m_ftaskp);
}
void AstModportFTaskRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstModportVarRef::brokenGen() const {
    BROKEN_RTN(m_varp && !m_varp->brokeExists());
    BROKEN_RTN(m_varp && !(privateTypeTest<AstVar>(m_varp)));
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    return AstModportVarRef::broken();
}
bool AstModportVarRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstModportVarRef::cloneRelinkGen() {
    if (m_varp && m_varp->clonep()) m_varp = m_varp->clonep();
}
void AstModportVarRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_varp), "varp");}
void AstModportVarRef::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "varp", m_varp);
}
void AstModportVarRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstModule::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeModule::brokenGen());
    return AstModule::broken();
}
bool AstModule::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstModule::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeModule::foreachLink(f);
}
void AstModule::dumpJsonGen(std::ostream& str) const {
    AstNodeModule::dumpJson(str);
}
void AstModule::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, inlinesp(), "inlinesp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstMonitorOff::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstMonitorOff::broken();
}
bool AstMonitorOff::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstMonitorOff::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstMonitorOff::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstMonitorOff::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstMul::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiComAsv::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstMul::broken();
}
bool AstMul::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstMul::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiComAsv::foreachLink(f);
}
void AstMul::dumpJsonGen(std::ostream& str) const {
    AstNodeBiComAsv::dumpJson(str);
}
void AstMul::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstMulD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiComAsv::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstMulD::broken();
}
bool AstMulD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstMulD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiComAsv::foreachLink(f);
}
void AstMulD::dumpJsonGen(std::ostream& str) const {
    AstNodeBiComAsv::dumpJson(str);
}
void AstMulD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstMulS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiComAsv::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstMulS::broken();
}
bool AstMulS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstMulS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiComAsv::foreachLink(f);
}
void AstMulS::dumpJsonGen(std::ostream& str) const {
    AstNodeBiComAsv::dumpJson(str);
}
void AstMulS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNBACommitQueueDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(!m_subDTypep);
    BROKEN_RTN(!m_subDTypep->brokeExists());
    BROKEN_RTN(m_subDTypep && !(privateTypeTest<AstNodeDType>(m_subDTypep)));
    return AstNBACommitQueueDType::broken();
}
bool AstNBACommitQueueDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNBACommitQueueDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_subDTypep && m_subDTypep->clonep()) m_subDTypep = m_subDTypep->clonep();
}
void AstNBACommitQueueDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_subDTypep), "subDTypep");}
void AstNBACommitQueueDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "subDTypep", m_subDTypep);
}
void AstNBACommitQueueDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstNToI::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstNToI::broken();
}
bool AstNToI::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNToI::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstNToI::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstNToI::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstNegate::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstNegate::broken();
}
bool AstNegate::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNegate::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstNegate::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstNegate::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstNegateD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstNegateD::broken();
}
bool AstNegateD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNegateD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstNegateD::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstNegateD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstNeq::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiCom::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNeq::broken();
}
bool AstNeq::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNeq::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiCom::foreachLink(f);
}
void AstNeq::dumpJsonGen(std::ostream& str) const {
    AstNodeBiCom::dumpJson(str);
}
void AstNeq::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNeqCase::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiCom::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNeqCase::broken();
}
bool AstNeqCase::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNeqCase::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiCom::foreachLink(f);
}
void AstNeqCase::dumpJsonGen(std::ostream& str) const {
    AstNodeBiCom::dumpJson(str);
}
void AstNeqCase::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNeqD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiCom::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNeqD::broken();
}
bool AstNeqD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNeqD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiCom::foreachLink(f);
}
void AstNeqD::dumpJsonGen(std::ostream& str) const {
    AstNodeBiCom::dumpJson(str);
}
void AstNeqD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNeqN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiCom::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNeqN::broken();
}
bool AstNeqN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNeqN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiCom::foreachLink(f);
}
void AstNeqN::dumpJsonGen(std::ostream& str) const {
    AstNodeBiCom::dumpJson(str);
}
void AstNeqN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNeqT::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiCom::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNeqT::broken();
}
bool AstNeqT::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNeqT::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiCom::foreachLink(f);
}
void AstNeqT::dumpJsonGen(std::ostream& str) const {
    AstNodeBiCom::dumpJson(str);
}
void AstNeqT::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNeqWild::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNeqWild::broken();
}
bool AstNeqWild::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNeqWild::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstNeqWild::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstNeqWild::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNetlist::brokenGen() const {
    BROKEN_RTN(!m_typeTablep);
    BROKEN_RTN(!m_typeTablep->brokeExists());
    BROKEN_RTN(m_typeTablep && !(privateTypeTest<AstTypeTable>(m_typeTablep)));
    BROKEN_RTN(!m_constPoolp);
    BROKEN_RTN(!m_constPoolp->brokeExists());
    BROKEN_RTN(m_constPoolp && !(privateTypeTest<AstConstPool>(m_constPoolp)));
    BROKEN_RTN(m_dollarUnitPkgp && !m_dollarUnitPkgp->brokeExists());
    BROKEN_RTN(m_dollarUnitPkgp && !(privateTypeTest<AstPackage>(m_dollarUnitPkgp)));
    BROKEN_RTN(m_stdPackagep && !m_stdPackagep->brokeExists());
    BROKEN_RTN(m_stdPackagep && !(privateTypeTest<AstPackage>(m_stdPackagep)));
    BROKEN_RTN(m_evalp && !m_evalp->brokeExists());
    BROKEN_RTN(m_evalp && !(privateTypeTest<AstCFunc>(m_evalp)));
    BROKEN_RTN(m_evalNbap && !m_evalNbap->brokeExists());
    BROKEN_RTN(m_evalNbap && !(privateTypeTest<AstCFunc>(m_evalNbap)));
    BROKEN_RTN(m_dpiExportTriggerp && !m_dpiExportTriggerp->brokeExists());
    BROKEN_RTN(m_dpiExportTriggerp && !(privateTypeTest<AstVarScope>(m_dpiExportTriggerp)));
    BROKEN_RTN(m_delaySchedulerp && !m_delaySchedulerp->brokeExists());
    BROKEN_RTN(m_delaySchedulerp && !(privateTypeTest<AstVar>(m_delaySchedulerp)));
    BROKEN_RTN(m_nbaEventp && !m_nbaEventp->brokeExists());
    BROKEN_RTN(m_nbaEventp && !(privateTypeTest<AstVarScope>(m_nbaEventp)));
    BROKEN_RTN(m_nbaEventTriggerp && !m_nbaEventTriggerp->brokeExists());
    BROKEN_RTN(m_nbaEventTriggerp && !(privateTypeTest<AstVarScope>(m_nbaEventTriggerp)));
    BROKEN_RTN(m_topScopep && !m_topScopep->brokeExists());
    BROKEN_RTN(m_topScopep && !(privateTypeTest<AstTopScope>(m_topScopep)));
    BROKEN_RTN(modulesp() && !(privateTypeTest<AstNodeModule>(modulesp())));
    BROKEN_RTN(filesp() && !(privateTypeTest<AstNodeFile>(filesp())));
    return AstNetlist::broken();
}
bool AstNetlist::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeModule>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeFile>(newp))) return true;
    return false;
}
void AstNetlist::cloneRelinkGen() {
    if (m_typeTablep && m_typeTablep->clonep()) m_typeTablep = m_typeTablep->clonep();
    if (m_constPoolp && m_constPoolp->clonep()) m_constPoolp = m_constPoolp->clonep();
    if (m_dollarUnitPkgp && m_dollarUnitPkgp->clonep()) m_dollarUnitPkgp = m_dollarUnitPkgp->clonep();
    if (m_stdPackagep && m_stdPackagep->clonep()) m_stdPackagep = m_stdPackagep->clonep();
    if (m_evalp && m_evalp->clonep()) m_evalp = m_evalp->clonep();
    if (m_evalNbap && m_evalNbap->clonep()) m_evalNbap = m_evalNbap->clonep();
    if (m_dpiExportTriggerp && m_dpiExportTriggerp->clonep()) m_dpiExportTriggerp = m_dpiExportTriggerp->clonep();
    if (m_delaySchedulerp && m_delaySchedulerp->clonep()) m_delaySchedulerp = m_delaySchedulerp->clonep();
    if (m_nbaEventp && m_nbaEventp->clonep()) m_nbaEventp = m_nbaEventp->clonep();
    if (m_nbaEventTriggerp && m_nbaEventTriggerp->clonep()) m_nbaEventTriggerp = m_nbaEventTriggerp->clonep();
    if (m_topScopep && m_topScopep->clonep()) m_topScopep = m_topScopep->clonep();
}
void AstNetlist::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_typeTablep), "typeTablep");    f(reinterpret_cast<AstNode**>(&m_constPoolp), "constPoolp");    f(reinterpret_cast<AstNode**>(&m_dollarUnitPkgp), "dollarUnitPkgp");    f(reinterpret_cast<AstNode**>(&m_stdPackagep), "stdPackagep");    f(reinterpret_cast<AstNode**>(&m_evalp), "evalp");    f(reinterpret_cast<AstNode**>(&m_evalNbap), "evalNbap");    f(reinterpret_cast<AstNode**>(&m_dpiExportTriggerp), "dpiExportTriggerp");    f(reinterpret_cast<AstNode**>(&m_delaySchedulerp), "delaySchedulerp");    f(reinterpret_cast<AstNode**>(&m_nbaEventp), "nbaEventp");    f(reinterpret_cast<AstNode**>(&m_nbaEventTriggerp), "nbaEventTriggerp");    f(reinterpret_cast<AstNode**>(&m_topScopep), "topScopep");}
void AstNetlist::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "typeTablep", m_typeTablep);
    dumpJsonPtr(str, "constPoolp", m_constPoolp);
    dumpJsonPtr(str, "dollarUnitPkgp", m_dollarUnitPkgp);
    dumpJsonPtr(str, "stdPackagep", m_stdPackagep);
    dumpJsonPtr(str, "evalp", m_evalp);
    dumpJsonPtr(str, "evalNbap", m_evalNbap);
    dumpJsonPtr(str, "dpiExportTriggerp", m_dpiExportTriggerp);
    dumpJsonPtr(str, "delaySchedulerp", m_delaySchedulerp);
    dumpJsonPtr(str, "nbaEventp", m_nbaEventp);
    dumpJsonPtr(str, "nbaEventTriggerp", m_nbaEventTriggerp);
    dumpJsonPtr(str, "topScopep", m_topScopep);
}
void AstNetlist::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, modulesp(), "modulesp", indent);
    dumpNodeListJson(str, filesp(), "filesp", indent);
    dumpNodeListJson(str, miscsp(), "miscsp", indent);
}
const char* AstNew::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeFTaskRef::brokenGen());
    BROKEN_RTN(pinsp() && !(privateTypeTest<AstNodeExpr>(pinsp())));
    BROKEN_RTN(scopeNamep() && !(privateTypeTest<AstScopeName>(scopeNamep())));
    return AstNew::broken();
}
bool AstNew::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstScopeName>(newp))) return true;
    return false;
}
void AstNew::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeFTaskRef::foreachLink(f);
}
void AstNew::dumpJsonGen(std::ostream& str) const {
    AstNodeFTaskRef::dumpJson(str);
}
void AstNew::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, namep(), "namep", indent);
    dumpNodeListJson(str, pinsp(), "pinsp", indent);
    dumpNodeListJson(str, scopeNamep(), "scopeNamep", indent);
}
const char* AstNewCopy::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNewCopy::broken();
}
bool AstNewCopy::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNewCopy::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstNewCopy::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstNewCopy::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNewDynamic::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(sizep() && !(privateTypeTest<AstNodeExpr>(sizep())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNewDynamic::broken();
}
bool AstNewDynamic::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNewDynamic::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstNewDynamic::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstNewDynamic::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, sizep(), "sizep", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNodeArrayDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_refDTypep && !m_refDTypep->brokeExists());
    BROKEN_RTN(m_refDTypep && !(privateTypeTest<AstNodeDType>(m_refDTypep)));
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    BROKEN_RTN(rangep() && !(privateTypeTest<AstRange>(rangep())));
    return AstNodeArrayDType::broken();
}
bool AstNodeArrayDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstRange>(newp))) return true;
    return false;
}
void AstNodeArrayDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_refDTypep && m_refDTypep->clonep()) m_refDTypep = m_refDTypep->clonep();
}
void AstNodeArrayDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_refDTypep), "refDTypep");}
void AstNodeArrayDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "refDTypep", m_refDTypep);
}
void AstNodeArrayDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
    dumpNodeListJson(str, rangep(), "rangep", indent);
}
const char* AstNodeAssign::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstNodeAssign::broken();
}
bool AstNodeAssign::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeAssign::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstNodeAssign::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstNodeAssign::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, timingControlp(), "timingControlp", indent);
}
const char* AstNodeBiCom::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNodeBiCom::broken();
}
bool AstNodeBiCom::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeBiCom::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstNodeBiCom::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstNodeBiCom::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNodeBiComAsv::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiCom::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNodeBiComAsv::broken();
}
bool AstNodeBiComAsv::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeBiComAsv::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiCom::foreachLink(f);
}
void AstNodeBiComAsv::dumpJsonGen(std::ostream& str) const {
    AstNodeBiCom::dumpJson(str);
}
void AstNodeBiComAsv::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNodeBiop::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNodeBiop::broken();
}
bool AstNodeBiop::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeBiop::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstNodeBiop::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstNodeBiop::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNodeBlock::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstNodeBlock::broken();
}
bool AstNodeBlock::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNodeBlock::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstNodeBlock::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstNodeBlock::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, declsp(), "declsp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstNodeCCall::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(!m_funcp);
    BROKEN_RTN(!m_funcp->brokeExists());
    BROKEN_RTN(m_funcp && !(privateTypeTest<AstCFunc>(m_funcp)));
    BROKEN_RTN(argsp() && !(privateTypeTest<AstNodeExpr>(argsp())));
    return AstNodeCCall::broken();
}
bool AstNodeCCall::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeCCall::cloneRelinkGen() {
    AstNodeExpr::cloneRelinkGen();
    if (m_funcp && m_funcp->clonep()) m_funcp = m_funcp->clonep();
}
void AstNodeCCall::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_funcp), "funcp");}
void AstNodeCCall::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
    dumpJsonPtr(str, "funcp", m_funcp);
}
void AstNodeCCall::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, argsp(), "argsp", indent);
}
const char* AstNodeCoverDecl::brokenGen() const {
    BROKEN_RTN(m_dataDeclp && !m_dataDeclp->brokeExists());
    BROKEN_RTN(m_dataDeclp && !(privateTypeTest<AstNodeCoverDecl>(m_dataDeclp)));
    return AstNodeCoverDecl::broken();
}
bool AstNodeCoverDecl::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNodeCoverDecl::cloneRelinkGen() {
    if (m_dataDeclp && m_dataDeclp->clonep()) m_dataDeclp = m_dataDeclp->clonep();
}
void AstNodeCoverDecl::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_dataDeclp), "dataDeclp");}
void AstNodeCoverDecl::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "dataDeclp", m_dataDeclp);
}
void AstNodeCoverDecl::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstNodeCoverOrAssert::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstNodeCoverOrAssert::broken();
}
bool AstNodeCoverOrAssert::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstNodeCoverOrAssert::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstNodeCoverOrAssert::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstNodeCoverOrAssert::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, propp(), "propp", indent);
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
    dumpNodeListJson(str, passsp(), "passsp", indent);
}
const char* AstNodeDType::brokenGen() const {
    return AstNodeDType::broken();
}
bool AstNodeDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNodeDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstNodeDType::dumpJsonGen(std::ostream& str) const {
}
void AstNodeDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstNodeDistBiop::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNodeDistBiop::broken();
}
bool AstNodeDistBiop::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeDistBiop::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstNodeDistBiop::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstNodeDistBiop::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNodeDistTriop::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeTriop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    return AstNodeDistTriop::broken();
}
bool AstNodeDistTriop::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeDistTriop::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeTriop::foreachLink(f);
}
void AstNodeDistTriop::dumpJsonGen(std::ostream& str) const {
    AstNodeTriop::dumpJson(str);
}
void AstNodeDistTriop::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
}
const char* AstNodeExpr::brokenGen() const {
    return AstNodeExpr::broken();
}
bool AstNodeExpr::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNodeExpr::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstNodeExpr::dumpJsonGen(std::ostream& str) const {
}
void AstNodeExpr::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstNodeFTask::brokenGen() const {
    BROKEN_RTN(scopeNamep() && !(privateTypeTest<AstScopeName>(scopeNamep())));
    return AstNodeFTask::broken();
}
bool AstNodeFTask::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op4p() && !(privateTypeTest<AstScopeName>(newp))) return true;
    return false;
}
void AstNodeFTask::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstNodeFTask::dumpJsonGen(std::ostream& str) const {
}
void AstNodeFTask::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fvarp(), "fvarp", indent);
    dumpNodeListJson(str, classOrPackagep(), "classOrPackagep", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
    dumpNodeListJson(str, scopeNamep(), "scopeNamep", indent);
}
const char* AstNodeFTaskRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(m_taskp && !m_taskp->brokeExists());
    BROKEN_RTN(m_taskp && !(privateTypeTest<AstNodeFTask>(m_taskp)));
    BROKEN_RTN(m_classOrPackagep && !m_classOrPackagep->brokeExists());
    BROKEN_RTN(m_classOrPackagep && !(privateTypeTest<AstNodeModule>(m_classOrPackagep)));
    BROKEN_RTN(pinsp() && !(privateTypeTest<AstNodeExpr>(pinsp())));
    BROKEN_RTN(scopeNamep() && !(privateTypeTest<AstScopeName>(scopeNamep())));
    return AstNodeFTaskRef::broken();
}
bool AstNodeFTaskRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstScopeName>(newp))) return true;
    return false;
}
void AstNodeFTaskRef::cloneRelinkGen() {
    AstNodeExpr::cloneRelinkGen();
    if (m_taskp && m_taskp->clonep()) m_taskp = m_taskp->clonep();
    if (m_classOrPackagep && m_classOrPackagep->clonep()) m_classOrPackagep = m_classOrPackagep->clonep();
}
void AstNodeFTaskRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_taskp), "taskp");    f(reinterpret_cast<AstNode**>(&m_classOrPackagep), "classOrPackagep");}
void AstNodeFTaskRef::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
    dumpJsonPtr(str, "taskp", m_taskp);
    dumpJsonPtr(str, "classOrPackagep", m_classOrPackagep);
}
void AstNodeFTaskRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, namep(), "namep", indent);
    dumpNodeListJson(str, pinsp(), "pinsp", indent);
    dumpNodeListJson(str, scopeNamep(), "scopeNamep", indent);
}
const char* AstNodeFile::brokenGen() const {
    BROKEN_RTN(tblockp() && !(privateTypeTest<AstTextBlock>(tblockp())));
    return AstNodeFile::broken();
}
bool AstNodeFile::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstTextBlock>(newp))) return true;
    return false;
}
void AstNodeFile::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstNodeFile::dumpJsonGen(std::ostream& str) const {
}
void AstNodeFile::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, tblockp(), "tblockp", indent);
}
const char* AstNodeForeach::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstNodeForeach::broken();
}
bool AstNodeForeach::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNodeForeach::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstNodeForeach::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstNodeForeach::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, arrayp(), "arrayp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstNodeGen::brokenGen() const {
    return AstNodeGen::broken();
}
bool AstNodeGen::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNodeGen::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstNodeGen::dumpJsonGen(std::ostream& str) const {
}
void AstNodeGen::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstNodeIf::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(condp() && !(privateTypeTest<AstNodeExpr>(condp())));
    return AstNodeIf::broken();
}
bool AstNodeIf::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeIf::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstNodeIf::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstNodeIf::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, condp(), "condp", indent);
    dumpNodeListJson(str, thensp(), "thensp", indent);
    dumpNodeListJson(str, elsesp(), "elsesp", indent);
}
const char* AstNodeModule::brokenGen() const {
    return AstNodeModule::broken();
}
bool AstNodeModule::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNodeModule::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstNodeModule::dumpJsonGen(std::ostream& str) const {
}
void AstNodeModule::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, inlinesp(), "inlinesp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstNodePreSel::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    BROKEN_RTN(attrp() && !(privateTypeTest<AstAttrOf>(attrp())));
    return AstNodePreSel::broken();
}
bool AstNodePreSel::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstAttrOf>(newp))) return true;
    return false;
}
void AstNodePreSel::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstNodePreSel::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstNodePreSel::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
    dumpNodeListJson(str, attrp(), "attrp", indent);
}
const char* AstNodeProcedure::brokenGen() const {
    return AstNodeProcedure::broken();
}
bool AstNodeProcedure::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNodeProcedure::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstNodeProcedure::dumpJsonGen(std::ostream& str) const {
}
void AstNodeProcedure::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstNodeQuadop::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    BROKEN_RTN(fhsp() && !(privateTypeTest<AstNodeExpr>(fhsp())));
    return AstNodeQuadop::broken();
}
bool AstNodeQuadop::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeQuadop::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstNodeQuadop::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstNodeQuadop::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
    dumpNodeListJson(str, fhsp(), "fhsp", indent);
}
const char* AstNodeRange::brokenGen() const {
    return AstNodeRange::broken();
}
bool AstNodeRange::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNodeRange::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstNodeRange::dumpJsonGen(std::ostream& str) const {
}
void AstNodeRange::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstNodeReadWriteMem::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(filenamep() && !(privateTypeTest<AstNodeExpr>(filenamep())));
    BROKEN_RTN(memp() && !(privateTypeTest<AstNodeExpr>(memp())));
    BROKEN_RTN(lsbp() && !(privateTypeTest<AstNodeExpr>(lsbp())));
    BROKEN_RTN(msbp() && !(privateTypeTest<AstNodeExpr>(msbp())));
    return AstNodeReadWriteMem::broken();
}
bool AstNodeReadWriteMem::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeReadWriteMem::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstNodeReadWriteMem::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstNodeReadWriteMem::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, filenamep(), "filenamep", indent);
    dumpNodeListJson(str, memp(), "memp", indent);
    dumpNodeListJson(str, lsbp(), "lsbp", indent);
    dumpNodeListJson(str, msbp(), "msbp", indent);
}
const char* AstNodeSel::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(bitp() && !(privateTypeTest<AstNodeExpr>(bitp())));
    return AstNodeSel::broken();
}
bool AstNodeSel::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeSel::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstNodeSel::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstNodeSel::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, bitp(), "bitp", indent);
}
const char* AstNodeStmt::brokenGen() const {
    return AstNodeStmt::broken();
}
bool AstNodeStmt::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNodeStmt::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstNodeStmt::dumpJsonGen(std::ostream& str) const {
}
void AstNodeStmt::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstNodeStream::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNodeStream::broken();
}
bool AstNodeStream::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeStream::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstNodeStream::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstNodeStream::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNodeSystemBiopD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstNodeSystemBiopD::broken();
}
bool AstNodeSystemBiopD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeSystemBiopD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstNodeSystemBiopD::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstNodeSystemBiopD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstNodeSystemUniopD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstNodeSystemUniopD::broken();
}
bool AstNodeSystemUniopD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeSystemUniopD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstNodeSystemUniopD::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstNodeSystemUniopD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstNodeTermop::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstNodeTermop::broken();
}
bool AstNodeTermop::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNodeTermop::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstNodeTermop::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstNodeTermop::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstNodeTriop::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    return AstNodeTriop::broken();
}
bool AstNodeTriop::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeTriop::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstNodeTriop::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstNodeTriop::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
}
const char* AstNodeUOrStructDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_classOrPackagep && !m_classOrPackagep->brokeExists());
    BROKEN_RTN(m_classOrPackagep && !(privateTypeTest<AstNodeModule>(m_classOrPackagep)));
    BROKEN_RTN(membersp() && !(privateTypeTest<AstMemberDType>(membersp())));
    return AstNodeUOrStructDType::broken();
}
bool AstNodeUOrStructDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstMemberDType>(newp))) return true;
    return false;
}
void AstNodeUOrStructDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_classOrPackagep && m_classOrPackagep->clonep()) m_classOrPackagep = m_classOrPackagep->clonep();
}
void AstNodeUOrStructDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_classOrPackagep), "classOrPackagep");}
void AstNodeUOrStructDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "classOrPackagep", m_classOrPackagep);
}
void AstNodeUOrStructDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, membersp(), "membersp", indent);
}
const char* AstNodeUniop::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstNodeUniop::broken();
}
bool AstNodeUniop::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNodeUniop::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstNodeUniop::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstNodeUniop::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstNodeVarRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(m_varp && !m_varp->brokeExists());
    BROKEN_RTN(m_varp && !(privateTypeTest<AstVar>(m_varp)));
    BROKEN_RTN(m_varScopep && !m_varScopep->brokeExists());
    BROKEN_RTN(m_varScopep && !(privateTypeTest<AstVarScope>(m_varScopep)));
    BROKEN_RTN(m_classOrPackagep && !m_classOrPackagep->brokeExists());
    BROKEN_RTN(m_classOrPackagep && !(privateTypeTest<AstNodeModule>(m_classOrPackagep)));
    return AstNodeVarRef::broken();
}
bool AstNodeVarRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNodeVarRef::cloneRelinkGen() {
    AstNodeExpr::cloneRelinkGen();
    if (m_varp && m_varp->clonep()) m_varp = m_varp->clonep();
    if (m_varScopep && m_varScopep->clonep()) m_varScopep = m_varScopep->clonep();
    if (m_classOrPackagep && m_classOrPackagep->clonep()) m_classOrPackagep = m_classOrPackagep->clonep();
}
void AstNodeVarRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_varp), "varp");    f(reinterpret_cast<AstNode**>(&m_varScopep), "varScopep");    f(reinterpret_cast<AstNode**>(&m_classOrPackagep), "classOrPackagep");}
void AstNodeVarRef::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
    dumpJsonPtr(str, "varp", m_varp);
    dumpJsonPtr(str, "varScopep", m_varScopep);
    dumpJsonPtr(str, "classOrPackagep", m_classOrPackagep);
}
void AstNodeVarRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstNot::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstNot::broken();
}
bool AstNot::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNot::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstNot::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstNot::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstNotFoundModule::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeModule::brokenGen());
    return AstNotFoundModule::broken();
}
bool AstNotFoundModule::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstNotFoundModule::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeModule::foreachLink(f);
}
void AstNotFoundModule::dumpJsonGen(std::ostream& str) const {
    AstNodeModule::dumpJson(str);
}
void AstNotFoundModule::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, inlinesp(), "inlinesp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstNullCheck::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstNullCheck::broken();
}
bool AstNullCheck::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstNullCheck::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstNullCheck::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstNullCheck::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstOneHot::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstOneHot::broken();
}
bool AstOneHot::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstOneHot::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstOneHot::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstOneHot::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstOneHot0::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstOneHot0::broken();
}
bool AstOneHot0::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstOneHot0::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstOneHot0::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstOneHot0::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstOr::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiComAsv::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstOr::broken();
}
bool AstOr::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstOr::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiComAsv::foreachLink(f);
}
void AstOr::dumpJsonGen(std::ostream& str) const {
    AstNodeBiComAsv::dumpJson(str);
}
void AstOr::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstPExpr::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(bodyp() && !(privateTypeTest<AstBegin>(bodyp())));
    return AstPExpr::broken();
}
bool AstPExpr::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstBegin>(newp))) return true;
    return false;
}
void AstPExpr::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstPExpr::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstPExpr::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, bodyp(), "bodyp", indent);
}
const char* AstPExprClause::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstPExprClause::broken();
}
bool AstPExprClause::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstPExprClause::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstPExprClause::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstPExprClause::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstPackArrayDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeArrayDType::brokenGen());
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    BROKEN_RTN(rangep() && !(privateTypeTest<AstRange>(rangep())));
    return AstPackArrayDType::broken();
}
bool AstPackArrayDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstRange>(newp))) return true;
    return false;
}
void AstPackArrayDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeArrayDType::foreachLink(f);
}
void AstPackArrayDType::dumpJsonGen(std::ostream& str) const {
    AstNodeArrayDType::dumpJson(str);
}
void AstPackArrayDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
    dumpNodeListJson(str, rangep(), "rangep", indent);
}
const char* AstPackage::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeModule::brokenGen());
    return AstPackage::broken();
}
bool AstPackage::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstPackage::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeModule::foreachLink(f);
}
void AstPackage::dumpJsonGen(std::ostream& str) const {
    AstNodeModule::dumpJson(str);
}
void AstPackage::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, inlinesp(), "inlinesp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstPackageExport::brokenGen() const {
    BROKEN_RTN(m_packagep && !m_packagep->brokeExists());
    BROKEN_RTN(m_packagep && !(privateTypeTest<AstPackage>(m_packagep)));
    return AstPackageExport::broken();
}
bool AstPackageExport::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstPackageExport::cloneRelinkGen() {
    if (m_packagep && m_packagep->clonep()) m_packagep = m_packagep->clonep();
}
void AstPackageExport::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_packagep), "packagep");}
void AstPackageExport::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "packagep", m_packagep);
}
void AstPackageExport::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstPackageExportStarStar::brokenGen() const {
    return AstPackageExportStarStar::broken();
}
bool AstPackageExportStarStar::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstPackageExportStarStar::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstPackageExportStarStar::dumpJsonGen(std::ostream& str) const {
}
void AstPackageExportStarStar::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstPackageImport::brokenGen() const {
    BROKEN_RTN(m_packagep && !m_packagep->brokeExists());
    BROKEN_RTN(m_packagep && !(privateTypeTest<AstPackage>(m_packagep)));
    BROKEN_RTN(resolvedClassp() && !(privateTypeTest<AstClassOrPackageRef>(resolvedClassp())));
    return AstPackageImport::broken();
}
bool AstPackageImport::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstClassOrPackageRef>(newp))) return true;
    return false;
}
void AstPackageImport::cloneRelinkGen() {
    if (m_packagep && m_packagep->clonep()) m_packagep = m_packagep->clonep();
}
void AstPackageImport::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_packagep), "packagep");}
void AstPackageImport::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "packagep", m_packagep);
}
void AstPackageImport::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, resolvedClassp(), "resolvedClassp", indent);
}
const char* AstParamTypeDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    return AstParamTypeDType::broken();
}
bool AstParamTypeDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstParamTypeDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
}
void AstParamTypeDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
}
void AstParamTypeDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
}
const char* AstParseHolder::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstParseHolder::broken();
}
bool AstParseHolder::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstParseHolder::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstParseHolder::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstParseHolder::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstParseRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(ftaskrefp() && !(privateTypeTest<AstNodeFTaskRef>(ftaskrefp())));
    return AstParseRef::broken();
}
bool AstParseRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstNodeFTaskRef>(newp))) return true;
    return false;
}
void AstParseRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstParseRef::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstParseRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, ftaskrefp(), "ftaskrefp", indent);
}
const char* AstParseTypeDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    return AstParseTypeDType::broken();
}
bool AstParseTypeDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstParseTypeDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
}
void AstParseTypeDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
}
void AstParseTypeDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstPast::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstPast::broken();
}
bool AstPast::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstPast::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstPast::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstPast::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
    dumpNodeListJson(str, ticksp(), "ticksp", indent);
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
}
const char* AstPatMember::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(lhssp() && !(privateTypeTest<AstNodeExpr>(lhssp())));
    BROKEN_RTN(repp() && !(privateTypeTest<AstNodeExpr>(repp())));
    BROKEN_RTN(varrefp() && !(privateTypeTest<AstNodeExpr>(varrefp())));
    return AstPatMember::broken();
}
bool AstPatMember::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPatMember::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstPatMember::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstPatMember::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhssp(), "lhssp", indent);
    dumpNodeListJson(str, keyp(), "keyp", indent);
    dumpNodeListJson(str, repp(), "repp", indent);
    dumpNodeListJson(str, varrefp(), "varrefp", indent);
}
const char* AstPattern::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    return AstPattern::broken();
}
bool AstPattern::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstPattern::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstPattern::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstPattern::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
}
const char* AstPin::brokenGen() const {
    BROKEN_RTN(m_modVarp && !m_modVarp->brokeExists());
    BROKEN_RTN(m_modVarp && !(privateTypeTest<AstVar>(m_modVarp)));
    BROKEN_RTN(m_modPTypep && !m_modPTypep->brokeExists());
    BROKEN_RTN(m_modPTypep && !(privateTypeTest<AstParamTypeDType>(m_modPTypep)));
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp()) || privateTypeTest<AstNodeDType>(exprp())));
    return AstPin::broken();
}
bool AstPin::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstPin::cloneRelinkGen() {
    if (m_modVarp && m_modVarp->clonep()) m_modVarp = m_modVarp->clonep();
    if (m_modPTypep && m_modPTypep->clonep()) m_modPTypep = m_modPTypep->clonep();
}
void AstPin::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_modVarp), "modVarp");    f(reinterpret_cast<AstNode**>(&m_modPTypep), "modPTypep");}
void AstPin::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "modVarp", m_modVarp);
    dumpJsonPtr(str, "modPTypep", m_modPTypep);
}
void AstPin::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstPort::brokenGen() const {
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    return AstPort::broken();
}
bool AstPort::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPort::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstPort::dumpJsonGen(std::ostream& str) const {
}
void AstPort::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstPostAdd::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeTriop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    return AstPostAdd::broken();
}
bool AstPostAdd::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPostAdd::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeTriop::foreachLink(f);
}
void AstPostAdd::dumpJsonGen(std::ostream& str) const {
    AstNodeTriop::dumpJson(str);
}
void AstPostAdd::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
}
const char* AstPostSub::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeTriop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    return AstPostSub::broken();
}
bool AstPostSub::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPostSub::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeTriop::foreachLink(f);
}
void AstPostSub::dumpJsonGen(std::ostream& str) const {
    AstNodeTriop::dumpJson(str);
}
void AstPostSub::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
}
const char* AstPow::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstPow::broken();
}
bool AstPow::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPow::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstPow::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstPow::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstPowD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstPowD::broken();
}
bool AstPowD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPowD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstPowD::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstPowD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstPowSS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstPowSS::broken();
}
bool AstPowSS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPowSS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstPowSS::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstPowSS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstPowSU::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstPowSU::broken();
}
bool AstPowSU::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPowSU::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstPowSU::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstPowSU::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstPowUS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstPowUS::broken();
}
bool AstPowUS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPowUS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstPowUS::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstPowUS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstPragma::brokenGen() const {
    return AstPragma::broken();
}
bool AstPragma::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstPragma::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstPragma::dumpJsonGen(std::ostream& str) const {
}
void AstPragma::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstPreAdd::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeTriop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    return AstPreAdd::broken();
}
bool AstPreAdd::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPreAdd::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeTriop::foreachLink(f);
}
void AstPreAdd::dumpJsonGen(std::ostream& str) const {
    AstNodeTriop::dumpJson(str);
}
void AstPreAdd::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
}
const char* AstPreSub::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeTriop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    return AstPreSub::broken();
}
bool AstPreSub::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPreSub::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeTriop::foreachLink(f);
}
void AstPreSub::dumpJsonGen(std::ostream& str) const {
    AstNodeTriop::dumpJson(str);
}
void AstPreSub::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
}
const char* AstPrimitive::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeModule::brokenGen());
    return AstPrimitive::broken();
}
bool AstPrimitive::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstPrimitive::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeModule::foreachLink(f);
}
void AstPrimitive::dumpJsonGen(std::ostream& str) const {
    AstNodeModule::dumpJson(str);
}
void AstPrimitive::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, inlinesp(), "inlinesp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstPrintTimeScale::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstPrintTimeScale::broken();
}
bool AstPrintTimeScale::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstPrintTimeScale::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstPrintTimeScale::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstPrintTimeScale::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstPropSpec::brokenGen() const {
    BROKEN_RTN(sensesp() && !(privateTypeTest<AstSenItem>(sensesp())));
    BROKEN_RTN(disablep() && !(privateTypeTest<AstNodeExpr>(disablep())));
    return AstPropSpec::broken();
}
bool AstPropSpec::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstSenItem>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPropSpec::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstPropSpec::dumpJsonGen(std::ostream& str) const {
}
void AstPropSpec::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, sensesp(), "sensesp", indent);
    dumpNodeListJson(str, disablep(), "disablep", indent);
    dumpNodeListJson(str, propp(), "propp", indent);
}
const char* AstProperty::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeFTask::brokenGen());
    BROKEN_RTN(scopeNamep() && !(privateTypeTest<AstScopeName>(scopeNamep())));
    return AstProperty::broken();
}
bool AstProperty::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op4p() && !(privateTypeTest<AstScopeName>(newp))) return true;
    return false;
}
void AstProperty::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeFTask::foreachLink(f);
}
void AstProperty::dumpJsonGen(std::ostream& str) const {
    AstNodeFTask::dumpJson(str);
}
void AstProperty::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fvarp(), "fvarp", indent);
    dumpNodeListJson(str, classOrPackagep(), "classOrPackagep", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
    dumpNodeListJson(str, scopeNamep(), "scopeNamep", indent);
}
const char* AstPull::brokenGen() const {
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstPull::broken();
}
bool AstPull::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPull::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstPull::dumpJsonGen(std::ostream& str) const {
}
void AstPull::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstPutcN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeTriop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    return AstPutcN::broken();
}
bool AstPutcN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstPutcN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeTriop::foreachLink(f);
}
void AstPutcN::dumpJsonGen(std::ostream& str) const {
    AstNodeTriop::dumpJson(str);
}
void AstPutcN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
}
const char* AstQueueDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_refDTypep && !m_refDTypep->brokeExists());
    BROKEN_RTN(m_refDTypep && !(privateTypeTest<AstNodeDType>(m_refDTypep)));
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    BROKEN_RTN(boundp() && !(privateTypeTest<AstNodeExpr>(boundp())));
    return AstQueueDType::broken();
}
bool AstQueueDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstQueueDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_refDTypep && m_refDTypep->clonep()) m_refDTypep = m_refDTypep->clonep();
}
void AstQueueDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_refDTypep), "refDTypep");}
void AstQueueDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "refDTypep", m_refDTypep);
}
void AstQueueDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
    dumpNodeListJson(str, boundp(), "boundp", indent);
}
const char* AstRSBreak::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstRSBreak::broken();
}
bool AstRSBreak::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstRSBreak::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstRSBreak::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstRSBreak::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstRSProd::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(fvarp() && !(privateTypeTest<AstVar>(fvarp())));
    BROKEN_RTN(rulesp() && !(privateTypeTest<AstRSRule>(rulesp())));
    return AstRSProd::broken();
}
bool AstRSProd::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstVar>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstRSRule>(newp))) return true;
    return false;
}
void AstRSProd::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstRSProd::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstRSProd::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fvarp(), "fvarp", indent);
    dumpNodeListJson(str, portsp(), "portsp", indent);
    dumpNodeListJson(str, rulesp(), "rulesp", indent);
}
const char* AstRSProdItem::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(m_prodp && !m_prodp->brokeExists());
    BROKEN_RTN(m_prodp && !(privateTypeTest<AstRSProd>(m_prodp)));
    BROKEN_RTN(argsp() && !(privateTypeTest<AstNodeExpr>(argsp())));
    return AstRSProdItem::broken();
}
bool AstRSProdItem::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstRSProdItem::cloneRelinkGen() {
    AstNodeStmt::cloneRelinkGen();
    if (m_prodp && m_prodp->clonep()) m_prodp = m_prodp->clonep();
}
void AstRSProdItem::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_prodp), "prodp");}
void AstRSProdItem::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
    dumpJsonPtr(str, "prodp", m_prodp);
}
void AstRSProdItem::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, argsp(), "argsp", indent);
}
const char* AstRSProdList::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(weightp() && !(privateTypeTest<AstNodeExpr>(weightp())));
    return AstRSProdList::broken();
}
bool AstRSProdList::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstRSProdList::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstRSProdList::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstRSProdList::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, weightp(), "weightp", indent);
    dumpNodeListJson(str, prodsp(), "prodsp", indent);
}
const char* AstRSReturn::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstRSReturn::broken();
}
bool AstRSReturn::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstRSReturn::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstRSReturn::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstRSReturn::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstRSRule::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(weightp() && !(privateTypeTest<AstNodeExpr>(weightp())));
    BROKEN_RTN(prodlistsp() && !(privateTypeTest<AstRSProdList>(prodlistsp())));
    return AstRSRule::broken();
}
bool AstRSRule::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstRSProdList>(newp))) return true;
    return false;
}
void AstRSRule::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstRSRule::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstRSRule::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, weightp(), "weightp", indent);
    dumpNodeListJson(str, prodlistsp(), "prodlistsp", indent);
    dumpNodeListJson(str, weightStmtsp(), "weightStmtsp", indent);
}
const char* AstRToIRoundS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstRToIRoundS::broken();
}
bool AstRToIRoundS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstRToIRoundS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstRToIRoundS::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstRToIRoundS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstRToIS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstRToIS::broken();
}
bool AstRToIS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstRToIS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstRToIS::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstRToIS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstRand::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstRand::broken();
}
bool AstRand::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstRand::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstRand::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstRand::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, seedp(), "seedp", indent);
}
const char* AstRandCase::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(itemsp() && !(privateTypeTest<AstCaseItem>(itemsp())));
    return AstRandCase::broken();
}
bool AstRandCase::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstCaseItem>(newp))) return true;
    return false;
}
void AstRandCase::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstRandCase::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstRandCase::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, itemsp(), "itemsp", indent);
}
const char* AstRandRNG::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstRandRNG::broken();
}
bool AstRandRNG::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstRandRNG::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstRandRNG::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstRandRNG::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstRandSequence::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(m_prodp && !m_prodp->brokeExists());
    BROKEN_RTN(m_prodp && !(privateTypeTest<AstRSProd>(m_prodp)));
    BROKEN_RTN(prodsp() && !(privateTypeTest<AstRSProd>(prodsp())));
    return AstRandSequence::broken();
}
bool AstRandSequence::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstRSProd>(newp))) return true;
    return false;
}
void AstRandSequence::cloneRelinkGen() {
    AstNodeStmt::cloneRelinkGen();
    if (m_prodp && m_prodp->clonep()) m_prodp = m_prodp->clonep();
}
void AstRandSequence::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_prodp), "prodp");}
void AstRandSequence::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
    dumpJsonPtr(str, "prodp", m_prodp);
}
void AstRandSequence::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, prodsp(), "prodsp", indent);
}
const char* AstRange::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeRange::brokenGen());
    BROKEN_RTN(leftp() && !(privateTypeTest<AstNodeExpr>(leftp())));
    BROKEN_RTN(rightp() && !(privateTypeTest<AstNodeExpr>(rightp())));
    return AstRange::broken();
}
bool AstRange::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstRange::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeRange::foreachLink(f);
}
void AstRange::dumpJsonGen(std::ostream& str) const {
    AstNodeRange::dumpJson(str);
}
void AstRange::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, leftp(), "leftp", indent);
    dumpNodeListJson(str, rightp(), "rightp", indent);
}
const char* AstReadMem::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeReadWriteMem::brokenGen());
    BROKEN_RTN(filenamep() && !(privateTypeTest<AstNodeExpr>(filenamep())));
    BROKEN_RTN(memp() && !(privateTypeTest<AstNodeExpr>(memp())));
    BROKEN_RTN(lsbp() && !(privateTypeTest<AstNodeExpr>(lsbp())));
    BROKEN_RTN(msbp() && !(privateTypeTest<AstNodeExpr>(msbp())));
    return AstReadMem::broken();
}
bool AstReadMem::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstReadMem::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeReadWriteMem::foreachLink(f);
}
void AstReadMem::dumpJsonGen(std::ostream& str) const {
    AstNodeReadWriteMem::dumpJson(str);
}
void AstReadMem::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, filenamep(), "filenamep", indent);
    dumpNodeListJson(str, memp(), "memp", indent);
    dumpNodeListJson(str, lsbp(), "lsbp", indent);
    dumpNodeListJson(str, msbp(), "msbp", indent);
}
const char* AstRealToBits::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstRealToBits::broken();
}
bool AstRealToBits::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstRealToBits::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstRealToBits::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstRealToBits::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstRedAnd::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstRedAnd::broken();
}
bool AstRedAnd::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstRedAnd::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstRedAnd::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstRedAnd::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstRedOr::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstRedOr::broken();
}
bool AstRedOr::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstRedOr::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstRedOr::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstRedOr::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstRedXor::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstRedXor::broken();
}
bool AstRedXor::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstRedXor::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstRedXor::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstRedXor::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstRefDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_typedefp && !m_typedefp->brokeExists());
    BROKEN_RTN(m_typedefp && !(privateTypeTest<AstTypedef>(m_typedefp)));
    BROKEN_RTN(m_refDTypep && !m_refDTypep->brokeExists());
    BROKEN_RTN(m_refDTypep && !(privateTypeTest<AstNodeDType>(m_refDTypep)));
    BROKEN_RTN(m_classOrPackagep && !m_classOrPackagep->brokeExists());
    BROKEN_RTN(m_classOrPackagep && !(privateTypeTest<AstNodeModule>(m_classOrPackagep)));
    BROKEN_RTN(typeofp() && !(privateTypeTest<AstNodeExpr>(typeofp()) || privateTypeTest<AstNodeDType>(typeofp())));
    BROKEN_RTN(classOrPackageOpp() && !(privateTypeTest<AstNodeExpr>(classOrPackageOpp())));
    BROKEN_RTN(paramsp() && !(privateTypeTest<AstPin>(paramsp())));
    return AstRefDType::broken();
}
bool AstRefDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstNodeDType>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstPin>(newp))) return true;
    return false;
}
void AstRefDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_typedefp && m_typedefp->clonep()) m_typedefp = m_typedefp->clonep();
    if (m_refDTypep && m_refDTypep->clonep()) m_refDTypep = m_refDTypep->clonep();
    if (m_classOrPackagep && m_classOrPackagep->clonep()) m_classOrPackagep = m_classOrPackagep->clonep();
}
void AstRefDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_typedefp), "typedefp");    f(reinterpret_cast<AstNode**>(&m_refDTypep), "refDTypep");    f(reinterpret_cast<AstNode**>(&m_classOrPackagep), "classOrPackagep");}
void AstRefDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "typedefp", m_typedefp);
    dumpJsonPtr(str, "refDTypep", m_refDTypep);
    dumpJsonPtr(str, "classOrPackagep", m_classOrPackagep);
}
void AstRefDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, typeofp(), "typeofp", indent);
    dumpNodeListJson(str, classOrPackageOpp(), "classOrPackageOpp", indent);
    dumpNodeListJson(str, paramsp(), "paramsp", indent);
}
const char* AstRelease::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstRelease::broken();
}
bool AstRelease::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstRelease::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstRelease::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstRelease::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstRepeat::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(countp() && !(privateTypeTest<AstNodeExpr>(countp())));
    return AstRepeat::broken();
}
bool AstRepeat::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstRepeat::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstRepeat::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstRepeat::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, countp(), "countp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstReplicate::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(srcp() && !(privateTypeTest<AstNodeExpr>(srcp())));
    BROKEN_RTN(countp() && !(privateTypeTest<AstNodeExpr>(countp())));
    return AstReplicate::broken();
}
bool AstReplicate::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstReplicate::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstReplicate::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstReplicate::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, srcp(), "srcp", indent);
    dumpNodeListJson(str, countp(), "countp", indent);
}
const char* AstReplicateN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstReplicateN::broken();
}
bool AstReplicateN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstReplicateN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstReplicateN::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstReplicateN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstRequireDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp()) || privateTypeTest<AstNodeDType>(lhsp())));
    return AstRequireDType::broken();
}
bool AstRequireDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstRequireDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
}
void AstRequireDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
}
void AstRequireDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstResizeLValue::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstResizeLValue::broken();
}
bool AstResizeLValue::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstResizeLValue::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstResizeLValue::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstResizeLValue::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstRestrict::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeCoverOrAssert::brokenGen());
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstRestrict::broken();
}
bool AstRestrict::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op2p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstRestrict::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeCoverOrAssert::foreachLink(f);
}
void AstRestrict::dumpJsonGen(std::ostream& str) const {
    AstNodeCoverOrAssert::dumpJson(str);
}
void AstRestrict::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, propp(), "propp", indent);
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
    dumpNodeListJson(str, passsp(), "passsp", indent);
}
const char* AstReturn::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstReturn::broken();
}
bool AstReturn::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstReturn::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstReturn::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstReturn::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstRising::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    return AstRising::broken();
}
bool AstRising::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstRising::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstRising::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstRising::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstRose::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstRose::broken();
}
bool AstRose::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstRose::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstRose::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstRose::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
}
const char* AstSExpr::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(preExprp() && !(privateTypeTest<AstNodeExpr>(preExprp())));
    BROKEN_RTN(delayp() && !(privateTypeTest<AstDelay>(delayp()) || privateTypeTest<AstBegin>(delayp())));
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    return AstSExpr::broken();
}
bool AstSExpr::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstDelay>(newp) || privateTypeTest<AstBegin>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSExpr::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstSExpr::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstSExpr::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, preExprp(), "preExprp", indent);
    dumpNodeListJson(str, delayp(), "delayp", indent);
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstSFormat::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(fmtp() && !(privateTypeTest<AstSFormatF>(fmtp())));
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstSFormat::broken();
}
bool AstSFormat::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstSFormatF>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSFormat::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstSFormat::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstSFormat::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fmtp(), "fmtp", indent);
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstSFormatF::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprsp() && !(privateTypeTest<AstNodeExpr>(exprsp())));
    BROKEN_RTN(scopeNamep() && !(privateTypeTest<AstScopeName>(scopeNamep())));
    return AstSFormatF::broken();
}
bool AstSFormatF::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstScopeName>(newp))) return true;
    return false;
}
void AstSFormatF::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstSFormatF::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstSFormatF::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprsp(), "exprsp", indent);
    dumpNodeListJson(str, scopeNamep(), "scopeNamep", indent);
}
const char* AstSScanF::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstSScanF::broken();
}
bool AstSScanF::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstSScanF::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstSScanF::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstSScanF::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprsp(), "exprsp", indent);
    dumpNodeListJson(str, fromp(), "fromp", indent);
}
const char* AstSampleQueueDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_refDTypep && !m_refDTypep->brokeExists());
    BROKEN_RTN(m_refDTypep && !(privateTypeTest<AstNodeDType>(m_refDTypep)));
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    return AstSampleQueueDType::broken();
}
bool AstSampleQueueDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstSampleQueueDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_refDTypep && m_refDTypep->clonep()) m_refDTypep = m_refDTypep->clonep();
}
void AstSampleQueueDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_refDTypep), "refDTypep");}
void AstSampleQueueDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "refDTypep", m_refDTypep);
}
void AstSampleQueueDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
}
const char* AstSampled::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstSampled::broken();
}
bool AstSampled::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstSampled::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstSampled::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstSampled::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstScope::brokenGen() const {
    BROKEN_RTN(m_aboveScopep && !m_aboveScopep->brokeExists());
    BROKEN_RTN(m_aboveScopep && !(privateTypeTest<AstScope>(m_aboveScopep)));
    BROKEN_RTN(m_aboveCellp && !m_aboveCellp->brokeExists());
    BROKEN_RTN(m_aboveCellp && !(privateTypeTest<AstCell>(m_aboveCellp)));
    BROKEN_RTN(!m_modp);
    BROKEN_RTN(!m_modp->brokeExists());
    BROKEN_RTN(m_modp && !(privateTypeTest<AstNodeModule>(m_modp)));
    BROKEN_RTN(varsp() && !(privateTypeTest<AstVarScope>(varsp())));
    BROKEN_RTN(inlinesp() && !(privateTypeTest<AstCellInlineScope>(inlinesp())));
    return AstScope::broken();
}
bool AstScope::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstVarScope>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstCellInlineScope>(newp))) return true;
    return false;
}
void AstScope::cloneRelinkGen() {
    if (m_aboveScopep && m_aboveScopep->clonep()) m_aboveScopep = m_aboveScopep->clonep();
    if (m_aboveCellp && m_aboveCellp->clonep()) m_aboveCellp = m_aboveCellp->clonep();
    if (m_modp && m_modp->clonep()) m_modp = m_modp->clonep();
}
void AstScope::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_aboveScopep), "aboveScopep");    f(reinterpret_cast<AstNode**>(&m_aboveCellp), "aboveCellp");    f(reinterpret_cast<AstNode**>(&m_modp), "modp");}
void AstScope::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "aboveScopep", m_aboveScopep);
    dumpJsonPtr(str, "aboveCellp", m_aboveCellp);
    dumpJsonPtr(str, "modp", m_modp);
}
void AstScope::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, varsp(), "varsp", indent);
    dumpNodeListJson(str, blocksp(), "blocksp", indent);
    dumpNodeListJson(str, inlinesp(), "inlinesp", indent);
}
const char* AstScopeName::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstScopeName::broken();
}
bool AstScopeName::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstScopeName::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstScopeName::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstScopeName::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstSel::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(lsbp() && !(privateTypeTest<AstNodeExpr>(lsbp())));
    return AstSel::broken();
}
bool AstSel::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSel::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstSel::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstSel::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, lsbp(), "lsbp", indent);
}
const char* AstSelBit::brokenGen() const {
    BROKEN_BASE_RTN(AstNodePreSel::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(bitp() && !(privateTypeTest<AstNodeExpr>(bitp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    BROKEN_RTN(attrp() && !(privateTypeTest<AstAttrOf>(attrp())));
    return AstSelBit::broken();
}
bool AstSelBit::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstAttrOf>(newp))) return true;
    return false;
}
void AstSelBit::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodePreSel::foreachLink(f);
}
void AstSelBit::dumpJsonGen(std::ostream& str) const {
    AstNodePreSel::dumpJson(str);
}
void AstSelBit::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, bitp(), "bitp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
    dumpNodeListJson(str, attrp(), "attrp", indent);
}
const char* AstSelExtract::brokenGen() const {
    BROKEN_BASE_RTN(AstNodePreSel::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(leftp() && !(privateTypeTest<AstNodeExpr>(leftp())));
    BROKEN_RTN(rightp() && !(privateTypeTest<AstNodeExpr>(rightp())));
    BROKEN_RTN(attrp() && !(privateTypeTest<AstAttrOf>(attrp())));
    return AstSelExtract::broken();
}
bool AstSelExtract::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstAttrOf>(newp))) return true;
    return false;
}
void AstSelExtract::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodePreSel::foreachLink(f);
}
void AstSelExtract::dumpJsonGen(std::ostream& str) const {
    AstNodePreSel::dumpJson(str);
}
void AstSelExtract::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, leftp(), "leftp", indent);
    dumpNodeListJson(str, rightp(), "rightp", indent);
    dumpNodeListJson(str, attrp(), "attrp", indent);
}
const char* AstSelLoopVars::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    return AstSelLoopVars::broken();
}
bool AstSelLoopVars::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSelLoopVars::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstSelLoopVars::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstSelLoopVars::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, elementsp(), "elementsp", indent);
}
const char* AstSelMinus::brokenGen() const {
    BROKEN_BASE_RTN(AstNodePreSel::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(bitp() && !(privateTypeTest<AstNodeExpr>(bitp())));
    BROKEN_RTN(widthp() && !(privateTypeTest<AstNodeExpr>(widthp())));
    BROKEN_RTN(attrp() && !(privateTypeTest<AstAttrOf>(attrp())));
    return AstSelMinus::broken();
}
bool AstSelMinus::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstAttrOf>(newp))) return true;
    return false;
}
void AstSelMinus::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodePreSel::foreachLink(f);
}
void AstSelMinus::dumpJsonGen(std::ostream& str) const {
    AstNodePreSel::dumpJson(str);
}
void AstSelMinus::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, bitp(), "bitp", indent);
    dumpNodeListJson(str, widthp(), "widthp", indent);
    dumpNodeListJson(str, attrp(), "attrp", indent);
}
const char* AstSelPlus::brokenGen() const {
    BROKEN_BASE_RTN(AstNodePreSel::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(bitp() && !(privateTypeTest<AstNodeExpr>(bitp())));
    BROKEN_RTN(widthp() && !(privateTypeTest<AstNodeExpr>(widthp())));
    BROKEN_RTN(attrp() && !(privateTypeTest<AstAttrOf>(attrp())));
    return AstSelPlus::broken();
}
bool AstSelPlus::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstAttrOf>(newp))) return true;
    return false;
}
void AstSelPlus::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodePreSel::foreachLink(f);
}
void AstSelPlus::dumpJsonGen(std::ostream& str) const {
    AstNodePreSel::dumpJson(str);
}
void AstSelPlus::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, bitp(), "bitp", indent);
    dumpNodeListJson(str, widthp(), "widthp", indent);
    dumpNodeListJson(str, attrp(), "attrp", indent);
}
const char* AstSenItem::brokenGen() const {
    BROKEN_RTN(sensp() && !(privateTypeTest<AstNodeExpr>(sensp())));
    BROKEN_RTN(condp() && !(privateTypeTest<AstNodeExpr>(condp())));
    return AstSenItem::broken();
}
bool AstSenItem::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSenItem::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstSenItem::dumpJsonGen(std::ostream& str) const {
}
void AstSenItem::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, sensp(), "sensp", indent);
    dumpNodeListJson(str, condp(), "condp", indent);
}
const char* AstSenTree::brokenGen() const {
    BROKEN_RTN(sensesp() && !(privateTypeTest<AstSenItem>(sensesp())));
    return AstSenTree::broken();
}
bool AstSenTree::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstSenItem>(newp))) return true;
    return false;
}
void AstSenTree::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstSenTree::dumpJsonGen(std::ostream& str) const {
}
void AstSenTree::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, sensesp(), "sensesp", indent);
}
const char* AstSequence::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeFTask::brokenGen());
    BROKEN_RTN(scopeNamep() && !(privateTypeTest<AstScopeName>(scopeNamep())));
    return AstSequence::broken();
}
bool AstSequence::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op4p() && !(privateTypeTest<AstScopeName>(newp))) return true;
    return false;
}
void AstSequence::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeFTask::foreachLink(f);
}
void AstSequence::dumpJsonGen(std::ostream& str) const {
    AstNodeFTask::dumpJson(str);
}
void AstSequence::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fvarp(), "fvarp", indent);
    dumpNodeListJson(str, classOrPackagep(), "classOrPackagep", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
    dumpNodeListJson(str, scopeNamep(), "scopeNamep", indent);
}
const char* AstSetAssoc::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(valuep() && !(privateTypeTest<AstNodeExpr>(valuep())));
    return AstSetAssoc::broken();
}
bool AstSetAssoc::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSetAssoc::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstSetAssoc::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstSetAssoc::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, keyp(), "keyp", indent);
    dumpNodeListJson(str, valuep(), "valuep", indent);
}
const char* AstSetWildcard::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(valuep() && !(privateTypeTest<AstNodeExpr>(valuep())));
    return AstSetWildcard::broken();
}
bool AstSetWildcard::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSetWildcard::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstSetWildcard::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstSetWildcard::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, keyp(), "keyp", indent);
    dumpNodeListJson(str, valuep(), "valuep", indent);
}
const char* AstSetuphold::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(refevp() && !(privateTypeTest<AstNodeExpr>(refevp())));
    BROKEN_RTN(dataevp() && !(privateTypeTest<AstNodeExpr>(dataevp())));
    BROKEN_RTN(delrefp() && !(privateTypeTest<AstNodeExpr>(delrefp())));
    BROKEN_RTN(deldatap() && !(privateTypeTest<AstNodeExpr>(deldatap())));
    return AstSetuphold::broken();
}
bool AstSetuphold::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSetuphold::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstSetuphold::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstSetuphold::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, refevp(), "refevp", indent);
    dumpNodeListJson(str, dataevp(), "dataevp", indent);
    dumpNodeListJson(str, delrefp(), "delrefp", indent);
    dumpNodeListJson(str, deldatap(), "deldatap", indent);
}
const char* AstShiftL::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstShiftL::broken();
}
bool AstShiftL::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstShiftL::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstShiftL::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstShiftL::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstShiftLOvr::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstShiftLOvr::broken();
}
bool AstShiftLOvr::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstShiftLOvr::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstShiftLOvr::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstShiftLOvr::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstShiftR::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstShiftR::broken();
}
bool AstShiftR::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstShiftR::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstShiftR::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstShiftR::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstShiftROvr::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstShiftROvr::broken();
}
bool AstShiftROvr::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstShiftROvr::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstShiftROvr::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstShiftROvr::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstShiftRS::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstShiftRS::broken();
}
bool AstShiftRS::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstShiftRS::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstShiftRS::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstShiftRS::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstShiftRSOvr::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstShiftRSOvr::broken();
}
bool AstShiftRSOvr::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstShiftRSOvr::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstShiftRSOvr::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstShiftRSOvr::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstSigned::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstSigned::broken();
}
bool AstSigned::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSigned::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstSigned::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstSigned::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstSinD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstSinD::broken();
}
bool AstSinD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSinD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstSinD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstSinD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstSinhD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstSinhD::broken();
}
bool AstSinhD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSinhD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstSinhD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstSinhD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstSliceSel::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeTriop::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    return AstSliceSel::broken();
}
bool AstSliceSel::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSliceSel::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeTriop::foreachLink(f);
}
void AstSliceSel::dumpJsonGen(std::ostream& str) const {
    AstNodeTriop::dumpJson(str);
}
void AstSliceSel::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
}
const char* AstSplitPlaceholder::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstSplitPlaceholder::broken();
}
bool AstSplitPlaceholder::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstSplitPlaceholder::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstSplitPlaceholder::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstSplitPlaceholder::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstSqrtD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstSqrtD::broken();
}
bool AstSqrtD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSqrtD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstSqrtD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstSqrtD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstStable::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    BROKEN_RTN(sentreep() && !(privateTypeTest<AstSenTree>(sentreep())));
    return AstStable::broken();
}
bool AstStable::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    return false;
}
void AstStable::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstStable::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstStable::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
    dumpNodeListJson(str, sentreep(), "sentreep", indent);
}
const char* AstStackTraceF::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstStackTraceF::broken();
}
bool AstStackTraceF::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstStackTraceF::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstStackTraceF::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstStackTraceF::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstStackTraceT::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstStackTraceT::broken();
}
bool AstStackTraceT::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstStackTraceT::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstStackTraceT::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstStackTraceT::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstSteady::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    return AstSteady::broken();
}
bool AstSteady::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSteady::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstSteady::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstSteady::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstStmtExpr::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(exprp() && !(privateTypeTest<AstNodeExpr>(exprp())));
    return AstStmtExpr::broken();
}
bool AstStmtExpr::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstStmtExpr::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstStmtExpr::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstStmtExpr::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstStmtPragma::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(pragp() && !(privateTypeTest<AstPragma>(pragp())));
    return AstStmtPragma::broken();
}
bool AstStmtPragma::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstPragma>(newp))) return true;
    return false;
}
void AstStmtPragma::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstStmtPragma::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstStmtPragma::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, pragp(), "pragp", indent);
}
const char* AstStop::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstStop::broken();
}
bool AstStop::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstStop::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstStop::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstStop::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstStreamDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    return AstStreamDType::broken();
}
bool AstStreamDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstStreamDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
}
void AstStreamDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
}
void AstStreamDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstStreamL::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStream::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstStreamL::broken();
}
bool AstStreamL::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstStreamL::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStream::foreachLink(f);
}
void AstStreamL::dumpJsonGen(std::ostream& str) const {
    AstNodeStream::dumpJson(str);
}
void AstStreamL::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstStreamR::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStream::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstStreamR::broken();
}
bool AstStreamR::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstStreamR::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStream::foreachLink(f);
}
void AstStreamR::dumpJsonGen(std::ostream& str) const {
    AstNodeStream::dumpJson(str);
}
void AstStreamR::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstStrengthSpec::brokenGen() const {
    return AstStrengthSpec::broken();
}
bool AstStrengthSpec::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstStrengthSpec::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstStrengthSpec::dumpJsonGen(std::ostream& str) const {
}
void AstStrengthSpec::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstStructDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUOrStructDType::brokenGen());
    BROKEN_RTN(membersp() && !(privateTypeTest<AstMemberDType>(membersp())));
    return AstStructDType::broken();
}
bool AstStructDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstMemberDType>(newp))) return true;
    return false;
}
void AstStructDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUOrStructDType::foreachLink(f);
}
void AstStructDType::dumpJsonGen(std::ostream& str) const {
    AstNodeUOrStructDType::dumpJson(str);
}
void AstStructDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, membersp(), "membersp", indent);
}
const char* AstStructSel::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    return AstStructSel::broken();
}
bool AstStructSel::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstStructSel::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstStructSel::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstStructSel::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
}
const char* AstSub::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstSub::broken();
}
bool AstSub::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSub::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstSub::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstSub::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstSubD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstSubD::broken();
}
bool AstSubD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSubD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstSubD::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstSubD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstSubstrN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeTriop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    BROKEN_RTN(thsp() && !(privateTypeTest<AstNodeExpr>(thsp())));
    return AstSubstrN::broken();
}
bool AstSubstrN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSubstrN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeTriop::foreachLink(f);
}
void AstSubstrN::dumpJsonGen(std::ostream& str) const {
    AstNodeTriop::dumpJson(str);
}
void AstSubstrN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
    dumpNodeListJson(str, thsp(), "thsp", indent);
}
const char* AstSysIgnore::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstSysIgnore::broken();
}
bool AstSysIgnore::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstSysIgnore::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstSysIgnore::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstSysIgnore::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, exprsp(), "exprsp", indent);
}
const char* AstSystemCSection::brokenGen() const {
    return AstSystemCSection::broken();
}
bool AstSystemCSection::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstSystemCSection::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstSystemCSection::dumpJsonGen(std::ostream& str) const {
}
void AstSystemCSection::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstSystemF::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstSystemF::broken();
}
bool AstSystemF::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstSystemF::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstSystemF::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstSystemF::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstSystemT::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstSystemT::broken();
}
bool AstSystemT::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstSystemT::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstSystemT::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstSystemT::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstTanD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstTanD::broken();
}
bool AstTanD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstTanD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstTanD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstTanD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstTanhD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSystemUniopD::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstTanhD::broken();
}
bool AstTanhD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstTanhD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSystemUniopD::foreachLink(f);
}
void AstTanhD::dumpJsonGen(std::ostream& str) const {
    AstNodeSystemUniopD::dumpJson(str);
}
void AstTanhD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstTask::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeFTask::brokenGen());
    BROKEN_RTN(scopeNamep() && !(privateTypeTest<AstScopeName>(scopeNamep())));
    return AstTask::broken();
}
bool AstTask::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op4p() && !(privateTypeTest<AstScopeName>(newp))) return true;
    return false;
}
void AstTask::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeFTask::foreachLink(f);
}
void AstTask::dumpJsonGen(std::ostream& str) const {
    AstNodeFTask::dumpJson(str);
}
void AstTask::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fvarp(), "fvarp", indent);
    dumpNodeListJson(str, classOrPackagep(), "classOrPackagep", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
    dumpNodeListJson(str, scopeNamep(), "scopeNamep", indent);
}
const char* AstTaskRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeFTaskRef::brokenGen());
    BROKEN_RTN(pinsp() && !(privateTypeTest<AstNodeExpr>(pinsp())));
    BROKEN_RTN(scopeNamep() && !(privateTypeTest<AstScopeName>(scopeNamep())));
    return AstTaskRef::broken();
}
bool AstTaskRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstScopeName>(newp))) return true;
    return false;
}
void AstTaskRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeFTaskRef::foreachLink(f);
}
void AstTaskRef::dumpJsonGen(std::ostream& str) const {
    AstNodeFTaskRef::dumpJson(str);
}
void AstTaskRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, namep(), "namep", indent);
    dumpNodeListJson(str, pinsp(), "pinsp", indent);
    dumpNodeListJson(str, scopeNamep(), "scopeNamep", indent);
}
const char* AstTestPlusArgs::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstTestPlusArgs::broken();
}
bool AstTestPlusArgs::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstTestPlusArgs::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstTestPlusArgs::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstTestPlusArgs::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, searchp(), "searchp", indent);
}
const char* AstText::brokenGen() const {
    return AstText::broken();
}
bool AstText::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstText::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstText::dumpJsonGen(std::ostream& str) const {
}
void AstText::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstTextBlock::brokenGen() const {
    return AstTextBlock::broken();
}
bool AstTextBlock::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstTextBlock::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstTextBlock::dumpJsonGen(std::ostream& str) const {
}
void AstTextBlock::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, nodesp(), "nodesp", indent);
}
const char* AstThisRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstClassRefDType>(childDTypep())));
    return AstThisRef::broken();
}
bool AstThisRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstClassRefDType>(newp))) return true;
    return false;
}
void AstThisRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstThisRef::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstThisRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
}
const char* AstTime::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeTermop::brokenGen());
    return AstTime::broken();
}
bool AstTime::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstTime::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeTermop::foreachLink(f);
}
void AstTime::dumpJsonGen(std::ostream& str) const {
    AstNodeTermop::dumpJson(str);
}
void AstTime::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstTimeD::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeTermop::brokenGen());
    return AstTimeD::broken();
}
bool AstTimeD::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstTimeD::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeTermop::foreachLink(f);
}
void AstTimeD::dumpJsonGen(std::ostream& str) const {
    AstNodeTermop::dumpJson(str);
}
void AstTimeD::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstTimeFormat::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(unitsp() && !(privateTypeTest<AstNodeExpr>(unitsp())));
    BROKEN_RTN(precisionp() && !(privateTypeTest<AstNodeExpr>(precisionp())));
    BROKEN_RTN(suffixp() && !(privateTypeTest<AstNodeExpr>(suffixp())));
    BROKEN_RTN(widthp() && !(privateTypeTest<AstNodeExpr>(widthp())));
    return AstTimeFormat::broken();
}
bool AstTimeFormat::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstTimeFormat::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstTimeFormat::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstTimeFormat::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, unitsp(), "unitsp", indent);
    dumpNodeListJson(str, precisionp(), "precisionp", indent);
    dumpNodeListJson(str, suffixp(), "suffixp", indent);
    dumpNodeListJson(str, widthp(), "widthp", indent);
}
const char* AstTimeImport::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstTimeImport::broken();
}
bool AstTimeImport::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstTimeImport::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstTimeImport::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstTimeImport::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstTimePrecision::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstTimePrecision::broken();
}
bool AstTimePrecision::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstTimePrecision::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstTimePrecision::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstTimePrecision::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstTimeUnit::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstTimeUnit::broken();
}
bool AstTimeUnit::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstTimeUnit::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstTimeUnit::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstTimeUnit::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstToLowerN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstToLowerN::broken();
}
bool AstToLowerN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstToLowerN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstToLowerN::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstToLowerN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstToStringN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstToStringN::broken();
}
bool AstToStringN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstToStringN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstToStringN::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstToStringN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstToUpperN::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstToUpperN::broken();
}
bool AstToUpperN::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstToUpperN::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstToUpperN::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstToUpperN::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstTopScope::brokenGen() const {
    BROKEN_RTN(senTreesp() && !(privateTypeTest<AstSenTree>(senTreesp())));
    BROKEN_RTN(scopep() && !(privateTypeTest<AstScope>(scopep())));
    return AstTopScope::broken();
}
bool AstTopScope::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstSenTree>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstScope>(newp))) return true;
    return false;
}
void AstTopScope::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstTopScope::dumpJsonGen(std::ostream& str) const {
}
void AstTopScope::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, senTreesp(), "senTreesp", indent);
    dumpNodeListJson(str, scopep(), "scopep", indent);
}
const char* AstTraceDecl::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(valuep() && !(privateTypeTest<AstNodeExpr>(valuep())));
    return AstTraceDecl::broken();
}
bool AstTraceDecl::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstTraceDecl::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstTraceDecl::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstTraceDecl::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, valuep(), "valuep", indent);
}
const char* AstTraceInc::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(!m_declp);
    BROKEN_RTN(!m_declp->brokeExists());
    BROKEN_RTN(m_declp && !(privateTypeTest<AstTraceDecl>(m_declp)));
    BROKEN_RTN(valuep() && !(privateTypeTest<AstNodeExpr>(valuep())));
    return AstTraceInc::broken();
}
bool AstTraceInc::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstTraceInc::cloneRelinkGen() {
    AstNodeStmt::cloneRelinkGen();
    if (m_declp && m_declp->clonep()) m_declp = m_declp->clonep();
}
void AstTraceInc::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_declp), "declp");}
void AstTraceInc::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
    dumpJsonPtr(str, "declp", m_declp);
}
void AstTraceInc::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, valuep(), "valuep", indent);
}
const char* AstTracePopPrefix::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstTracePopPrefix::broken();
}
bool AstTracePopPrefix::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstTracePopPrefix::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstTracePopPrefix::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstTracePopPrefix::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstTracePushPrefix::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstTracePushPrefix::broken();
}
bool AstTracePushPrefix::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstTracePushPrefix::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstTracePushPrefix::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstTracePushPrefix::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstTypeTable::brokenGen() const {
    BROKEN_RTN(m_constraintRefp && !m_constraintRefp->brokeExists());
    BROKEN_RTN(m_constraintRefp && !(privateTypeTest<AstConstraintRefDType>(m_constraintRefp)));
    BROKEN_RTN(m_emptyQueuep && !m_emptyQueuep->brokeExists());
    BROKEN_RTN(m_emptyQueuep && !(privateTypeTest<AstEmptyQueueDType>(m_emptyQueuep)));
    BROKEN_RTN(m_queueIndexp && !m_queueIndexp->brokeExists());
    BROKEN_RTN(m_queueIndexp && !(privateTypeTest<AstQueueDType>(m_queueIndexp)));
    BROKEN_RTN(m_streamp && !m_streamp->brokeExists());
    BROKEN_RTN(m_streamp && !(privateTypeTest<AstStreamDType>(m_streamp)));
    BROKEN_RTN(m_voidp && !m_voidp->brokeExists());
    BROKEN_RTN(m_voidp && !(privateTypeTest<AstVoidDType>(m_voidp)));
    BROKEN_RTN(typesp() && !(privateTypeTest<AstNodeDType>(typesp())));
    return AstTypeTable::broken();
}
bool AstTypeTable::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstTypeTable::cloneRelinkGen() {
    if (m_constraintRefp && m_constraintRefp->clonep()) m_constraintRefp = m_constraintRefp->clonep();
    if (m_emptyQueuep && m_emptyQueuep->clonep()) m_emptyQueuep = m_emptyQueuep->clonep();
    if (m_queueIndexp && m_queueIndexp->clonep()) m_queueIndexp = m_queueIndexp->clonep();
    if (m_streamp && m_streamp->clonep()) m_streamp = m_streamp->clonep();
    if (m_voidp && m_voidp->clonep()) m_voidp = m_voidp->clonep();
}
void AstTypeTable::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_constraintRefp), "constraintRefp");    f(reinterpret_cast<AstNode**>(&m_emptyQueuep), "emptyQueuep");    f(reinterpret_cast<AstNode**>(&m_queueIndexp), "queueIndexp");    f(reinterpret_cast<AstNode**>(&m_streamp), "streamp");    f(reinterpret_cast<AstNode**>(&m_voidp), "voidp");}
void AstTypeTable::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "constraintRefp", m_constraintRefp);
    dumpJsonPtr(str, "emptyQueuep", m_emptyQueuep);
    dumpJsonPtr(str, "queueIndexp", m_queueIndexp);
    dumpJsonPtr(str, "streamp", m_streamp);
    dumpJsonPtr(str, "voidp", m_voidp);
}
void AstTypeTable::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, typesp(), "typesp", indent);
}
const char* AstTypedef::brokenGen() const {
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    return AstTypedef::broken();
}
bool AstTypedef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstTypedef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstTypedef::dumpJsonGen(std::ostream& str) const {
}
void AstTypedef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
    dumpNodeListJson(str, attrsp(), "attrsp", indent);
}
const char* AstTypedefFwd::brokenGen() const {
    return AstTypedefFwd::broken();
}
bool AstTypedefFwd::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstTypedefFwd::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstTypedefFwd::dumpJsonGen(std::ostream& str) const {
}
void AstTypedefFwd::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstURandomRange::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstURandomRange::broken();
}
bool AstURandomRange::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstURandomRange::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiop::foreachLink(f);
}
void AstURandomRange::dumpJsonGen(std::ostream& str) const {
    AstNodeBiop::dumpJson(str);
}
void AstURandomRange::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
const char* AstUdpTable::brokenGen() const {
    BROKEN_RTN(linesp() && !(privateTypeTest<AstUdpTableLine>(linesp())));
    return AstUdpTable::broken();
}
bool AstUdpTable::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstUdpTableLine>(newp))) return true;
    return false;
}
void AstUdpTable::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstUdpTable::dumpJsonGen(std::ostream& str) const {
}
void AstUdpTable::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, linesp(), "linesp", indent);
}
const char* AstUdpTableLine::brokenGen() const {
    BROKEN_RTN(iFieldsp() && !(privateTypeTest<AstUdpTableLineVal>(iFieldsp())));
    BROKEN_RTN(oFieldsp() && !(privateTypeTest<AstUdpTableLineVal>(oFieldsp())));
    return AstUdpTableLine::broken();
}
bool AstUdpTableLine::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstUdpTableLineVal>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstUdpTableLineVal>(newp))) return true;
    return false;
}
void AstUdpTableLine::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstUdpTableLine::dumpJsonGen(std::ostream& str) const {
}
void AstUdpTableLine::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, iFieldsp(), "iFieldsp", indent);
    dumpNodeListJson(str, oFieldsp(), "oFieldsp", indent);
}
const char* AstUdpTableLineVal::brokenGen() const {
    return AstUdpTableLineVal::broken();
}
bool AstUdpTableLineVal::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstUdpTableLineVal::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
}
void AstUdpTableLineVal::dumpJsonGen(std::ostream& str) const {
}
void AstUdpTableLineVal::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstUnbounded::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstUnbounded::broken();
}
bool AstUnbounded::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstUnbounded::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstUnbounded::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstUnbounded::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstUnionDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUOrStructDType::brokenGen());
    BROKEN_RTN(membersp() && !(privateTypeTest<AstMemberDType>(membersp())));
    return AstUnionDType::broken();
}
bool AstUnionDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstMemberDType>(newp))) return true;
    return false;
}
void AstUnionDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUOrStructDType::foreachLink(f);
}
void AstUnionDType::dumpJsonGen(std::ostream& str) const {
    AstNodeUOrStructDType::dumpJson(str);
}
void AstUnionDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, membersp(), "membersp", indent);
}
const char* AstUnlinkedRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstUnlinkedRef::broken();
}
bool AstUnlinkedRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstUnlinkedRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstUnlinkedRef::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstUnlinkedRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, refp(), "refp", indent);
    dumpNodeListJson(str, cellrefp(), "cellrefp", indent);
}
const char* AstUnpackArrayDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeArrayDType::brokenGen());
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    BROKEN_RTN(rangep() && !(privateTypeTest<AstRange>(rangep())));
    return AstUnpackArrayDType::broken();
}
bool AstUnpackArrayDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstRange>(newp))) return true;
    return false;
}
void AstUnpackArrayDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeArrayDType::foreachLink(f);
}
void AstUnpackArrayDType::dumpJsonGen(std::ostream& str) const {
    AstNodeArrayDType::dumpJson(str);
}
void AstUnpackArrayDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
    dumpNodeListJson(str, rangep(), "rangep", indent);
}
const char* AstUnsigned::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeUniop::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    return AstUnsigned::broken();
}
bool AstUnsigned::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstUnsigned::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeUniop::foreachLink(f);
}
void AstUnsigned::dumpJsonGen(std::ostream& str) const {
    AstNodeUniop::dumpJson(str);
}
void AstUnsigned::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
}
const char* AstUnsizedArrayDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_refDTypep && !m_refDTypep->brokeExists());
    BROKEN_RTN(m_refDTypep && !(privateTypeTest<AstNodeDType>(m_refDTypep)));
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    return AstUnsizedArrayDType::broken();
}
bool AstUnsizedArrayDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstUnsizedArrayDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_refDTypep && m_refDTypep->clonep()) m_refDTypep = m_refDTypep->clonep();
}
void AstUnsizedArrayDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_refDTypep), "refDTypep");}
void AstUnsizedArrayDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "refDTypep", m_refDTypep);
}
void AstUnsizedArrayDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
}
const char* AstUnsizedRange::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeRange::brokenGen());
    return AstUnsizedRange::broken();
}
bool AstUnsizedRange::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstUnsizedRange::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeRange::foreachLink(f);
}
void AstUnsizedRange::dumpJsonGen(std::ostream& str) const {
    AstNodeRange::dumpJson(str);
}
void AstUnsizedRange::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstVFile::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeFile::brokenGen());
    BROKEN_RTN(tblockp() && !(privateTypeTest<AstTextBlock>(tblockp())));
    return AstVFile::broken();
}
bool AstVFile::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstTextBlock>(newp))) return true;
    return false;
}
void AstVFile::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeFile::foreachLink(f);
}
void AstVFile::dumpJsonGen(std::ostream& str) const {
    AstNodeFile::dumpJson(str);
}
void AstVFile::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, tblockp(), "tblockp", indent);
}
const char* AstValuePlusArgs::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    return AstValuePlusArgs::broken();
}
bool AstValuePlusArgs::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstValuePlusArgs::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstValuePlusArgs::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstValuePlusArgs::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, searchp(), "searchp", indent);
    dumpNodeListJson(str, outp(), "outp", indent);
}
const char* AstVar::brokenGen() const {
    BROKEN_RTN(m_sensIfacep && !m_sensIfacep->brokeExists());
    BROKEN_RTN(m_sensIfacep && !(privateTypeTest<AstIface>(m_sensIfacep)));
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    BROKEN_RTN(delayp() && !(privateTypeTest<AstDelay>(delayp())));
    BROKEN_RTN(valuep() && !(privateTypeTest<AstNodeExpr>(valuep()) || privateTypeTest<AstNodeDType>(valuep())));
    return AstVar::broken();
}
bool AstVar::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstDelay>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp) || privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstVar::cloneRelinkGen() {
    if (m_sensIfacep && m_sensIfacep->clonep()) m_sensIfacep = m_sensIfacep->clonep();
}
void AstVar::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_sensIfacep), "sensIfacep");}
void AstVar::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "sensIfacep", m_sensIfacep);
}
void AstVar::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
    dumpNodeListJson(str, delayp(), "delayp", indent);
    dumpNodeListJson(str, valuep(), "valuep", indent);
    dumpNodeListJson(str, attrsp(), "attrsp", indent);
}
const char* AstVarRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeVarRef::brokenGen());
    return AstVarRef::broken();
}
bool AstVarRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstVarRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeVarRef::foreachLink(f);
}
void AstVarRef::dumpJsonGen(std::ostream& str) const {
    AstNodeVarRef::dumpJson(str);
}
void AstVarRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstVarScope::brokenGen() const {
    BROKEN_RTN(m_scopep && !m_scopep->brokeExists());
    BROKEN_RTN(m_scopep && !(privateTypeTest<AstScope>(m_scopep)));
    BROKEN_RTN(m_varp && !m_varp->brokeExists());
    BROKEN_RTN(m_varp && !(privateTypeTest<AstVar>(m_varp)));
    return AstVarScope::broken();
}
bool AstVarScope::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstVarScope::cloneRelinkGen() {
    if (m_scopep && m_scopep->clonep()) m_scopep = m_scopep->clonep();
    if (m_varp && m_varp->clonep()) m_varp = m_varp->clonep();
}
void AstVarScope::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    f(reinterpret_cast<AstNode**>(&m_scopep), "scopep");    f(reinterpret_cast<AstNode**>(&m_varp), "varp");}
void AstVarScope::dumpJsonGen(std::ostream& str) const {
    dumpJsonPtr(str, "scopep", m_scopep);
    dumpJsonPtr(str, "varp", m_varp);
}
void AstVarScope::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstVarXRef::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeVarRef::brokenGen());
    return AstVarXRef::broken();
}
bool AstVarXRef::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstVarXRef::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeVarRef::foreachLink(f);
}
void AstVarXRef::dumpJsonGen(std::ostream& str) const {
    AstNodeVarRef::dumpJson(str);
}
void AstVarXRef::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstVoidDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    return AstVoidDType::broken();
}
bool AstVoidDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstVoidDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
}
void AstVoidDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
}
void AstVoidDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstWait::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    BROKEN_RTN(condp() && !(privateTypeTest<AstNodeExpr>(condp())));
    return AstWait::broken();
}
bool AstWait::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstWait::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstWait::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstWait::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, condp(), "condp", indent);
    dumpNodeListJson(str, stmtsp(), "stmtsp", indent);
}
const char* AstWaitFork::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeStmt::brokenGen());
    return AstWaitFork::broken();
}
bool AstWaitFork::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstWaitFork::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeStmt::foreachLink(f);
}
void AstWaitFork::dumpJsonGen(std::ostream& str) const {
    AstNodeStmt::dumpJson(str);
}
void AstWaitFork::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstWildcardArrayDType::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeDType::brokenGen());
    BROKEN_RTN(m_refDTypep && !m_refDTypep->brokeExists());
    BROKEN_RTN(m_refDTypep && !(privateTypeTest<AstNodeDType>(m_refDTypep)));
    BROKEN_RTN(childDTypep() && !(privateTypeTest<AstNodeDType>(childDTypep())));
    return AstWildcardArrayDType::broken();
}
bool AstWildcardArrayDType::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeDType>(newp))) return true;
    return false;
}
void AstWildcardArrayDType::cloneRelinkGen() {
    AstNodeDType::cloneRelinkGen();
    if (m_refDTypep && m_refDTypep->clonep()) m_refDTypep = m_refDTypep->clonep();
}
void AstWildcardArrayDType::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeDType::foreachLink(f);
    f(reinterpret_cast<AstNode**>(&m_refDTypep), "refDTypep");}
void AstWildcardArrayDType::dumpJsonGen(std::ostream& str) const {
    AstNodeDType::dumpJson(str);
    dumpJsonPtr(str, "refDTypep", m_refDTypep);
}
void AstWildcardArrayDType::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, childDTypep(), "childDTypep", indent);
}
const char* AstWildcardRange::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeRange::brokenGen());
    return AstWildcardRange::broken();
}
bool AstWildcardRange::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    return false;
}
void AstWildcardRange::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeRange::foreachLink(f);
}
void AstWildcardRange::dumpJsonGen(std::ostream& str) const {
    AstNodeRange::dumpJson(str);
}
void AstWildcardRange::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
}
const char* AstWildcardSel::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSel::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(bitp() && !(privateTypeTest<AstNodeExpr>(bitp())));
    return AstWildcardSel::broken();
}
bool AstWildcardSel::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstWildcardSel::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSel::foreachLink(f);
}
void AstWildcardSel::dumpJsonGen(std::ostream& str) const {
    AstNodeSel::dumpJson(str);
}
void AstWildcardSel::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, bitp(), "bitp", indent);
}
const char* AstWith::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(indexArgRefp() && !(privateTypeTest<AstLambdaArgRef>(indexArgRefp())));
    BROKEN_RTN(valueArgRefp() && !(privateTypeTest<AstLambdaArgRef>(valueArgRefp())));
    return AstWith::broken();
}
bool AstWith::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstLambdaArgRef>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstLambdaArgRef>(newp))) return true;
    return false;
}
void AstWith::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstWith::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstWith::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, indexArgRefp(), "indexArgRefp", indent);
    dumpNodeListJson(str, valueArgRefp(), "valueArgRefp", indent);
    dumpNodeListJson(str, exprp(), "exprp", indent);
}
const char* AstWithParse::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeExpr::brokenGen());
    BROKEN_RTN(funcrefp() && !(privateTypeTest<AstNodeExpr>(funcrefp())));
    return AstWithParse::broken();
}
bool AstWithParse::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstWithParse::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeExpr::foreachLink(f);
}
void AstWithParse::dumpJsonGen(std::ostream& str) const {
    AstNodeExpr::dumpJson(str);
}
void AstWithParse::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, funcrefp(), "funcrefp", indent);
    dumpNodeListJson(str, exprsp(), "exprsp", indent);
    dumpNodeListJson(str, constraintsp(), "constraintsp", indent);
}
const char* AstWordSel::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeSel::brokenGen());
    BROKEN_RTN(fromp() && !(privateTypeTest<AstNodeExpr>(fromp())));
    BROKEN_RTN(bitp() && !(privateTypeTest<AstNodeExpr>(bitp())));
    return AstWordSel::broken();
}
bool AstWordSel::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstWordSel::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeSel::foreachLink(f);
}
void AstWordSel::dumpJsonGen(std::ostream& str) const {
    AstNodeSel::dumpJson(str);
}
void AstWordSel::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, fromp(), "fromp", indent);
    dumpNodeListJson(str, bitp(), "bitp", indent);
}
const char* AstWriteMem::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeReadWriteMem::brokenGen());
    BROKEN_RTN(filenamep() && !(privateTypeTest<AstNodeExpr>(filenamep())));
    BROKEN_RTN(memp() && !(privateTypeTest<AstNodeExpr>(memp())));
    BROKEN_RTN(lsbp() && !(privateTypeTest<AstNodeExpr>(lsbp())));
    BROKEN_RTN(msbp() && !(privateTypeTest<AstNodeExpr>(msbp())));
    return AstWriteMem::broken();
}
bool AstWriteMem::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op3p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op4p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstWriteMem::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeReadWriteMem::foreachLink(f);
}
void AstWriteMem::dumpJsonGen(std::ostream& str) const {
    AstNodeReadWriteMem::dumpJson(str);
}
void AstWriteMem::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, filenamep(), "filenamep", indent);
    dumpNodeListJson(str, memp(), "memp", indent);
    dumpNodeListJson(str, lsbp(), "lsbp", indent);
    dumpNodeListJson(str, msbp(), "msbp", indent);
}
const char* AstXor::brokenGen() const {
    BROKEN_BASE_RTN(AstNodeBiComAsv::brokenGen());
    BROKEN_RTN(lhsp() && !(privateTypeTest<AstNodeExpr>(lhsp())));
    BROKEN_RTN(rhsp() && !(privateTypeTest<AstNodeExpr>(rhsp())));
    return AstXor::broken();
}
bool AstXor::wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const {
    if (oldp == op1p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    if (oldp == op2p() && !(privateTypeTest<AstNodeExpr>(newp))) return true;
    return false;
}
void AstXor::foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) {
    AstNodeBiComAsv::foreachLink(f);
}
void AstXor::dumpJsonGen(std::ostream& str) const {
    AstNodeBiComAsv::dumpJson(str);
}
void AstXor::dumpTreeJsonOpGen(std::ostream& str, const string& indent) const {
    dumpNodeListJson(str, lhsp(), "lhsp", indent);
    dumpNodeListJson(str, rhsp(), "rhsp", indent);
}
