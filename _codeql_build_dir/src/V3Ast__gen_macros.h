// Generated by astgen // -*- mode: C++; c-file-style: "cc-mode" -*-
#define ASTGEN_MEMBERS_AstAcosD \
    AstAcosD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAcosD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAcosD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAcosD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAcosD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAcosD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAcosD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAcosD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAcosD* clonep() const { return static_cast<AstAcosD*>(AstNode::clonep()); } \
    AstAcosD* addNext(AstAcosD* nodep) { return static_cast<AstAcosD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAcosD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AcosD(...) AstNodeSystemUniopD(VNType::AcosD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAcoshD \
    AstAcoshD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAcoshD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAcoshD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAcoshD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAcoshD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAcoshD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAcoshD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAcoshD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAcoshD* clonep() const { return static_cast<AstAcoshD*>(AstNode::clonep()); } \
    AstAcoshD* addNext(AstAcoshD* nodep) { return static_cast<AstAcoshD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAcoshD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AcoshD(...) AstNodeSystemUniopD(VNType::AcoshD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstActive \
private: \
    AstSenTree* m_sentreep = nullptr;public: \
    AstActive* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstActive*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstActive* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstActive*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstActive* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstActive*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstActive* cloneTreePure(bool cloneNext) { \
        return static_cast<AstActive*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstActive* clonep() const { return static_cast<AstActive*>(AstNode::clonep()); } \
    AstActive* addNext(AstActive* nodep) { return static_cast<AstActive*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstActive(*this); } \
    AstSenTree* senTreeStorep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), SenTree); } \
    void senTreeStorep(AstSenTree* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Active(...) AstNode(VNType::Active, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAdd \
    AstAdd* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAdd*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAdd* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAdd*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAdd* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAdd*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAdd* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAdd*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAdd* clonep() const { return static_cast<AstAdd*>(AstNode::clonep()); } \
    AstAdd* addNext(AstAdd* nodep) { return static_cast<AstAdd*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAdd(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiComAsv::lhsp; \
    using AstNodeBiComAsv::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Add(...) AstNodeBiComAsv(VNType::Add, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAddD \
    AstAddD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAddD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAddD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAddD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAddD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAddD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAddD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAddD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAddD* clonep() const { return static_cast<AstAddD*>(AstNode::clonep()); } \
    AstAddD* addNext(AstAddD* nodep) { return static_cast<AstAddD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAddD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiComAsv::lhsp; \
    using AstNodeBiComAsv::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AddD(...) AstNodeBiComAsv(VNType::AddD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAddrOfCFunc \
private: \
    AstCFunc* m_funcp = nullptr;public: \
    AstAddrOfCFunc* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAddrOfCFunc*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAddrOfCFunc* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAddrOfCFunc*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAddrOfCFunc* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAddrOfCFunc*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAddrOfCFunc* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAddrOfCFunc*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAddrOfCFunc* clonep() const { return static_cast<AstAddrOfCFunc*>(AstNode::clonep()); } \
    AstAddrOfCFunc* addNext(AstAddrOfCFunc* nodep) { return static_cast<AstAddrOfCFunc*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAddrOfCFunc(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_AddrOfCFunc(...) AstNodeExpr(VNType::AddrOfCFunc, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAlias \
    AstAlias* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlias*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAlias* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlias*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAlias* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAlias*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAlias* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAlias*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAlias* clonep() const { return static_cast<AstAlias*>(AstNode::clonep()); } \
    AstAlias* addNext(AstAlias* nodep) { return static_cast<AstAlias*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAlias(*this); } \
    AstNodeExpr* itemsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void addItemsp(AstNodeExpr* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Alias(...) AstNode(VNType::Alias, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAliasScope \
    AstAliasScope* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAliasScope*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAliasScope* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAliasScope*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAliasScope* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAliasScope*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAliasScope* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAliasScope*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAliasScope* clonep() const { return static_cast<AstAliasScope*>(AstNode::clonep()); } \
    AstAliasScope* addNext(AstAliasScope* nodep) { return static_cast<AstAliasScope*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAliasScope(*this); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_AliasScope(...) AstNode(VNType::AliasScope, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAlways \
    AstAlways* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlways*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAlways* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlways*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAlways* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAlways*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAlways* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAlways*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAlways* clonep() const { return static_cast<AstAlways*>(AstNode::clonep()); } \
    AstAlways* addNext(AstAlways* nodep) { return static_cast<AstAlways*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAlways(*this); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeProcedure::stmtsp; \
    using AstNodeProcedure::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Always(...) AstNodeProcedure(VNType::Always, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAlwaysObserved \
    AstAlwaysObserved* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlwaysObserved*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAlwaysObserved* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlwaysObserved*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAlwaysObserved* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAlwaysObserved*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAlwaysObserved* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAlwaysObserved*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAlwaysObserved* clonep() const { return static_cast<AstAlwaysObserved*>(AstNode::clonep()); } \
    AstAlwaysObserved* addNext(AstAlwaysObserved* nodep) { return static_cast<AstAlwaysObserved*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAlwaysObserved(*this); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeProcedure::stmtsp; \
    using AstNodeProcedure::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AlwaysObserved(...) AstNodeProcedure(VNType::AlwaysObserved, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAlwaysPost \
    AstAlwaysPost* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlwaysPost*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAlwaysPost* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlwaysPost*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAlwaysPost* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAlwaysPost*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAlwaysPost* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAlwaysPost*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAlwaysPost* clonep() const { return static_cast<AstAlwaysPost*>(AstNode::clonep()); } \
    AstAlwaysPost* addNext(AstAlwaysPost* nodep) { return static_cast<AstAlwaysPost*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAlwaysPost(*this); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeProcedure::stmtsp; \
    using AstNodeProcedure::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AlwaysPost(...) AstNodeProcedure(VNType::AlwaysPost, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAlwaysPostponed \
    AstAlwaysPostponed* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlwaysPostponed*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAlwaysPostponed* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlwaysPostponed*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAlwaysPostponed* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAlwaysPostponed*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAlwaysPostponed* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAlwaysPostponed*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAlwaysPostponed* clonep() const { return static_cast<AstAlwaysPostponed*>(AstNode::clonep()); } \
    AstAlwaysPostponed* addNext(AstAlwaysPostponed* nodep) { return static_cast<AstAlwaysPostponed*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAlwaysPostponed(*this); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeProcedure::stmtsp; \
    using AstNodeProcedure::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AlwaysPostponed(...) AstNodeProcedure(VNType::AlwaysPostponed, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAlwaysPre \
    AstAlwaysPre* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlwaysPre*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAlwaysPre* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlwaysPre*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAlwaysPre* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAlwaysPre*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAlwaysPre* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAlwaysPre*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAlwaysPre* clonep() const { return static_cast<AstAlwaysPre*>(AstNode::clonep()); } \
    AstAlwaysPre* addNext(AstAlwaysPre* nodep) { return static_cast<AstAlwaysPre*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAlwaysPre(*this); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeProcedure::stmtsp; \
    using AstNodeProcedure::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AlwaysPre(...) AstNodeProcedure(VNType::AlwaysPre, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAlwaysReactive \
    AstAlwaysReactive* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlwaysReactive*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAlwaysReactive* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAlwaysReactive*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAlwaysReactive* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAlwaysReactive*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAlwaysReactive* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAlwaysReactive*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAlwaysReactive* clonep() const { return static_cast<AstAlwaysReactive*>(AstNode::clonep()); } \
    AstAlwaysReactive* addNext(AstAlwaysReactive* nodep) { return static_cast<AstAlwaysReactive*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAlwaysReactive(*this); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeProcedure::stmtsp; \
    using AstNodeProcedure::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AlwaysReactive(...) AstNodeProcedure(VNType::AlwaysReactive, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAnd \
    AstAnd* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAnd*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAnd* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAnd*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAnd* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAnd*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAnd* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAnd*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAnd* clonep() const { return static_cast<AstAnd*>(AstNode::clonep()); } \
    AstAnd* addNext(AstAnd* nodep) { return static_cast<AstAnd*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAnd(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiComAsv::lhsp; \
    using AstNodeBiComAsv::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_And(...) AstNodeBiComAsv(VNType::And, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstArg \
    AstArg* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstArg*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstArg* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstArg*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstArg* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstArg*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstArg* cloneTreePure(bool cloneNext) { \
        return static_cast<AstArg*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstArg* clonep() const { return static_cast<AstArg*>(AstNode::clonep()); } \
    AstArg* addNext(AstArg* nodep) { return static_cast<AstArg*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstArg(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Arg(...) AstNodeExpr(VNType::Arg, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstArraySel \
    AstArraySel* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstArraySel*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstArraySel* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstArraySel*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstArraySel* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstArraySel*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstArraySel* cloneTreePure(bool cloneNext) { \
        return static_cast<AstArraySel*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstArraySel* clonep() const { return static_cast<AstArraySel*>(AstNode::clonep()); } \
    AstArraySel* addNext(AstArraySel* nodep) { return static_cast<AstArraySel*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstArraySel(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* bitp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void bitp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSel::fromp; \
    using AstNodeSel::bitp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ArraySel(...) AstNodeSel(VNType::ArraySel, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAsinD \
    AstAsinD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAsinD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAsinD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAsinD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAsinD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAsinD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAsinD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAsinD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAsinD* clonep() const { return static_cast<AstAsinD*>(AstNode::clonep()); } \
    AstAsinD* addNext(AstAsinD* nodep) { return static_cast<AstAsinD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAsinD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AsinD(...) AstNodeSystemUniopD(VNType::AsinD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAsinhD \
    AstAsinhD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAsinhD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAsinhD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAsinhD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAsinhD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAsinhD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAsinhD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAsinhD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAsinhD* clonep() const { return static_cast<AstAsinhD*>(AstNode::clonep()); } \
    AstAsinhD* addNext(AstAsinhD* nodep) { return static_cast<AstAsinhD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAsinhD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AsinhD(...) AstNodeSystemUniopD(VNType::AsinhD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAssert \
    AstAssert* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssert*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAssert* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssert*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAssert* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAssert*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAssert* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAssert*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAssert* clonep() const { return static_cast<AstAssert*>(AstNode::clonep()); } \
    AstAssert* addNext(AstAssert* nodep) { return static_cast<AstAssert*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAssert(*this); } \
    AstNode* propp() const VL_MT_STABLE { return op1p(); } \
    void propp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* failsp() const VL_MT_STABLE { return op3p(); } \
    void addFailsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* passsp() const VL_MT_STABLE { return op4p(); } \
    void addPasssp(AstNode* nodep) { addNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeCoverOrAssert::propp; \
    using AstNodeCoverOrAssert::sentreep; \
    using AstNodeCoverOrAssert::passsp; \
    using AstNodeCoverOrAssert::addPasssp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Assert(...) AstNodeCoverOrAssert(VNType::Assert, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAssertCtl \
    AstAssertCtl* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssertCtl*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAssertCtl* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssertCtl*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAssertCtl* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAssertCtl*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAssertCtl* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAssertCtl*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAssertCtl* clonep() const { return static_cast<AstAssertCtl*>(AstNode::clonep()); } \
    AstAssertCtl* addNext(AstAssertCtl* nodep) { return static_cast<AstAssertCtl*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAssertCtl(*this); } \
    AstNodeExpr* controlTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void controlTypep(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* assertTypesp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void assertTypesp(AstNodeExpr* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* directiveTypesp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void directiveTypesp(AstNodeExpr* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_AssertCtl(...) AstNodeStmt(VNType::AssertCtl, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAssertIntrinsic \
    AstAssertIntrinsic* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssertIntrinsic*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAssertIntrinsic* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssertIntrinsic*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAssertIntrinsic* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAssertIntrinsic*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAssertIntrinsic* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAssertIntrinsic*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAssertIntrinsic* clonep() const { return static_cast<AstAssertIntrinsic*>(AstNode::clonep()); } \
    AstAssertIntrinsic* addNext(AstAssertIntrinsic* nodep) { return static_cast<AstAssertIntrinsic*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAssertIntrinsic(*this); } \
    AstNode* propp() const VL_MT_STABLE { return op1p(); } \
    void propp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* failsp() const VL_MT_STABLE { return op3p(); } \
    void addFailsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* passsp() const VL_MT_STABLE { return op4p(); } \
    void addPasssp(AstNode* nodep) { addNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeCoverOrAssert::propp; \
    using AstNodeCoverOrAssert::sentreep; \
    using AstNodeCoverOrAssert::passsp; \
    using AstNodeCoverOrAssert::addPasssp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AssertIntrinsic(...) AstNodeCoverOrAssert(VNType::AssertIntrinsic, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAssign \
    AstAssign* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssign*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAssign* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssign*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAssign* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAssign*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAssign* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAssign*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAssign* clonep() const { return static_cast<AstAssign*>(AstNode::clonep()); } \
    AstAssign* addNext(AstAssign* nodep) { return static_cast<AstAssign*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAssign(*this); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* timingControlp() const VL_MT_STABLE { return op3p(); } \
    void timingControlp(AstNode* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeAssign::rhsp; \
    using AstNodeAssign::lhsp; \
    using AstNodeAssign::timingControlp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Assign(...) AstNodeAssign(VNType::Assign, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAssignCont \
    AstAssignCont* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssignCont*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAssignCont* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssignCont*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAssignCont* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAssignCont*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAssignCont* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAssignCont*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAssignCont* clonep() const { return static_cast<AstAssignCont*>(AstNode::clonep()); } \
    AstAssignCont* addNext(AstAssignCont* nodep) { return static_cast<AstAssignCont*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAssignCont(*this); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* timingControlp() const VL_MT_STABLE { return op3p(); } \
    void timingControlp(AstNode* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeAssign::rhsp; \
    using AstNodeAssign::lhsp; \
    using AstNodeAssign::timingControlp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AssignCont(...) AstNodeAssign(VNType::AssignCont, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAssignDly \
    AstAssignDly* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssignDly*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAssignDly* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssignDly*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAssignDly* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAssignDly*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAssignDly* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAssignDly*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAssignDly* clonep() const { return static_cast<AstAssignDly*>(AstNode::clonep()); } \
    AstAssignDly* addNext(AstAssignDly* nodep) { return static_cast<AstAssignDly*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAssignDly(*this); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* timingControlp() const VL_MT_STABLE { return op3p(); } \
    void timingControlp(AstNode* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeAssign::rhsp; \
    using AstNodeAssign::lhsp; \
    using AstNodeAssign::timingControlp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AssignDly(...) AstNodeAssign(VNType::AssignDly, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAssignForce \
    AstAssignForce* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssignForce*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAssignForce* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssignForce*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAssignForce* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAssignForce*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAssignForce* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAssignForce*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAssignForce* clonep() const { return static_cast<AstAssignForce*>(AstNode::clonep()); } \
    AstAssignForce* addNext(AstAssignForce* nodep) { return static_cast<AstAssignForce*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAssignForce(*this); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* timingControlp() const VL_MT_STABLE { return op3p(); } \
    void timingControlp(AstNode* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeAssign::rhsp; \
    using AstNodeAssign::lhsp; \
    using AstNodeAssign::timingControlp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AssignForce(...) AstNodeAssign(VNType::AssignForce, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAssignW \
    AstAssignW* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssignW*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAssignW* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssignW*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAssignW* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAssignW*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAssignW* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAssignW*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAssignW* clonep() const { return static_cast<AstAssignW*>(AstNode::clonep()); } \
    AstAssignW* addNext(AstAssignW* nodep) { return static_cast<AstAssignW*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAssignW(*this); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* timingControlp() const VL_MT_STABLE { return op3p(); } \
    void timingControlp(AstNode* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstStrengthSpec* strengthSpecp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), StrengthSpec); } \
    void strengthSpecp(AstStrengthSpec* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeAssign::rhsp; \
    using AstNodeAssign::lhsp; \
    using AstNodeAssign::timingControlp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AssignW(...) AstNodeAssign(VNType::AssignW, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAssocArrayDType \
private: \
    AstNodeDType* m_refDTypep = nullptr;    AstNodeDType* m_keyDTypep = nullptr;public: \
    AstAssocArrayDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssocArrayDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAssocArrayDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssocArrayDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAssocArrayDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAssocArrayDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAssocArrayDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAssocArrayDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAssocArrayDType* clonep() const { return static_cast<AstAssocArrayDType*>(AstNode::clonep()); } \
    AstAssocArrayDType* addNext(AstAssocArrayDType* nodep) { return static_cast<AstAssocArrayDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAssocArrayDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeDType* keyChildDTypep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeDType); } \
    void keyChildDTypep(AstNodeDType* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_AssocArrayDType(...) AstNodeDType(VNType::AssocArrayDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAssocSel \
    AstAssocSel* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssocSel*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAssocSel* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAssocSel*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAssocSel* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAssocSel*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAssocSel* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAssocSel*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAssocSel* clonep() const { return static_cast<AstAssocSel*>(AstNode::clonep()); } \
    AstAssocSel* addNext(AstAssocSel* nodep) { return static_cast<AstAssocSel*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAssocSel(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* bitp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void bitp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSel::fromp; \
    using AstNodeSel::bitp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AssocSel(...) AstNodeSel(VNType::AssocSel, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAtan2D \
    AstAtan2D* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAtan2D*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAtan2D* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAtan2D*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAtan2D* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAtan2D*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAtan2D* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAtan2D*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAtan2D* clonep() const { return static_cast<AstAtan2D*>(AstNode::clonep()); } \
    AstAtan2D* addNext(AstAtan2D* nodep) { return static_cast<AstAtan2D*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAtan2D(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemBiopD::lhsp; \
    using AstNodeSystemBiopD::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Atan2D(...) AstNodeSystemBiopD(VNType::Atan2D, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAtanD \
    AstAtanD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAtanD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAtanD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAtanD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAtanD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAtanD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAtanD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAtanD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAtanD* clonep() const { return static_cast<AstAtanD*>(AstNode::clonep()); } \
    AstAtanD* addNext(AstAtanD* nodep) { return static_cast<AstAtanD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAtanD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AtanD(...) AstNodeSystemUniopD(VNType::AtanD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAtanhD \
    AstAtanhD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAtanhD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAtanhD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAtanhD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAtanhD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAtanhD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAtanhD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAtanhD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAtanhD* clonep() const { return static_cast<AstAtanhD*>(AstNode::clonep()); } \
    AstAtanhD* addNext(AstAtanhD* nodep) { return static_cast<AstAtanhD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAtanhD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AtanhD(...) AstNodeSystemUniopD(VNType::AtanhD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAtoN \
    AstAtoN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAtoN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAtoN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAtoN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAtoN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAtoN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAtoN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAtoN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAtoN* clonep() const { return static_cast<AstAtoN*>(AstNode::clonep()); } \
    AstAtoN* addNext(AstAtoN* nodep) { return static_cast<AstAtoN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAtoN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_AtoN(...) AstNodeUniop(VNType::AtoN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstAttrOf \
    AstAttrOf* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAttrOf*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstAttrOf* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstAttrOf*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstAttrOf* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstAttrOf*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstAttrOf* cloneTreePure(bool cloneNext) { \
        return static_cast<AstAttrOf*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstAttrOf* clonep() const { return static_cast<AstAttrOf*>(AstNode::clonep()); } \
    AstAttrOf* addNext(AstAttrOf* nodep) { return static_cast<AstAttrOf*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstAttrOf(*this); } \
    AstNode* fromp() const VL_MT_STABLE { return op1p(); } \
    void fromp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* dimp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void dimp(AstNodeExpr* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_AttrOf(...) AstNodeExpr(VNType::AttrOf, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstBasicDType \
    AstBasicDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBasicDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstBasicDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBasicDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstBasicDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstBasicDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstBasicDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstBasicDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstBasicDType* clonep() const { return static_cast<AstBasicDType*>(AstNode::clonep()); } \
    AstBasicDType* addNext(AstBasicDType* nodep) { return static_cast<AstBasicDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstBasicDType(*this); } \
    AstRange* rangep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), Range); } \
    void rangep(AstRange* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_BasicDType(...) AstNodeDType(VNType::BasicDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstBegin \
    AstBegin* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBegin*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstBegin* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBegin*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstBegin* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstBegin*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstBegin* cloneTreePure(bool cloneNext) { \
        return static_cast<AstBegin*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstBegin* clonep() const { return static_cast<AstBegin*>(AstNode::clonep()); } \
    AstBegin* addNext(AstBegin* nodep) { return static_cast<AstBegin*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstBegin(*this); } \
    AstNode* declsp() const VL_MT_STABLE { return op1p(); } \
    void addDeclsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBlock::declsp; \
    using AstNodeBlock::addDeclsp; \
    using AstNodeBlock::stmtsp; \
    using AstNodeBlock::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Begin(...) AstNodeBlock(VNType::Begin, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstBind \
    AstBind* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBind*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstBind* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBind*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstBind* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstBind*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstBind* cloneTreePure(bool cloneNext) { \
        return static_cast<AstBind*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstBind* clonep() const { return static_cast<AstBind*>(AstNode::clonep()); } \
    AstBind* addNext(AstBind* nodep) { return static_cast<AstBind*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstBind(*this); } \
    AstNode* cellsp() const VL_MT_STABLE { return op1p(); } \
    void addCellsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Bind(...) AstNode(VNType::Bind, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstBitsToRealD \
    AstBitsToRealD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBitsToRealD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstBitsToRealD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBitsToRealD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstBitsToRealD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstBitsToRealD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstBitsToRealD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstBitsToRealD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstBitsToRealD* clonep() const { return static_cast<AstBitsToRealD*>(AstNode::clonep()); } \
    AstBitsToRealD* addNext(AstBitsToRealD* nodep) { return static_cast<AstBitsToRealD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstBitsToRealD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_BitsToRealD(...) AstNodeUniop(VNType::BitsToRealD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstBracketArrayDType \
    AstBracketArrayDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBracketArrayDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstBracketArrayDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBracketArrayDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstBracketArrayDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstBracketArrayDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstBracketArrayDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstBracketArrayDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstBracketArrayDType* clonep() const { return static_cast<AstBracketArrayDType*>(AstNode::clonep()); } \
    AstBracketArrayDType* addNext(AstBracketArrayDType* nodep) { return static_cast<AstBracketArrayDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstBracketArrayDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* elementsp() const VL_MT_STABLE { return op2p(); } \
    void elementsp(AstNode* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_BracketArrayDType(...) AstNodeDType(VNType::BracketArrayDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstBracketRange \
    AstBracketRange* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBracketRange*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstBracketRange* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBracketRange*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstBracketRange* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstBracketRange*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstBracketRange* cloneTreePure(bool cloneNext) { \
        return static_cast<AstBracketRange*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstBracketRange* clonep() const { return static_cast<AstBracketRange*>(AstNode::clonep()); } \
    AstBracketRange* addNext(AstBracketRange* nodep) { return static_cast<AstBracketRange*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstBracketRange(*this); } \
    AstNode* elementsp() const VL_MT_STABLE { return op1p(); } \
    void elementsp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_BracketRange(...) AstNodeRange(VNType::BracketRange, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstBreak \
    AstBreak* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBreak*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstBreak* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBreak*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstBreak* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstBreak*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstBreak* cloneTreePure(bool cloneNext) { \
        return static_cast<AstBreak*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstBreak* clonep() const { return static_cast<AstBreak*>(AstNode::clonep()); } \
    AstBreak* addNext(AstBreak* nodep) { return static_cast<AstBreak*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstBreak(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Break(...) AstNodeStmt(VNType::Break, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstBufIf1 \
    AstBufIf1* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBufIf1*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstBufIf1* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstBufIf1*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstBufIf1* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstBufIf1*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstBufIf1* cloneTreePure(bool cloneNext) { \
        return static_cast<AstBufIf1*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstBufIf1* clonep() const { return static_cast<AstBufIf1*>(AstNode::clonep()); } \
    AstBufIf1* addNext(AstBufIf1* nodep) { return static_cast<AstBufIf1*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstBufIf1(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_BufIf1(...) AstNodeBiop(VNType::BufIf1, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCAwait \
private: \
    AstSenTree* m_sentreep = nullptr;public: \
    AstCAwait* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCAwait*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCAwait* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCAwait*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCAwait* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCAwait*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCAwait* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCAwait*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCAwait* clonep() const { return static_cast<AstCAwait*>(AstNode::clonep()); } \
    AstCAwait* addNext(AstCAwait* nodep) { return static_cast<AstCAwait*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCAwait(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CAwait(...) AstNodeUniop(VNType::CAwait, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCCall \
    AstCCall* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCCall*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCCall* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCCall*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCCall* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCCall*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCCall* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCCall*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCCall* clonep() const { return static_cast<AstCCall*>(AstNode::clonep()); } \
    AstCCall* addNext(AstCCall* nodep) { return static_cast<AstCCall*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCCall(*this); } \
    AstNodeExpr* argsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void addArgsp(AstNodeExpr* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeCCall::argsp; \
    using AstNodeCCall::addArgsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CCall(...) AstNodeCCall(VNType::CCall, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCCast \
    AstCCast* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCCast*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCCast* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCCast*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCCast* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCCast*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCCast* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCCast*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCCast* clonep() const { return static_cast<AstCCast*>(AstNode::clonep()); } \
    AstCCast* addNext(AstCCast* nodep) { return static_cast<AstCCast*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCCast(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CCast(...) AstNodeUniop(VNType::CCast, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCDType \
    AstCDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCDType* clonep() const { return static_cast<AstCDType*>(AstNode::clonep()); } \
    AstCDType* addNext(AstCDType* nodep) { return static_cast<AstCDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCDType(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CDType(...) AstNodeDType(VNType::CDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCExpr \
    AstCExpr* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCExpr*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCExpr* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCExpr*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCExpr* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCExpr*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCExpr* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCExpr*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCExpr* clonep() const { return static_cast<AstCExpr*>(AstNode::clonep()); } \
    AstCExpr* addNext(AstCExpr* nodep) { return static_cast<AstCExpr*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCExpr(*this); } \
    AstNode* nodesp() const VL_MT_STABLE { return op1p(); } \
    void addNodesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CExpr(...) AstNodeExpr(VNType::CExpr, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCExprUser \
    AstCExprUser* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCExprUser*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCExprUser* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCExprUser*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCExprUser* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCExprUser*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCExprUser* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCExprUser*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCExprUser* clonep() const { return static_cast<AstCExprUser*>(AstNode::clonep()); } \
    AstCExprUser* addNext(AstCExprUser* nodep) { return static_cast<AstCExprUser*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCExprUser(*this); } \
    AstNode* nodesp() const VL_MT_STABLE { return op1p(); } \
    void addNodesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CExprUser(...) AstNodeExpr(VNType::CExprUser, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCFile \
    AstCFile* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCFile*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCFile* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCFile*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCFile* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCFile*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCFile* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCFile*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCFile* clonep() const { return static_cast<AstCFile*>(AstNode::clonep()); } \
    AstCFile* addNext(AstCFile* nodep) { return static_cast<AstCFile*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCFile(*this); } \
    AstTextBlock* tblockp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), TextBlock); } \
    void tblockp(AstTextBlock* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeFile::tblockp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CFile(...) AstNodeFile(VNType::CFile, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCFunc \
private: \
    AstScope* m_scopep = nullptr;public: \
    AstCFunc* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCFunc*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCFunc* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCFunc*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCFunc* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCFunc*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCFunc* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCFunc*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCFunc* clonep() const { return static_cast<AstCFunc*>(AstNode::clonep()); } \
    AstCFunc* addNext(AstCFunc* nodep) { return static_cast<AstCFunc*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCFunc(*this); } \
    AstVar* argsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), Var); } \
    void addArgsp(AstVar* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstVar* varsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), Var); } \
    void addVarsp(AstVar* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op3p(); } \
    void addStmtsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CFunc(...) AstNode(VNType::CFunc, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCLocalScope \
    AstCLocalScope* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCLocalScope*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCLocalScope* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCLocalScope*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCLocalScope* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCLocalScope*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCLocalScope* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCLocalScope*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCLocalScope* clonep() const { return static_cast<AstCLocalScope*>(AstNode::clonep()); } \
    AstCLocalScope* addNext(AstCLocalScope* nodep) { return static_cast<AstCLocalScope*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCLocalScope(*this); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op1p(); } \
    void addStmtsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CLocalScope(...) AstNode(VNType::CLocalScope, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCLog2 \
    AstCLog2* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCLog2*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCLog2* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCLog2*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCLog2* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCLog2*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCLog2* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCLog2*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCLog2* clonep() const { return static_cast<AstCLog2*>(AstNode::clonep()); } \
    AstCLog2* addNext(AstCLog2* nodep) { return static_cast<AstCLog2*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCLog2(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CLog2(...) AstNodeUniop(VNType::CLog2, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCMethodCall \
    AstCMethodCall* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCMethodCall*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCMethodCall* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCMethodCall*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCMethodCall* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCMethodCall*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCMethodCall* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCMethodCall*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCMethodCall* clonep() const { return static_cast<AstCMethodCall*>(AstNode::clonep()); } \
    AstCMethodCall* addNext(AstCMethodCall* nodep) { return static_cast<AstCMethodCall*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCMethodCall(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* argsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void addArgsp(AstNodeExpr* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeCCall::argsp; \
    using AstNodeCCall::addArgsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CMethodCall(...) AstNodeCCall(VNType::CMethodCall, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCMethodHard \
    AstCMethodHard* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCMethodHard*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCMethodHard* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCMethodHard*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCMethodHard* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCMethodHard*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCMethodHard* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCMethodHard*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCMethodHard* clonep() const { return static_cast<AstCMethodHard*>(AstNode::clonep()); } \
    AstCMethodHard* addNext(AstCMethodHard* nodep) { return static_cast<AstCMethodHard*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCMethodHard(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* pinsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void addPinsp(AstNodeExpr* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CMethodHard(...) AstNodeExpr(VNType::CMethodHard, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCNew \
    AstCNew* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCNew*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCNew* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCNew*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCNew* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCNew*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCNew* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCNew*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCNew* clonep() const { return static_cast<AstCNew*>(AstNode::clonep()); } \
    AstCNew* addNext(AstCNew* nodep) { return static_cast<AstCNew*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCNew(*this); } \
    AstNodeExpr* argsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void addArgsp(AstNodeExpr* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeCCall::argsp; \
    using AstNodeCCall::addArgsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CNew(...) AstNodeCCall(VNType::CNew, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCReset \
    AstCReset* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCReset*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCReset* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCReset*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCReset* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCReset*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCReset* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCReset*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCReset* clonep() const { return static_cast<AstCReset*>(AstNode::clonep()); } \
    AstCReset* addNext(AstCReset* nodep) { return static_cast<AstCReset*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCReset(*this); } \
    AstVarRef* varrefp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), VarRef); } \
    void varrefp(AstVarRef* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CReset(...) AstNodeStmt(VNType::CReset, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCReturn \
    AstCReturn* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCReturn*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCReturn* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCReturn*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCReturn* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCReturn*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCReturn* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCReturn*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCReturn* clonep() const { return static_cast<AstCReturn*>(AstNode::clonep()); } \
    AstCReturn* addNext(AstCReturn* nodep) { return static_cast<AstCReturn*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCReturn(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CReturn(...) AstNodeStmt(VNType::CReturn, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCStmt \
    AstCStmt* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCStmt*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCStmt* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCStmt*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCStmt* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCStmt*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCStmt* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCStmt*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCStmt* clonep() const { return static_cast<AstCStmt*>(AstNode::clonep()); } \
    AstCStmt* addNext(AstCStmt* nodep) { return static_cast<AstCStmt*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCStmt(*this); } \
    AstNode* nodesp() const VL_MT_STABLE { return op1p(); } \
    void addNodesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CStmt(...) AstNodeStmt(VNType::CStmt, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCStmtUser \
    AstCStmtUser* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCStmtUser*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCStmtUser* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCStmtUser*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCStmtUser* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCStmtUser*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCStmtUser* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCStmtUser*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCStmtUser* clonep() const { return static_cast<AstCStmtUser*>(AstNode::clonep()); } \
    AstCStmtUser* addNext(AstCStmtUser* nodep) { return static_cast<AstCStmtUser*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCStmtUser(*this); } \
    AstNode* nodesp() const VL_MT_STABLE { return op1p(); } \
    void addNodesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CStmtUser(...) AstNodeStmt(VNType::CStmtUser, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCUse \
    AstCUse* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCUse*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCUse* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCUse*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCUse* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCUse*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCUse* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCUse*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCUse* clonep() const { return static_cast<AstCUse*>(AstNode::clonep()); } \
    AstCUse* addNext(AstCUse* nodep) { return static_cast<AstCUse*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCUse(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CUse(...) AstNode(VNType::CUse, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCase \
    AstCase* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCase*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCase* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCase*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCase* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCase*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCase* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCase*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCase* clonep() const { return static_cast<AstCase*>(AstNode::clonep()); } \
    AstCase* addNext(AstCase* nodep) { return static_cast<AstCase*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCase(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstCaseItem* itemsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), CaseItem); } \
    void addItemsp(AstCaseItem* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* notParallelp() const VL_MT_STABLE { return op3p(); } \
    void addNotParallelp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Case(...) AstNodeStmt(VNType::Case, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCaseItem \
    AstCaseItem* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCaseItem*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCaseItem* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCaseItem*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCaseItem* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCaseItem*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCaseItem* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCaseItem*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCaseItem* clonep() const { return static_cast<AstCaseItem*>(AstNode::clonep()); } \
    AstCaseItem* addNext(AstCaseItem* nodep) { return static_cast<AstCaseItem*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCaseItem(*this); } \
    AstNodeExpr* condsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void addCondsp(AstNodeExpr* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CaseItem(...) AstNode(VNType::CaseItem, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCast \
    AstCast* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCast*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCast* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCast*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCast* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCast*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCast* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCast*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCast* clonep() const { return static_cast<AstCast*>(AstNode::clonep()); } \
    AstCast* addNext(AstCast* nodep) { return static_cast<AstCast*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCast(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Cast(...) AstNodeExpr(VNType::Cast, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCastDynamic \
    AstCastDynamic* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCastDynamic*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCastDynamic* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCastDynamic*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCastDynamic* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCastDynamic*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCastDynamic* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCastDynamic*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCastDynamic* clonep() const { return static_cast<AstCastDynamic*>(AstNode::clonep()); } \
    AstCastDynamic* addNext(AstCastDynamic* nodep) { return static_cast<AstCastDynamic*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCastDynamic(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* top() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void top(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CastDynamic(...) AstNodeBiop(VNType::CastDynamic, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCastParse \
    AstCastParse* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCastParse*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCastParse* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCastParse*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCastParse* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCastParse*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCastParse* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCastParse*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCastParse* clonep() const { return static_cast<AstCastParse*>(AstNode::clonep()); } \
    AstCastParse* addNext(AstCastParse* nodep) { return static_cast<AstCastParse*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCastParse(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* dtp() const VL_MT_STABLE { return op2p(); } \
    void dtp(AstNode* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CastParse(...) AstNodeExpr(VNType::CastParse, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCastSize \
    AstCastSize* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCastSize*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCastSize* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCastSize*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCastSize* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCastSize*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCastSize* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCastSize*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCastSize* clonep() const { return static_cast<AstCastSize*>(AstNode::clonep()); } \
    AstCastSize* addNext(AstCastSize* nodep) { return static_cast<AstCastSize*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCastSize(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstConst* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), Const); } \
    void rhsp(AstConst* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CastSize(...) AstNodeExpr(VNType::CastSize, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCastWrap \
    AstCastWrap* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCastWrap*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCastWrap* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCastWrap*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCastWrap* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCastWrap*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCastWrap* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCastWrap*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCastWrap* clonep() const { return static_cast<AstCastWrap*>(AstNode::clonep()); } \
    AstCastWrap* addNext(AstCastWrap* nodep) { return static_cast<AstCastWrap*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCastWrap(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CastWrap(...) AstNodeUniop(VNType::CastWrap, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCeilD \
    AstCeilD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCeilD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCeilD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCeilD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCeilD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCeilD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCeilD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCeilD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCeilD* clonep() const { return static_cast<AstCeilD*>(AstNode::clonep()); } \
    AstCeilD* addNext(AstCeilD* nodep) { return static_cast<AstCeilD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCeilD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CeilD(...) AstNodeSystemUniopD(VNType::CeilD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCell \
private: \
    AstNodeModule* m_modp = nullptr;public: \
    AstCell* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCell*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCell* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCell*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCell* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCell*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCell* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCell*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCell* clonep() const { return static_cast<AstCell*>(AstNode::clonep()); } \
    AstCell* addNext(AstCell* nodep) { return static_cast<AstCell*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCell(*this); } \
    AstPin* pinsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), Pin); } \
    void addPinsp(AstPin* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstPin* paramsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), Pin); } \
    void addParamsp(AstPin* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstRange* rangep() const VL_MT_STABLE { return VN_DBG_AS(op3p(), Range); } \
    void rangep(AstRange* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstIntfRef* intfRefsp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), IntfRef); } \
    void addIntfRefsp(AstIntfRef* nodep) { addNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Cell(...) AstNode(VNType::Cell, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCellArrayRef \
    AstCellArrayRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCellArrayRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCellArrayRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCellArrayRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCellArrayRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCellArrayRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCellArrayRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCellArrayRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCellArrayRef* clonep() const { return static_cast<AstCellArrayRef*>(AstNode::clonep()); } \
    AstCellArrayRef* addNext(AstCellArrayRef* nodep) { return static_cast<AstCellArrayRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCellArrayRef(*this); } \
    AstNodeExpr* selp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void addSelp(AstNodeExpr* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CellArrayRef(...) AstNodeExpr(VNType::CellArrayRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCellInline \
private: \
    AstScope* m_scopep = nullptr;public: \
    AstCellInline* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCellInline*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCellInline* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCellInline*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCellInline* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCellInline*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCellInline* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCellInline*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCellInline* clonep() const { return static_cast<AstCellInline*>(AstNode::clonep()); } \
    AstCellInline* addNext(AstCellInline* nodep) { return static_cast<AstCellInline*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCellInline(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CellInline(...) AstNode(VNType::CellInline, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCellInlineScope \
private: \
    AstScope* m_scopep = nullptr;    AstCellInline* m_cellp = nullptr;public: \
    AstCellInlineScope* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCellInlineScope*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCellInlineScope* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCellInlineScope*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCellInlineScope* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCellInlineScope*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCellInlineScope* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCellInlineScope*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCellInlineScope* clonep() const { return static_cast<AstCellInlineScope*>(AstNode::clonep()); } \
    AstCellInlineScope* addNext(AstCellInlineScope* nodep) { return static_cast<AstCellInlineScope*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCellInlineScope(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CellInlineScope(...) AstNode(VNType::CellInlineScope, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCellRef \
    AstCellRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCellRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCellRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCellRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCellRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCellRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCellRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCellRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCellRef* clonep() const { return static_cast<AstCellRef*>(AstNode::clonep()); } \
    AstCellRef* addNext(AstCellRef* nodep) { return static_cast<AstCellRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCellRef(*this); } \
    AstNode* cellp() const VL_MT_STABLE { return op1p(); } \
    void cellp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* exprp() const VL_MT_STABLE { return op2p(); } \
    void exprp(AstNode* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CellRef(...) AstNodeExpr(VNType::CellRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCgOptionAssign \
    AstCgOptionAssign* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCgOptionAssign*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCgOptionAssign* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCgOptionAssign*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCgOptionAssign* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCgOptionAssign*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCgOptionAssign* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCgOptionAssign*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCgOptionAssign* clonep() const { return static_cast<AstCgOptionAssign*>(AstNode::clonep()); } \
    AstCgOptionAssign* addNext(AstCgOptionAssign* nodep) { return static_cast<AstCgOptionAssign*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCgOptionAssign(*this); } \
    AstNodeExpr* valuep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void valuep(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CgOptionAssign(...) AstNode(VNType::CgOptionAssign, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstClass \
private: \
    AstClassPackage* m_classOrPackagep = nullptr;public: \
    AstClass* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClass*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstClass* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClass*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstClass* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstClass*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstClass* cloneTreePure(bool cloneNext) { \
        return static_cast<AstClass*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstClass* clonep() const { return static_cast<AstClass*>(AstNode::clonep()); } \
    AstClass* addNext(AstClass* nodep) { return static_cast<AstClass*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstClass(*this); } \
    AstNode* inlinesp() const VL_MT_STABLE { return op1p(); } \
    void addInlinesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstClassExtends* extendsp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), ClassExtends); } \
    void addExtendsp(AstClassExtends* nodep) { addNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeModule::inlinesp; \
    using AstNodeModule::addInlinesp; \
    using AstNodeModule::stmtsp; \
    using AstNodeModule::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Class(...) AstNodeModule(VNType::Class, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstClassExtends \
    AstClassExtends* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClassExtends*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstClassExtends* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClassExtends*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstClassExtends* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstClassExtends*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstClassExtends* cloneTreePure(bool cloneNext) { \
        return static_cast<AstClassExtends*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstClassExtends* clonep() const { return static_cast<AstClassExtends*>(AstNode::clonep()); } \
    AstClassExtends* addNext(AstClassExtends* nodep) { return static_cast<AstClassExtends*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstClassExtends(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* classOrPkgsp() const VL_MT_STABLE { return op2p(); } \
    void classOrPkgsp(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* argsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void addArgsp(AstNodeExpr* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ClassExtends(...) AstNode(VNType::ClassExtends, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstClassOrPackageRef \
private: \
    AstNode* m_classOrPackageNodep = nullptr;public: \
    AstClassOrPackageRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClassOrPackageRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstClassOrPackageRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClassOrPackageRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstClassOrPackageRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstClassOrPackageRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstClassOrPackageRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstClassOrPackageRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstClassOrPackageRef* clonep() const { return static_cast<AstClassOrPackageRef*>(AstNode::clonep()); } \
    AstClassOrPackageRef* addNext(AstClassOrPackageRef* nodep) { return static_cast<AstClassOrPackageRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstClassOrPackageRef(*this); } \
    AstPin* paramsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), Pin); } \
    void addParamsp(AstPin* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ClassOrPackageRef(...) AstNodeExpr(VNType::ClassOrPackageRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstClassPackage \
private: \
    AstClass* m_classp = nullptr;public: \
    AstClassPackage* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClassPackage*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstClassPackage* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClassPackage*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstClassPackage* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstClassPackage*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstClassPackage* cloneTreePure(bool cloneNext) { \
        return static_cast<AstClassPackage*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstClassPackage* clonep() const { return static_cast<AstClassPackage*>(AstNode::clonep()); } \
    AstClassPackage* addNext(AstClassPackage* nodep) { return static_cast<AstClassPackage*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstClassPackage(*this); } \
    AstNode* inlinesp() const VL_MT_STABLE { return op1p(); } \
    void addInlinesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeModule::inlinesp; \
    using AstNodeModule::addInlinesp; \
    using AstNodeModule::stmtsp; \
    using AstNodeModule::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ClassPackage(...) AstNodeModule(VNType::ClassPackage, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstClassRefDType \
private: \
    AstClass* m_classp = nullptr;    AstNodeModule* m_classOrPackagep = nullptr;public: \
    AstClassRefDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClassRefDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstClassRefDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClassRefDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstClassRefDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstClassRefDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstClassRefDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstClassRefDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstClassRefDType* clonep() const { return static_cast<AstClassRefDType*>(AstNode::clonep()); } \
    AstClassRefDType* addNext(AstClassRefDType* nodep) { return static_cast<AstClassRefDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstClassRefDType(*this); } \
    AstPin* paramsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), Pin); } \
    void addParamsp(AstPin* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ClassRefDType(...) AstNodeDType(VNType::ClassRefDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstClocking \
    AstClocking* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClocking*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstClocking* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClocking*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstClocking* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstClocking*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstClocking* cloneTreePure(bool cloneNext) { \
        return static_cast<AstClocking*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstClocking* clonep() const { return static_cast<AstClocking*>(AstNode::clonep()); } \
    AstClocking* addNext(AstClocking* nodep) { return static_cast<AstClocking*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstClocking(*this); } \
    AstSenItem* sensesp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), SenItem); } \
    void sensesp(AstSenItem* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* itemsp() const VL_MT_STABLE { return op2p(); } \
    void addItemsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstVar* eventp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), Var); } \
    void eventp(AstVar* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Clocking(...) AstNode(VNType::Clocking, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstClockingItem \
private: \
    AstClockingItem* m_outputp = nullptr;public: \
    AstClockingItem* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClockingItem*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstClockingItem* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstClockingItem*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstClockingItem* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstClockingItem*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstClockingItem* cloneTreePure(bool cloneNext) { \
        return static_cast<AstClockingItem*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstClockingItem* clonep() const { return static_cast<AstClockingItem*>(AstNode::clonep()); } \
    AstClockingItem* addNext(AstClockingItem* nodep) { return static_cast<AstClockingItem*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstClockingItem(*this); } \
    AstNodeExpr* skewp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void skewp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstAssign* assignp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), Assign); } \
    void assignp(AstAssign* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstVar* varp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), Var); } \
    void varp(AstVar* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ClockingItem(...) AstNode(VNType::ClockingItem, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstComment \
    AstComment* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstComment*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstComment* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstComment*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstComment* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstComment*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstComment* cloneTreePure(bool cloneNext) { \
        return static_cast<AstComment*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstComment* clonep() const { return static_cast<AstComment*>(AstNode::clonep()); } \
    AstComment* addNext(AstComment* nodep) { return static_cast<AstComment*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstComment(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Comment(...) AstNodeStmt(VNType::Comment, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCompareNN \
    AstCompareNN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCompareNN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCompareNN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCompareNN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCompareNN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCompareNN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCompareNN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCompareNN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCompareNN* clonep() const { return static_cast<AstCompareNN*>(AstNode::clonep()); } \
    AstCompareNN* addNext(AstCompareNN* nodep) { return static_cast<AstCompareNN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCompareNN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CompareNN(...) AstNodeBiop(VNType::CompareNN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConcat \
    AstConcat* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConcat*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConcat* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConcat*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConcat* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConcat*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConcat* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConcat*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConcat* clonep() const { return static_cast<AstConcat*>(AstNode::clonep()); } \
    AstConcat* addNext(AstConcat* nodep) { return static_cast<AstConcat*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConcat(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Concat(...) AstNodeBiop(VNType::Concat, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConcatN \
    AstConcatN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConcatN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConcatN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConcatN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConcatN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConcatN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConcatN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConcatN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConcatN* clonep() const { return static_cast<AstConcatN*>(AstNode::clonep()); } \
    AstConcatN* addNext(AstConcatN* nodep) { return static_cast<AstConcatN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConcatN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ConcatN(...) AstNodeBiop(VNType::ConcatN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCond \
    AstCond* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCond*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCond* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCond*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCond* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCond*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCond* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCond*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCond* clonep() const { return static_cast<AstCond*>(AstNode::clonep()); } \
    AstCond* addNext(AstCond* nodep) { return static_cast<AstCond*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCond(*this); } \
    AstNodeExpr* condp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void condp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thenp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void thenp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* elsep() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void elsep(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeTriop::lhsp; \
    using AstNodeTriop::rhsp; \
    using AstNodeTriop::thsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Cond(...) AstNodeTriop(VNType::Cond, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConfig \
    AstConfig* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConfig*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConfig* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConfig*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConfig* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConfig*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConfig* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConfig*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConfig* clonep() const { return static_cast<AstConfig*>(AstNode::clonep()); } \
    AstConfig* addNext(AstConfig* nodep) { return static_cast<AstConfig*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConfig(*this); } \
    AstConfigCell* designp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), ConfigCell); } \
    void addDesignp(AstConfigCell* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* itemsp() const VL_MT_STABLE { return op2p(); } \
    void addItemsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Config(...) AstNode(VNType::Config, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConfigCell \
    AstConfigCell* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConfigCell*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConfigCell* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConfigCell*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConfigCell* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConfigCell*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConfigCell* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConfigCell*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConfigCell* clonep() const { return static_cast<AstConfigCell*>(AstNode::clonep()); } \
    AstConfigCell* addNext(AstConfigCell* nodep) { return static_cast<AstConfigCell*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConfigCell(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConfigCell(...) AstNode(VNType::ConfigCell, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConfigRule \
    AstConfigRule* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConfigRule*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConfigRule* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConfigRule*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConfigRule* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConfigRule*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConfigRule* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConfigRule*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConfigRule* clonep() const { return static_cast<AstConfigRule*>(AstNode::clonep()); } \
    AstConfigRule* addNext(AstConfigRule* nodep) { return static_cast<AstConfigRule*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConfigRule(*this); } \
    AstNode* cellp() const VL_MT_STABLE { return op1p(); } \
    void cellp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* usep() const VL_MT_STABLE { return op2p(); } \
    void addUsep(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConfigRule(...) AstNode(VNType::ConfigRule, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConfigUse \
    AstConfigUse* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConfigUse*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConfigUse* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConfigUse*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConfigUse* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConfigUse*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConfigUse* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConfigUse*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConfigUse* clonep() const { return static_cast<AstConfigUse*>(AstNode::clonep()); } \
    AstConfigUse* addNext(AstConfigUse* nodep) { return static_cast<AstConfigUse*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConfigUse(*this); } \
    AstPin* paramsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), Pin); } \
    void addParamsp(AstPin* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConfigUse(...) AstNode(VNType::ConfigUse, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConsAssoc \
    AstConsAssoc* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConsAssoc*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConsAssoc* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConsAssoc*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConsAssoc* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConsAssoc*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConsAssoc* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConsAssoc*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConsAssoc* clonep() const { return static_cast<AstConsAssoc*>(AstNode::clonep()); } \
    AstConsAssoc* addNext(AstConsAssoc* nodep) { return static_cast<AstConsAssoc*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConsAssoc(*this); } \
    AstNode* defaultp() const VL_MT_STABLE { return op1p(); } \
    void defaultp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConsAssoc(...) AstNodeExpr(VNType::ConsAssoc, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConsDynArray \
    AstConsDynArray* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConsDynArray*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConsDynArray* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConsDynArray*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConsDynArray* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConsDynArray*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConsDynArray* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConsDynArray*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConsDynArray* clonep() const { return static_cast<AstConsDynArray*>(AstNode::clonep()); } \
    AstConsDynArray* addNext(AstConsDynArray* nodep) { return static_cast<AstConsDynArray*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConsDynArray(*this); } \
    AstNode* lhsp() const VL_MT_STABLE { return op1p(); } \
    void lhsp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* rhsp() const VL_MT_STABLE { return op2p(); } \
    void rhsp(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConsDynArray(...) AstNodeExpr(VNType::ConsDynArray, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConsPackMember \
    AstConsPackMember* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConsPackMember*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConsPackMember* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConsPackMember*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConsPackMember* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConsPackMember*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConsPackMember* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConsPackMember*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConsPackMember* clonep() const { return static_cast<AstConsPackMember*>(AstNode::clonep()); } \
    AstConsPackMember* addNext(AstConsPackMember* nodep) { return static_cast<AstConsPackMember*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConsPackMember(*this); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConsPackMember(...) AstNodeExpr(VNType::ConsPackMember, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConsPackUOrStruct \
    AstConsPackUOrStruct* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConsPackUOrStruct*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConsPackUOrStruct* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConsPackUOrStruct*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConsPackUOrStruct* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConsPackUOrStruct*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConsPackUOrStruct* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConsPackUOrStruct*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConsPackUOrStruct* clonep() const { return static_cast<AstConsPackUOrStruct*>(AstNode::clonep()); } \
    AstConsPackUOrStruct* addNext(AstConsPackUOrStruct* nodep) { return static_cast<AstConsPackUOrStruct*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConsPackUOrStruct(*this); } \
    AstConsPackMember* membersp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), ConsPackMember); } \
    void addMembersp(AstConsPackMember* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConsPackUOrStruct(...) AstNodeExpr(VNType::ConsPackUOrStruct, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConsQueue \
    AstConsQueue* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConsQueue*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConsQueue* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConsQueue*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConsQueue* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConsQueue*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConsQueue* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConsQueue*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConsQueue* clonep() const { return static_cast<AstConsQueue*>(AstNode::clonep()); } \
    AstConsQueue* addNext(AstConsQueue* nodep) { return static_cast<AstConsQueue*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConsQueue(*this); } \
    AstNode* lhsp() const VL_MT_STABLE { return op1p(); } \
    void lhsp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* rhsp() const VL_MT_STABLE { return op2p(); } \
    void rhsp(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConsQueue(...) AstNodeExpr(VNType::ConsQueue, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConsWildcard \
    AstConsWildcard* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConsWildcard*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConsWildcard* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConsWildcard*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConsWildcard* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConsWildcard*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConsWildcard* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConsWildcard*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConsWildcard* clonep() const { return static_cast<AstConsWildcard*>(AstNode::clonep()); } \
    AstConsWildcard* addNext(AstConsWildcard* nodep) { return static_cast<AstConsWildcard*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConsWildcard(*this); } \
    AstNode* defaultp() const VL_MT_STABLE { return op1p(); } \
    void defaultp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConsWildcard(...) AstNodeExpr(VNType::ConsWildcard, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConst \
    AstConst* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConst*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConst* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConst*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConst* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConst*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConst* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConst*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConst* clonep() const { return static_cast<AstConst*>(AstNode::clonep()); } \
    AstConst* addNext(AstConst* nodep) { return static_cast<AstConst*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConst(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Const(...) AstNodeExpr(VNType::Const, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConstDType \
private: \
    AstNodeDType* m_refDTypep = nullptr;public: \
    AstConstDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConstDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConstDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConstDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConstDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConstDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConstDType* clonep() const { return static_cast<AstConstDType*>(AstNode::clonep()); } \
    AstConstDType* addNext(AstConstDType* nodep) { return static_cast<AstConstDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConstDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConstDType(...) AstNodeDType(VNType::ConstDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConstPool \
private: \
    AstModule* m_modp = nullptr;    AstScope* m_scopep = nullptr;public: \
    AstConstPool* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstPool*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConstPool* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstPool*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConstPool* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConstPool*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConstPool* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConstPool*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConstPool* clonep() const { return static_cast<AstConstPool*>(AstNode::clonep()); } \
    AstConstPool* addNext(AstConstPool* nodep) { return static_cast<AstConstPool*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConstPool(*this); } \
    AstModule* modulep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), Module); } \
    void modulep(AstModule* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConstPool(...) AstNode(VNType::ConstPool, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConstraint \
    AstConstraint* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraint*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConstraint* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraint*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConstraint* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConstraint*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConstraint* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConstraint*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConstraint* clonep() const { return static_cast<AstConstraint*>(AstNode::clonep()); } \
    AstConstraint* addNext(AstConstraint* nodep) { return static_cast<AstConstraint*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConstraint(*this); } \
    AstNode* itemsp() const VL_MT_STABLE { return op1p(); } \
    void addItemsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* classOrPackagep() const VL_MT_STABLE { return op2p(); } \
    void classOrPackagep(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Constraint(...) AstNode(VNType::Constraint, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConstraintBefore \
    AstConstraintBefore* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintBefore*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConstraintBefore* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintBefore*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConstraintBefore* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConstraintBefore*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConstraintBefore* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConstraintBefore*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConstraintBefore* clonep() const { return static_cast<AstConstraintBefore*>(AstNode::clonep()); } \
    AstConstraintBefore* addNext(AstConstraintBefore* nodep) { return static_cast<AstConstraintBefore*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConstraintBefore(*this); } \
    AstNodeExpr* lhssp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void addLhssp(AstNodeExpr* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhssp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void addRhssp(AstNodeExpr* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConstraintBefore(...) AstNode(VNType::ConstraintBefore, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConstraintExpr \
    AstConstraintExpr* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintExpr*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConstraintExpr* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintExpr*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConstraintExpr* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConstraintExpr*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConstraintExpr* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConstraintExpr*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConstraintExpr* clonep() const { return static_cast<AstConstraintExpr*>(AstNode::clonep()); } \
    AstConstraintExpr* addNext(AstConstraintExpr* nodep) { return static_cast<AstConstraintExpr*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConstraintExpr(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConstraintExpr(...) AstNodeStmt(VNType::ConstraintExpr, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConstraintForeach \
    AstConstraintForeach* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintForeach*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConstraintForeach* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintForeach*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConstraintForeach* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConstraintForeach*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConstraintForeach* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConstraintForeach*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConstraintForeach* clonep() const { return static_cast<AstConstraintForeach*>(AstNode::clonep()); } \
    AstConstraintForeach* addNext(AstConstraintForeach* nodep) { return static_cast<AstConstraintForeach*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConstraintForeach(*this); } \
    AstNode* arrayp() const VL_MT_STABLE { return op1p(); } \
    void arrayp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeForeach::arrayp; \
    using AstNodeForeach::stmtsp; \
    using AstNodeForeach::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ConstraintForeach(...) AstNodeForeach(VNType::ConstraintForeach, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConstraintIf \
    AstConstraintIf* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintIf*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConstraintIf* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintIf*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConstraintIf* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConstraintIf*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConstraintIf* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConstraintIf*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConstraintIf* clonep() const { return static_cast<AstConstraintIf*>(AstNode::clonep()); } \
    AstConstraintIf* addNext(AstConstraintIf* nodep) { return static_cast<AstConstraintIf*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConstraintIf(*this); } \
    AstNodeExpr* condp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void condp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* thensp() const VL_MT_STABLE { return op2p(); } \
    void addThensp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* elsesp() const VL_MT_STABLE { return op3p(); } \
    void addElsesp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeIf::condp; \
    using AstNodeIf::thensp; \
    using AstNodeIf::addThensp; \
    using AstNodeIf::elsesp; \
    using AstNodeIf::addElsesp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ConstraintIf(...) AstNodeIf(VNType::ConstraintIf, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConstraintRef \
private: \
    AstConstraint* m_constrp = nullptr;    AstNodeModule* m_classOrPackagep = nullptr;public: \
    AstConstraintRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConstraintRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConstraintRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConstraintRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConstraintRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConstraintRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConstraintRef* clonep() const { return static_cast<AstConstraintRef*>(AstNode::clonep()); } \
    AstConstraintRef* addNext(AstConstraintRef* nodep) { return static_cast<AstConstraintRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConstraintRef(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConstraintRef(...) AstNodeExpr(VNType::ConstraintRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConstraintRefDType \
    AstConstraintRefDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintRefDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConstraintRefDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintRefDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConstraintRefDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConstraintRefDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConstraintRefDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConstraintRefDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConstraintRefDType* clonep() const { return static_cast<AstConstraintRefDType*>(AstNode::clonep()); } \
    AstConstraintRefDType* addNext(AstConstraintRefDType* nodep) { return static_cast<AstConstraintRefDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConstraintRefDType(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConstraintRefDType(...) AstNodeDType(VNType::ConstraintRefDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstConstraintUnique \
    AstConstraintUnique* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintUnique*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstConstraintUnique* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstConstraintUnique*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstConstraintUnique* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstConstraintUnique*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstConstraintUnique* cloneTreePure(bool cloneNext) { \
        return static_cast<AstConstraintUnique*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstConstraintUnique* clonep() const { return static_cast<AstConstraintUnique*>(AstNode::clonep()); } \
    AstConstraintUnique* addNext(AstConstraintUnique* nodep) { return static_cast<AstConstraintUnique*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstConstraintUnique(*this); } \
    AstNode* rangesp() const VL_MT_STABLE { return op1p(); } \
    void addRangesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ConstraintUnique(...) AstNodeStmt(VNType::ConstraintUnique, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstContinue \
    AstContinue* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstContinue*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstContinue* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstContinue*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstContinue* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstContinue*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstContinue* cloneTreePure(bool cloneNext) { \
        return static_cast<AstContinue*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstContinue* clonep() const { return static_cast<AstContinue*>(AstNode::clonep()); } \
    AstContinue* addNext(AstContinue* nodep) { return static_cast<AstContinue*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstContinue(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Continue(...) AstNodeStmt(VNType::Continue, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCosD \
    AstCosD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCosD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCosD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCosD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCosD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCosD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCosD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCosD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCosD* clonep() const { return static_cast<AstCosD*>(AstNode::clonep()); } \
    AstCosD* addNext(AstCosD* nodep) { return static_cast<AstCosD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCosD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CosD(...) AstNodeSystemUniopD(VNType::CosD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCoshD \
    AstCoshD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCoshD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCoshD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCoshD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCoshD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCoshD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCoshD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCoshD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCoshD* clonep() const { return static_cast<AstCoshD*>(AstNode::clonep()); } \
    AstCoshD* addNext(AstCoshD* nodep) { return static_cast<AstCoshD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCoshD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CoshD(...) AstNodeSystemUniopD(VNType::CoshD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCountBits \
    AstCountBits* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCountBits*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCountBits* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCountBits*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCountBits* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCountBits*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCountBits* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCountBits*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCountBits* clonep() const { return static_cast<AstCountBits*>(AstNode::clonep()); } \
    AstCountBits* addNext(AstCountBits* nodep) { return static_cast<AstCountBits*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCountBits(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* fhsp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), NodeExpr); } \
    void fhsp(AstNodeExpr* nodep) { setOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeQuadop::lhsp; \
    using AstNodeQuadop::rhsp; \
    using AstNodeQuadop::thsp; \
    using AstNodeQuadop::fhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CountBits(...) AstNodeQuadop(VNType::CountBits, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCountOnes \
    AstCountOnes* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCountOnes*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCountOnes* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCountOnes*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCountOnes* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCountOnes*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCountOnes* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCountOnes*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCountOnes* clonep() const { return static_cast<AstCountOnes*>(AstNode::clonep()); } \
    AstCountOnes* addNext(AstCountOnes* nodep) { return static_cast<AstCountOnes*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCountOnes(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CountOnes(...) AstNodeUniop(VNType::CountOnes, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCover \
    AstCover* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCover*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCover* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCover*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCover* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCover*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCover* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCover*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCover* clonep() const { return static_cast<AstCover*>(AstNode::clonep()); } \
    AstCover* addNext(AstCover* nodep) { return static_cast<AstCover*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCover(*this); } \
    AstNode* propp() const VL_MT_STABLE { return op1p(); } \
    void propp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* coverincsp() const VL_MT_STABLE { return op3p(); } \
    void addCoverincsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* passsp() const VL_MT_STABLE { return op4p(); } \
    void addPasssp(AstNode* nodep) { addNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeCoverOrAssert::propp; \
    using AstNodeCoverOrAssert::sentreep; \
    using AstNodeCoverOrAssert::passsp; \
    using AstNodeCoverOrAssert::addPasssp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Cover(...) AstNodeCoverOrAssert(VNType::Cover, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCoverInc \
private: \
    AstNodeCoverDecl* m_declp = nullptr;public: \
    AstCoverInc* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCoverInc*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCoverInc* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCoverInc*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCoverInc* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCoverInc*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCoverInc* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCoverInc*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCoverInc* clonep() const { return static_cast<AstCoverInc*>(AstNode::clonep()); } \
    AstCoverInc* addNext(AstCoverInc* nodep) { return static_cast<AstCoverInc*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCoverInc(*this); } \
    AstNodeExpr* toggleExprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void toggleExprp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* toggleCovExprp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void toggleCovExprp(AstNodeExpr* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CoverInc(...) AstNodeStmt(VNType::CoverInc, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCoverOtherDecl \
    AstCoverOtherDecl* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCoverOtherDecl*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCoverOtherDecl* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCoverOtherDecl*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCoverOtherDecl* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCoverOtherDecl*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCoverOtherDecl* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCoverOtherDecl*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCoverOtherDecl* clonep() const { return static_cast<AstCoverOtherDecl*>(AstNode::clonep()); } \
    AstCoverOtherDecl* addNext(AstCoverOtherDecl* nodep) { return static_cast<AstCoverOtherDecl*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCoverOtherDecl(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CoverOtherDecl(...) AstNodeCoverDecl(VNType::CoverOtherDecl, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCoverToggle \
    AstCoverToggle* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCoverToggle*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCoverToggle* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCoverToggle*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCoverToggle* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCoverToggle*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCoverToggle* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCoverToggle*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCoverToggle* clonep() const { return static_cast<AstCoverToggle*>(AstNode::clonep()); } \
    AstCoverToggle* addNext(AstCoverToggle* nodep) { return static_cast<AstCoverToggle*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCoverToggle(*this); } \
    AstCoverInc* incp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), CoverInc); } \
    void incp(AstCoverInc* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* origp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void origp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* changep() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void changep(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CoverToggle(...) AstNodeStmt(VNType::CoverToggle, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCoverToggleDecl \
    AstCoverToggleDecl* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCoverToggleDecl*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCoverToggleDecl* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCoverToggleDecl*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCoverToggleDecl* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCoverToggleDecl*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCoverToggleDecl* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCoverToggleDecl*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCoverToggleDecl* clonep() const { return static_cast<AstCoverToggleDecl*>(AstNode::clonep()); } \
    AstCoverToggleDecl* addNext(AstCoverToggleDecl* nodep) { return static_cast<AstCoverToggleDecl*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCoverToggleDecl(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CoverToggleDecl(...) AstNodeCoverDecl(VNType::CoverToggleDecl, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCvtArrayToArray \
    AstCvtArrayToArray* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCvtArrayToArray*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCvtArrayToArray* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCvtArrayToArray*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCvtArrayToArray* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCvtArrayToArray*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCvtArrayToArray* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCvtArrayToArray*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCvtArrayToArray* clonep() const { return static_cast<AstCvtArrayToArray*>(AstNode::clonep()); } \
    AstCvtArrayToArray* addNext(AstCvtArrayToArray* nodep) { return static_cast<AstCvtArrayToArray*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCvtArrayToArray(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CvtArrayToArray(...) AstNodeExpr(VNType::CvtArrayToArray, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCvtArrayToPacked \
    AstCvtArrayToPacked* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCvtArrayToPacked*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCvtArrayToPacked* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCvtArrayToPacked*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCvtArrayToPacked* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCvtArrayToPacked*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCvtArrayToPacked* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCvtArrayToPacked*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCvtArrayToPacked* clonep() const { return static_cast<AstCvtArrayToPacked*>(AstNode::clonep()); } \
    AstCvtArrayToPacked* addNext(AstCvtArrayToPacked* nodep) { return static_cast<AstCvtArrayToPacked*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCvtArrayToPacked(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CvtArrayToPacked(...) AstNodeExpr(VNType::CvtArrayToPacked, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCvtPackString \
    AstCvtPackString* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCvtPackString*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCvtPackString* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCvtPackString*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCvtPackString* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCvtPackString*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCvtPackString* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCvtPackString*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCvtPackString* clonep() const { return static_cast<AstCvtPackString*>(AstNode::clonep()); } \
    AstCvtPackString* addNext(AstCvtPackString* nodep) { return static_cast<AstCvtPackString*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCvtPackString(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_CvtPackString(...) AstNodeUniop(VNType::CvtPackString, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCvtPackedToArray \
    AstCvtPackedToArray* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCvtPackedToArray*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCvtPackedToArray* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCvtPackedToArray*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCvtPackedToArray* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCvtPackedToArray*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCvtPackedToArray* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCvtPackedToArray*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCvtPackedToArray* clonep() const { return static_cast<AstCvtPackedToArray*>(AstNode::clonep()); } \
    AstCvtPackedToArray* addNext(AstCvtPackedToArray* nodep) { return static_cast<AstCvtPackedToArray*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCvtPackedToArray(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CvtPackedToArray(...) AstNodeExpr(VNType::CvtPackedToArray, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstCvtUnpackedToQueue \
    AstCvtUnpackedToQueue* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCvtUnpackedToQueue*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstCvtUnpackedToQueue* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstCvtUnpackedToQueue*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstCvtUnpackedToQueue* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstCvtUnpackedToQueue*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstCvtUnpackedToQueue* cloneTreePure(bool cloneNext) { \
        return static_cast<AstCvtUnpackedToQueue*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstCvtUnpackedToQueue* clonep() const { return static_cast<AstCvtUnpackedToQueue*>(AstNode::clonep()); } \
    AstCvtUnpackedToQueue* addNext(AstCvtUnpackedToQueue* nodep) { return static_cast<AstCvtUnpackedToQueue*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstCvtUnpackedToQueue(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_CvtUnpackedToQueue(...) AstNodeExpr(VNType::CvtUnpackedToQueue, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDefImplicitDType \
    AstDefImplicitDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDefImplicitDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDefImplicitDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDefImplicitDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDefImplicitDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDefImplicitDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDefImplicitDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDefImplicitDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDefImplicitDType* clonep() const { return static_cast<AstDefImplicitDType*>(AstNode::clonep()); } \
    AstDefImplicitDType* addNext(AstDefImplicitDType* nodep) { return static_cast<AstDefImplicitDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDefImplicitDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_DefImplicitDType(...) AstNodeDType(VNType::DefImplicitDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDefParam \
    AstDefParam* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDefParam*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDefParam* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDefParam*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDefParam* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDefParam*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDefParam* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDefParam*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDefParam* clonep() const { return static_cast<AstDefParam*>(AstNode::clonep()); } \
    AstDefParam* addNext(AstDefParam* nodep) { return static_cast<AstDefParam*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDefParam(*this); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_DefParam(...) AstNode(VNType::DefParam, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDefaultDisable \
    AstDefaultDisable* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDefaultDisable*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDefaultDisable* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDefaultDisable*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDefaultDisable* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDefaultDisable*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDefaultDisable* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDefaultDisable*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDefaultDisable* clonep() const { return static_cast<AstDefaultDisable*>(AstNode::clonep()); } \
    AstDefaultDisable* addNext(AstDefaultDisable* nodep) { return static_cast<AstDefaultDisable*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDefaultDisable(*this); } \
    AstNodeExpr* condp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void condp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_DefaultDisable(...) AstNode(VNType::DefaultDisable, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDelay \
    AstDelay* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDelay*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDelay* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDelay*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDelay* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDelay*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDelay* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDelay*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDelay* clonep() const { return static_cast<AstDelay*>(AstNode::clonep()); } \
    AstDelay* addNext(AstDelay* nodep) { return static_cast<AstDelay*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDelay(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Delay(...) AstNodeStmt(VNType::Delay, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDisable \
private: \
    AstNode* m_targetp = nullptr;public: \
    AstDisable* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDisable*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDisable* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDisable*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDisable* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDisable*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDisable* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDisable*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDisable* clonep() const { return static_cast<AstDisable*>(AstNode::clonep()); } \
    AstDisable* addNext(AstDisable* nodep) { return static_cast<AstDisable*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDisable(*this); } \
    AstNodeExpr* targetRefp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void targetRefp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Disable(...) AstNodeStmt(VNType::Disable, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDisableFork \
    AstDisableFork* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDisableFork*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDisableFork* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDisableFork*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDisableFork* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDisableFork*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDisableFork* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDisableFork*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDisableFork* clonep() const { return static_cast<AstDisableFork*>(AstNode::clonep()); } \
    AstDisableFork* addNext(AstDisableFork* nodep) { return static_cast<AstDisableFork*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDisableFork(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_DisableFork(...) AstNodeStmt(VNType::DisableFork, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDisplay \
    AstDisplay* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDisplay*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDisplay* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDisplay*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDisplay* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDisplay*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDisplay* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDisplay*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDisplay* clonep() const { return static_cast<AstDisplay*>(AstNode::clonep()); } \
    AstDisplay* addNext(AstDisplay* nodep) { return static_cast<AstDisplay*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDisplay(*this); } \
    AstSFormatF* fmtp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), SFormatF); } \
    void fmtp(AstSFormatF* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* filep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void filep(AstNodeExpr* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Display(...) AstNodeStmt(VNType::Display, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDist \
    AstDist* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDist*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDist* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDist*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDist* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDist*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDist* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDist*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDist* clonep() const { return static_cast<AstDist*>(AstNode::clonep()); } \
    AstDist* addNext(AstDist* nodep) { return static_cast<AstDist*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDist(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstDistItem* itemsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), DistItem); } \
    void addItemsp(AstDistItem* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Dist(...) AstNodeExpr(VNType::Dist, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDistChiSquare \
    AstDistChiSquare* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistChiSquare*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDistChiSquare* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistChiSquare*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDistChiSquare* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDistChiSquare*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDistChiSquare* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDistChiSquare*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDistChiSquare* clonep() const { return static_cast<AstDistChiSquare*>(AstNode::clonep()); } \
    AstDistChiSquare* addNext(AstDistChiSquare* nodep) { return static_cast<AstDistChiSquare*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDistChiSquare(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeDistBiop::lhsp; \
    using AstNodeDistBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_DistChiSquare(...) AstNodeDistBiop(VNType::DistChiSquare, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDistErlang \
    AstDistErlang* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistErlang*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDistErlang* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistErlang*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDistErlang* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDistErlang*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDistErlang* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDistErlang*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDistErlang* clonep() const { return static_cast<AstDistErlang*>(AstNode::clonep()); } \
    AstDistErlang* addNext(AstDistErlang* nodep) { return static_cast<AstDistErlang*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDistErlang(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeDistTriop::lhsp; \
    using AstNodeDistTriop::rhsp; \
    using AstNodeDistTriop::thsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_DistErlang(...) AstNodeDistTriop(VNType::DistErlang, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDistExponential \
    AstDistExponential* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistExponential*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDistExponential* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistExponential*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDistExponential* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDistExponential*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDistExponential* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDistExponential*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDistExponential* clonep() const { return static_cast<AstDistExponential*>(AstNode::clonep()); } \
    AstDistExponential* addNext(AstDistExponential* nodep) { return static_cast<AstDistExponential*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDistExponential(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeDistBiop::lhsp; \
    using AstNodeDistBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_DistExponential(...) AstNodeDistBiop(VNType::DistExponential, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDistItem \
    AstDistItem* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistItem*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDistItem* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistItem*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDistItem* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDistItem*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDistItem* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDistItem*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDistItem* clonep() const { return static_cast<AstDistItem*>(AstNode::clonep()); } \
    AstDistItem* addNext(AstDistItem* nodep) { return static_cast<AstDistItem*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDistItem(*this); } \
    AstNodeExpr* rangep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void rangep(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* weightp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void weightp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_DistItem(...) AstNodeExpr(VNType::DistItem, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDistNormal \
    AstDistNormal* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistNormal*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDistNormal* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistNormal*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDistNormal* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDistNormal*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDistNormal* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDistNormal*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDistNormal* clonep() const { return static_cast<AstDistNormal*>(AstNode::clonep()); } \
    AstDistNormal* addNext(AstDistNormal* nodep) { return static_cast<AstDistNormal*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDistNormal(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeDistTriop::lhsp; \
    using AstNodeDistTriop::rhsp; \
    using AstNodeDistTriop::thsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_DistNormal(...) AstNodeDistTriop(VNType::DistNormal, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDistPoisson \
    AstDistPoisson* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistPoisson*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDistPoisson* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistPoisson*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDistPoisson* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDistPoisson*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDistPoisson* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDistPoisson*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDistPoisson* clonep() const { return static_cast<AstDistPoisson*>(AstNode::clonep()); } \
    AstDistPoisson* addNext(AstDistPoisson* nodep) { return static_cast<AstDistPoisson*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDistPoisson(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeDistBiop::lhsp; \
    using AstNodeDistBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_DistPoisson(...) AstNodeDistBiop(VNType::DistPoisson, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDistT \
    AstDistT* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistT*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDistT* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistT*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDistT* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDistT*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDistT* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDistT*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDistT* clonep() const { return static_cast<AstDistT*>(AstNode::clonep()); } \
    AstDistT* addNext(AstDistT* nodep) { return static_cast<AstDistT*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDistT(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeDistBiop::lhsp; \
    using AstNodeDistBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_DistT(...) AstNodeDistBiop(VNType::DistT, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDistUniform \
    AstDistUniform* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistUniform*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDistUniform* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDistUniform*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDistUniform* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDistUniform*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDistUniform* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDistUniform*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDistUniform* clonep() const { return static_cast<AstDistUniform*>(AstNode::clonep()); } \
    AstDistUniform* addNext(AstDistUniform* nodep) { return static_cast<AstDistUniform*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDistUniform(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeDistTriop::lhsp; \
    using AstNodeDistTriop::rhsp; \
    using AstNodeDistTriop::thsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_DistUniform(...) AstNodeDistTriop(VNType::DistUniform, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDiv \
    AstDiv* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDiv*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDiv* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDiv*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDiv* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDiv*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDiv* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDiv*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDiv* clonep() const { return static_cast<AstDiv*>(AstNode::clonep()); } \
    AstDiv* addNext(AstDiv* nodep) { return static_cast<AstDiv*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDiv(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Div(...) AstNodeBiop(VNType::Div, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDivD \
    AstDivD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDivD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDivD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDivD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDivD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDivD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDivD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDivD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDivD* clonep() const { return static_cast<AstDivD*>(AstNode::clonep()); } \
    AstDivD* addNext(AstDivD* nodep) { return static_cast<AstDivD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDivD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_DivD(...) AstNodeBiop(VNType::DivD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDivS \
    AstDivS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDivS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDivS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDivS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDivS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDivS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDivS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDivS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDivS* clonep() const { return static_cast<AstDivS*>(AstNode::clonep()); } \
    AstDivS* addNext(AstDivS* nodep) { return static_cast<AstDivS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDivS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_DivS(...) AstNodeBiop(VNType::DivS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDot \
    AstDot* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDot*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDot* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDot*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDot* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDot*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDot* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDot*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDot* clonep() const { return static_cast<AstDot*>(AstNode::clonep()); } \
    AstDot* addNext(AstDot* nodep) { return static_cast<AstDot*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDot(*this); } \
    AstNode* lhsp() const VL_MT_STABLE { return op1p(); } \
    void lhsp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* rhsp() const VL_MT_STABLE { return op2p(); } \
    void rhsp(AstNode* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Dot(...) AstNodeExpr(VNType::Dot, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDpiExport \
    AstDpiExport* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDpiExport*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDpiExport* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDpiExport*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDpiExport* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDpiExport*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDpiExport* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDpiExport*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDpiExport* clonep() const { return static_cast<AstDpiExport*>(AstNode::clonep()); } \
    AstDpiExport* addNext(AstDpiExport* nodep) { return static_cast<AstDpiExport*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDpiExport(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_DpiExport(...) AstNode(VNType::DpiExport, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDumpCtl \
    AstDumpCtl* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDumpCtl*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDumpCtl* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDumpCtl*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDumpCtl* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDumpCtl*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDumpCtl* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDumpCtl*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDumpCtl* clonep() const { return static_cast<AstDumpCtl*>(AstNode::clonep()); } \
    AstDumpCtl* addNext(AstDumpCtl* nodep) { return static_cast<AstDumpCtl*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDumpCtl(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_DumpCtl(...) AstNodeStmt(VNType::DumpCtl, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstDynArrayDType \
private: \
    AstNodeDType* m_refDTypep = nullptr;public: \
    AstDynArrayDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDynArrayDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstDynArrayDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstDynArrayDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstDynArrayDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstDynArrayDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstDynArrayDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstDynArrayDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstDynArrayDType* clonep() const { return static_cast<AstDynArrayDType*>(AstNode::clonep()); } \
    AstDynArrayDType* addNext(AstDynArrayDType* nodep) { return static_cast<AstDynArrayDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstDynArrayDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_DynArrayDType(...) AstNodeDType(VNType::DynArrayDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstElabDisplay \
    AstElabDisplay* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstElabDisplay*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstElabDisplay* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstElabDisplay*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstElabDisplay* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstElabDisplay*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstElabDisplay* cloneTreePure(bool cloneNext) { \
        return static_cast<AstElabDisplay*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstElabDisplay* clonep() const { return static_cast<AstElabDisplay*>(AstNode::clonep()); } \
    AstElabDisplay* addNext(AstElabDisplay* nodep) { return static_cast<AstElabDisplay*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstElabDisplay(*this); } \
    AstSFormatF* fmtp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), SFormatF); } \
    void addFmtp(AstSFormatF* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ElabDisplay(...) AstNode(VNType::ElabDisplay, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEmpty \
    AstEmpty* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEmpty*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEmpty* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEmpty*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEmpty* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEmpty*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEmpty* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEmpty*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEmpty* clonep() const { return static_cast<AstEmpty*>(AstNode::clonep()); } \
    AstEmpty* addNext(AstEmpty* nodep) { return static_cast<AstEmpty*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEmpty(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Empty(...) AstNode(VNType::Empty, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEmptyQueue \
    AstEmptyQueue* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEmptyQueue*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEmptyQueue* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEmptyQueue*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEmptyQueue* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEmptyQueue*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEmptyQueue* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEmptyQueue*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEmptyQueue* clonep() const { return static_cast<AstEmptyQueue*>(AstNode::clonep()); } \
    AstEmptyQueue* addNext(AstEmptyQueue* nodep) { return static_cast<AstEmptyQueue*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEmptyQueue(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_EmptyQueue(...) AstNodeExpr(VNType::EmptyQueue, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEmptyQueueDType \
    AstEmptyQueueDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEmptyQueueDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEmptyQueueDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEmptyQueueDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEmptyQueueDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEmptyQueueDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEmptyQueueDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEmptyQueueDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEmptyQueueDType* clonep() const { return static_cast<AstEmptyQueueDType*>(AstNode::clonep()); } \
    AstEmptyQueueDType* addNext(AstEmptyQueueDType* nodep) { return static_cast<AstEmptyQueueDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEmptyQueueDType(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_EmptyQueueDType(...) AstNodeDType(VNType::EmptyQueueDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEnumDType \
private: \
    AstNodeDType* m_refDTypep = nullptr;public: \
    AstEnumDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEnumDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEnumDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEnumDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEnumDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEnumDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEnumDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEnumDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEnumDType* clonep() const { return static_cast<AstEnumDType*>(AstNode::clonep()); } \
    AstEnumDType* addNext(AstEnumDType* nodep) { return static_cast<AstEnumDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEnumDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstEnumItem* itemsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), EnumItem); } \
    void addItemsp(AstEnumItem* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_EnumDType(...) AstNodeDType(VNType::EnumDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEnumItem \
    AstEnumItem* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEnumItem*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEnumItem* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEnumItem*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEnumItem* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEnumItem*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEnumItem* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEnumItem*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEnumItem* clonep() const { return static_cast<AstEnumItem*>(AstNode::clonep()); } \
    AstEnumItem* addNext(AstEnumItem* nodep) { return static_cast<AstEnumItem*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEnumItem(*this); } \
    AstRange* rangep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), Range); } \
    void rangep(AstRange* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* valuep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void valuep(AstNodeExpr* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_EnumItem(...) AstNode(VNType::EnumItem, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEnumItemRef \
private: \
    AstEnumItem* m_itemp = nullptr;    AstNodeModule* m_classOrPackagep = nullptr;public: \
    AstEnumItemRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEnumItemRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEnumItemRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEnumItemRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEnumItemRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEnumItemRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEnumItemRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEnumItemRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEnumItemRef* clonep() const { return static_cast<AstEnumItemRef*>(AstNode::clonep()); } \
    AstEnumItemRef* addNext(AstEnumItemRef* nodep) { return static_cast<AstEnumItemRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEnumItemRef(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_EnumItemRef(...) AstNodeExpr(VNType::EnumItemRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEq \
    AstEq* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEq*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEq* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEq*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEq* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEq*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEq* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEq*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEq* clonep() const { return static_cast<AstEq*>(AstNode::clonep()); } \
    AstEq* addNext(AstEq* nodep) { return static_cast<AstEq*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEq(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiCom::lhsp; \
    using AstNodeBiCom::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Eq(...) AstNodeBiCom(VNType::Eq, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEqCase \
    AstEqCase* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEqCase*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEqCase* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEqCase*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEqCase* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEqCase*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEqCase* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEqCase*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEqCase* clonep() const { return static_cast<AstEqCase*>(AstNode::clonep()); } \
    AstEqCase* addNext(AstEqCase* nodep) { return static_cast<AstEqCase*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEqCase(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiCom::lhsp; \
    using AstNodeBiCom::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_EqCase(...) AstNodeBiCom(VNType::EqCase, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEqD \
    AstEqD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEqD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEqD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEqD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEqD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEqD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEqD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEqD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEqD* clonep() const { return static_cast<AstEqD*>(AstNode::clonep()); } \
    AstEqD* addNext(AstEqD* nodep) { return static_cast<AstEqD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEqD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiCom::lhsp; \
    using AstNodeBiCom::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_EqD(...) AstNodeBiCom(VNType::EqD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEqN \
    AstEqN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEqN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEqN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEqN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEqN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEqN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEqN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEqN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEqN* clonep() const { return static_cast<AstEqN*>(AstNode::clonep()); } \
    AstEqN* addNext(AstEqN* nodep) { return static_cast<AstEqN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEqN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiCom::lhsp; \
    using AstNodeBiCom::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_EqN(...) AstNodeBiCom(VNType::EqN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEqT \
    AstEqT* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEqT*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEqT* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEqT*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEqT* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEqT*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEqT* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEqT*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEqT* clonep() const { return static_cast<AstEqT*>(AstNode::clonep()); } \
    AstEqT* addNext(AstEqT* nodep) { return static_cast<AstEqT*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEqT(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiCom::lhsp; \
    using AstNodeBiCom::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_EqT(...) AstNodeBiCom(VNType::EqT, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEqWild \
    AstEqWild* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEqWild*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEqWild* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEqWild*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEqWild* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEqWild*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEqWild* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEqWild*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEqWild* clonep() const { return static_cast<AstEqWild*>(AstNode::clonep()); } \
    AstEqWild* addNext(AstEqWild* nodep) { return static_cast<AstEqWild*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEqWild(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_EqWild(...) AstNodeBiop(VNType::EqWild, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstEventControl \
    AstEventControl* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEventControl*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstEventControl* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstEventControl*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstEventControl* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstEventControl*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstEventControl* cloneTreePure(bool cloneNext) { \
        return static_cast<AstEventControl*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstEventControl* clonep() const { return static_cast<AstEventControl*>(AstNode::clonep()); } \
    AstEventControl* addNext(AstEventControl* nodep) { return static_cast<AstEventControl*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstEventControl(*this); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_EventControl(...) AstNodeStmt(VNType::EventControl, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstExecGraph \
    AstExecGraph* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstExecGraph*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstExecGraph* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstExecGraph*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstExecGraph* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstExecGraph*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstExecGraph* cloneTreePure(bool cloneNext) { \
        return static_cast<AstExecGraph*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstExecGraph* clonep() const { return static_cast<AstExecGraph*>(AstNode::clonep()); } \
    AstExecGraph* addNext(AstExecGraph* nodep) { return static_cast<AstExecGraph*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstExecGraph(*this); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op1p(); } \
    void addStmtsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ExecGraph(...) AstNodeStmt(VNType::ExecGraph, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstExpD \
    AstExpD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstExpD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstExpD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstExpD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstExpD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstExpD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstExpD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstExpD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstExpD* clonep() const { return static_cast<AstExpD*>(AstNode::clonep()); } \
    AstExpD* addNext(AstExpD* nodep) { return static_cast<AstExpD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstExpD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ExpD(...) AstNodeSystemUniopD(VNType::ExpD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstExprStmt \
    AstExprStmt* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstExprStmt*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstExprStmt* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstExprStmt*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstExprStmt* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstExprStmt*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstExprStmt* cloneTreePure(bool cloneNext) { \
        return static_cast<AstExprStmt*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstExprStmt* clonep() const { return static_cast<AstExprStmt*>(AstNode::clonep()); } \
    AstExprStmt* addNext(AstExprStmt* nodep) { return static_cast<AstExprStmt*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstExprStmt(*this); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op1p(); } \
    void addStmtsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* resultp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void resultp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ExprStmt(...) AstNodeExpr(VNType::ExprStmt, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstExtend \
    AstExtend* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstExtend*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstExtend* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstExtend*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstExtend* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstExtend*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstExtend* cloneTreePure(bool cloneNext) { \
        return static_cast<AstExtend*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstExtend* clonep() const { return static_cast<AstExtend*>(AstNode::clonep()); } \
    AstExtend* addNext(AstExtend* nodep) { return static_cast<AstExtend*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstExtend(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Extend(...) AstNodeUniop(VNType::Extend, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstExtendS \
    AstExtendS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstExtendS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstExtendS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstExtendS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstExtendS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstExtendS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstExtendS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstExtendS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstExtendS* clonep() const { return static_cast<AstExtendS*>(AstNode::clonep()); } \
    AstExtendS* addNext(AstExtendS* nodep) { return static_cast<AstExtendS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstExtendS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ExtendS(...) AstNodeUniop(VNType::ExtendS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFClose \
    AstFClose* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFClose*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFClose* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFClose*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFClose* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFClose*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFClose* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFClose*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFClose* clonep() const { return static_cast<AstFClose*>(AstNode::clonep()); } \
    AstFClose* addNext(AstFClose* nodep) { return static_cast<AstFClose*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFClose(*this); } \
    AstNodeExpr* filep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void filep(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_FClose(...) AstNodeStmt(VNType::FClose, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFEof \
    AstFEof* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFEof*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFEof* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFEof*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFEof* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFEof*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFEof* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFEof*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFEof* clonep() const { return static_cast<AstFEof*>(AstNode::clonep()); } \
    AstFEof* addNext(AstFEof* nodep) { return static_cast<AstFEof*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFEof(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_FEof(...) AstNodeUniop(VNType::FEof, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFError \
    AstFError* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFError*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFError* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFError*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFError* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFError*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFError* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFError*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFError* clonep() const { return static_cast<AstFError*>(AstNode::clonep()); } \
    AstFError* addNext(AstFError* nodep) { return static_cast<AstFError*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFError(*this); } \
    AstNode* filep() const VL_MT_STABLE { return op1p(); } \
    void filep(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* strp() const VL_MT_STABLE { return op2p(); } \
    void strp(AstNode* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_FError(...) AstNodeExpr(VNType::FError, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFFlush \
    AstFFlush* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFFlush*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFFlush* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFFlush*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFFlush* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFFlush*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFFlush* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFFlush*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFFlush* clonep() const { return static_cast<AstFFlush*>(AstNode::clonep()); } \
    AstFFlush* addNext(AstFFlush* nodep) { return static_cast<AstFFlush*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFFlush(*this); } \
    AstNodeExpr* filep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void filep(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_FFlush(...) AstNodeStmt(VNType::FFlush, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFGetC \
    AstFGetC* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFGetC*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFGetC* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFGetC*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFGetC* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFGetC*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFGetC* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFGetC*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFGetC* clonep() const { return static_cast<AstFGetC*>(AstNode::clonep()); } \
    AstFGetC* addNext(AstFGetC* nodep) { return static_cast<AstFGetC*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFGetC(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_FGetC(...) AstNodeUniop(VNType::FGetC, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFGetS \
    AstFGetS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFGetS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFGetS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFGetS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFGetS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFGetS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFGetS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFGetS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFGetS* clonep() const { return static_cast<AstFGetS*>(AstNode::clonep()); } \
    AstFGetS* addNext(AstFGetS* nodep) { return static_cast<AstFGetS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFGetS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_FGetS(...) AstNodeBiop(VNType::FGetS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFOpen \
    AstFOpen* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFOpen*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFOpen* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFOpen*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFOpen* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFOpen*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFOpen* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFOpen*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFOpen* clonep() const { return static_cast<AstFOpen*>(AstNode::clonep()); } \
    AstFOpen* addNext(AstFOpen* nodep) { return static_cast<AstFOpen*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFOpen(*this); } \
    AstNodeExpr* filenamep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void filenamep(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* modep() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void modep(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_FOpen(...) AstNodeExpr(VNType::FOpen, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFOpenMcd \
    AstFOpenMcd* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFOpenMcd*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFOpenMcd* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFOpenMcd*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFOpenMcd* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFOpenMcd*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFOpenMcd* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFOpenMcd*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFOpenMcd* clonep() const { return static_cast<AstFOpenMcd*>(AstNode::clonep()); } \
    AstFOpenMcd* addNext(AstFOpenMcd* nodep) { return static_cast<AstFOpenMcd*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFOpenMcd(*this); } \
    AstNodeExpr* filenamep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void filenamep(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_FOpenMcd(...) AstNodeExpr(VNType::FOpenMcd, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFRead \
    AstFRead* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFRead*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFRead* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFRead*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFRead* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFRead*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFRead* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFRead*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFRead* clonep() const { return static_cast<AstFRead*>(AstNode::clonep()); } \
    AstFRead* addNext(AstFRead* nodep) { return static_cast<AstFRead*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFRead(*this); } \
    AstNode* memp() const VL_MT_STABLE { return op1p(); } \
    void memp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* filep() const VL_MT_STABLE { return op2p(); } \
    void filep(AstNode* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* startp() const VL_MT_STABLE { return op3p(); } \
    void startp(AstNode* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* countp() const VL_MT_STABLE { return op4p(); } \
    void countp(AstNode* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_FRead(...) AstNodeExpr(VNType::FRead, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFRewind \
    AstFRewind* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFRewind*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFRewind* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFRewind*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFRewind* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFRewind*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFRewind* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFRewind*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFRewind* clonep() const { return static_cast<AstFRewind*>(AstNode::clonep()); } \
    AstFRewind* addNext(AstFRewind* nodep) { return static_cast<AstFRewind*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFRewind(*this); } \
    AstNode* filep() const VL_MT_STABLE { return op1p(); } \
    void filep(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_FRewind(...) AstNodeExpr(VNType::FRewind, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFScanF \
    AstFScanF* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFScanF*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFScanF* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFScanF*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFScanF* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFScanF*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFScanF* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFScanF*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFScanF* clonep() const { return static_cast<AstFScanF*>(AstNode::clonep()); } \
    AstFScanF* addNext(AstFScanF* nodep) { return static_cast<AstFScanF*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFScanF(*this); } \
    AstNode* exprsp() const VL_MT_STABLE { return op1p(); } \
    void addExprsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* filep() const VL_MT_STABLE { return op2p(); } \
    void filep(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_FScanF(...) AstNodeExpr(VNType::FScanF, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFSeek \
    AstFSeek* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFSeek*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFSeek* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFSeek*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFSeek* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFSeek*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFSeek* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFSeek*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFSeek* clonep() const { return static_cast<AstFSeek*>(AstNode::clonep()); } \
    AstFSeek* addNext(AstFSeek* nodep) { return static_cast<AstFSeek*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFSeek(*this); } \
    AstNode* filep() const VL_MT_STABLE { return op1p(); } \
    void filep(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* offset() const VL_MT_STABLE { return op2p(); } \
    void offset(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* operation() const VL_MT_STABLE { return op3p(); } \
    void operation(AstNode* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_FSeek(...) AstNodeExpr(VNType::FSeek, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFTell \
    AstFTell* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFTell*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFTell* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFTell*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFTell* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFTell*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFTell* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFTell*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFTell* clonep() const { return static_cast<AstFTell*>(AstNode::clonep()); } \
    AstFTell* addNext(AstFTell* nodep) { return static_cast<AstFTell*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFTell(*this); } \
    AstNode* filep() const VL_MT_STABLE { return op1p(); } \
    void filep(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_FTell(...) AstNodeExpr(VNType::FTell, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFUngetC \
    AstFUngetC* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFUngetC*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFUngetC* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFUngetC*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFUngetC* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFUngetC*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFUngetC* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFUngetC*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFUngetC* clonep() const { return static_cast<AstFUngetC*>(AstNode::clonep()); } \
    AstFUngetC* addNext(AstFUngetC* nodep) { return static_cast<AstFUngetC*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFUngetC(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_FUngetC(...) AstNodeBiop(VNType::FUngetC, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFalling \
    AstFalling* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFalling*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFalling* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFalling*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFalling* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFalling*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFalling* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFalling*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFalling* clonep() const { return static_cast<AstFalling*>(AstNode::clonep()); } \
    AstFalling* addNext(AstFalling* nodep) { return static_cast<AstFalling*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFalling(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Falling(...) AstNodeExpr(VNType::Falling, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFell \
    AstFell* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFell*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFell* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFell*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFell* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFell*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFell* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFell*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFell* clonep() const { return static_cast<AstFell*>(AstNode::clonep()); } \
    AstFell* addNext(AstFell* nodep) { return static_cast<AstFell*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFell(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Fell(...) AstNodeExpr(VNType::Fell, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFinal \
    AstFinal* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFinal*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFinal* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFinal*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFinal* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFinal*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFinal* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFinal*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFinal* clonep() const { return static_cast<AstFinal*>(AstNode::clonep()); } \
    AstFinal* addNext(AstFinal* nodep) { return static_cast<AstFinal*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFinal(*this); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeProcedure::stmtsp; \
    using AstNodeProcedure::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Final(...) AstNodeProcedure(VNType::Final, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFinish \
    AstFinish* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFinish*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFinish* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFinish*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFinish* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFinish*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFinish* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFinish*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFinish* clonep() const { return static_cast<AstFinish*>(AstNode::clonep()); } \
    AstFinish* addNext(AstFinish* nodep) { return static_cast<AstFinish*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFinish(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Finish(...) AstNodeStmt(VNType::Finish, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFinishFork \
    AstFinishFork* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFinishFork*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFinishFork* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFinishFork*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFinishFork* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFinishFork*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFinishFork* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFinishFork*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFinishFork* clonep() const { return static_cast<AstFinishFork*>(AstNode::clonep()); } \
    AstFinishFork* addNext(AstFinishFork* nodep) { return static_cast<AstFinishFork*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFinishFork(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_FinishFork(...) AstNodeStmt(VNType::FinishFork, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFireEvent \
    AstFireEvent* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFireEvent*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFireEvent* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFireEvent*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFireEvent* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFireEvent*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFireEvent* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFireEvent*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFireEvent* clonep() const { return static_cast<AstFireEvent*>(AstNode::clonep()); } \
    AstFireEvent* addNext(AstFireEvent* nodep) { return static_cast<AstFireEvent*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFireEvent(*this); } \
    AstNodeExpr* operandp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void operandp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_FireEvent(...) AstNodeStmt(VNType::FireEvent, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFloorD \
    AstFloorD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFloorD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFloorD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFloorD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFloorD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFloorD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFloorD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFloorD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFloorD* clonep() const { return static_cast<AstFloorD*>(AstNode::clonep()); } \
    AstFloorD* addNext(AstFloorD* nodep) { return static_cast<AstFloorD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFloorD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_FloorD(...) AstNodeSystemUniopD(VNType::FloorD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstForeach \
    AstForeach* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstForeach*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstForeach* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstForeach*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstForeach* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstForeach*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstForeach* cloneTreePure(bool cloneNext) { \
        return static_cast<AstForeach*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstForeach* clonep() const { return static_cast<AstForeach*>(AstNode::clonep()); } \
    AstForeach* addNext(AstForeach* nodep) { return static_cast<AstForeach*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstForeach(*this); } \
    AstNode* arrayp() const VL_MT_STABLE { return op1p(); } \
    void arrayp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeForeach::arrayp; \
    using AstNodeForeach::stmtsp; \
    using AstNodeForeach::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Foreach(...) AstNodeForeach(VNType::Foreach, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFork \
    AstFork* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFork*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFork* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFork*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFork* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFork*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFork* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFork*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFork* clonep() const { return static_cast<AstFork*>(AstNode::clonep()); } \
    AstFork* addNext(AstFork* nodep) { return static_cast<AstFork*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFork(*this); } \
    AstNode* declsp() const VL_MT_STABLE { return op1p(); } \
    void addDeclsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstBegin* forksp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), Begin); } \
    void addForksp(AstBegin* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstVarRef* parentProcessp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), VarRef); } \
    void parentProcessp(AstVarRef* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBlock::declsp; \
    using AstNodeBlock::addDeclsp; \
    using AstNodeBlock::stmtsp; \
    using AstNodeBlock::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Fork(...) AstNodeBlock(VNType::Fork, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFunc \
    AstFunc* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFunc*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFunc* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFunc*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFunc* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFunc*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFunc* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFunc*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFunc* clonep() const { return static_cast<AstFunc*>(AstNode::clonep()); } \
    AstFunc* addNext(AstFunc* nodep) { return static_cast<AstFunc*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFunc(*this); } \
    AstNode* fvarp() const VL_MT_STABLE { return op1p(); } \
    void fvarp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* classOrPackagep() const VL_MT_STABLE { return op2p(); } \
    void classOrPackagep(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op3p(); } \
    void addStmtsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScopeName* scopeNamep() const VL_MT_STABLE { return VN_DBG_AS(op4p(), ScopeName); } \
    void scopeNamep(AstScopeName* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeFTask::fvarp; \
    using AstNodeFTask::classOrPackagep; \
    using AstNodeFTask::stmtsp; \
    using AstNodeFTask::addStmtsp; \
    using AstNodeFTask::scopeNamep; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Func(...) AstNodeFTask(VNType::Func, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFuncRef \
    AstFuncRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFuncRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFuncRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFuncRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFuncRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFuncRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFuncRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFuncRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFuncRef* clonep() const { return static_cast<AstFuncRef*>(AstNode::clonep()); } \
    AstFuncRef* addNext(AstFuncRef* nodep) { return static_cast<AstFuncRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFuncRef(*this); } \
    AstNode* namep() const VL_MT_STABLE { return op1p(); } \
    void namep(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* pinsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void addPinsp(AstNodeExpr* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScopeName* scopeNamep() const VL_MT_STABLE { return VN_DBG_AS(op4p(), ScopeName); } \
    void scopeNamep(AstScopeName* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeFTaskRef::namep; \
    using AstNodeFTaskRef::pinsp; \
    using AstNodeFTaskRef::addPinsp; \
    using AstNodeFTaskRef::scopeNamep; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_FuncRef(...) AstNodeFTaskRef(VNType::FuncRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstFuture \
    AstFuture* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFuture*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstFuture* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstFuture*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstFuture* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstFuture*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstFuture* cloneTreePure(bool cloneNext) { \
        return static_cast<AstFuture*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstFuture* clonep() const { return static_cast<AstFuture*>(AstNode::clonep()); } \
    AstFuture* addNext(AstFuture* nodep) { return static_cast<AstFuture*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstFuture(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Future(...) AstNodeExpr(VNType::Future, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGatePin \
    AstGatePin* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGatePin*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGatePin* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGatePin*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGatePin* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGatePin*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGatePin* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGatePin*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGatePin* clonep() const { return static_cast<AstGatePin*>(AstNode::clonep()); } \
    AstGatePin* addNext(AstGatePin* nodep) { return static_cast<AstGatePin*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGatePin(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstRange* rangep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), Range); } \
    void rangep(AstRange* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_GatePin(...) AstNodeExpr(VNType::GatePin, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGenBlock \
    AstGenBlock* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGenBlock*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGenBlock* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGenBlock*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGenBlock* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGenBlock*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGenBlock* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGenBlock*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGenBlock* clonep() const { return static_cast<AstGenBlock*>(AstNode::clonep()); } \
    AstGenBlock* addNext(AstGenBlock* nodep) { return static_cast<AstGenBlock*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGenBlock(*this); } \
    AstNode* genforp() const VL_MT_STABLE { return op1p(); } \
    void genforp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* itemsp() const VL_MT_STABLE { return op2p(); } \
    void addItemsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_GenBlock(...) AstNodeGen(VNType::GenBlock, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGenCase \
    AstGenCase* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGenCase*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGenCase* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGenCase*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGenCase* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGenCase*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGenCase* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGenCase*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGenCase* clonep() const { return static_cast<AstGenCase*>(AstNode::clonep()); } \
    AstGenCase* addNext(AstGenCase* nodep) { return static_cast<AstGenCase*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGenCase(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstGenCaseItem* itemsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), GenCaseItem); } \
    void addItemsp(AstGenCaseItem* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_GenCase(...) AstNodeGen(VNType::GenCase, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGenCaseItem \
    AstGenCaseItem* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGenCaseItem*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGenCaseItem* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGenCaseItem*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGenCaseItem* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGenCaseItem*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGenCaseItem* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGenCaseItem*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGenCaseItem* clonep() const { return static_cast<AstGenCaseItem*>(AstNode::clonep()); } \
    AstGenCaseItem* addNext(AstGenCaseItem* nodep) { return static_cast<AstGenCaseItem*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGenCaseItem(*this); } \
    AstNodeExpr* condsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void addCondsp(AstNodeExpr* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* itemsp() const VL_MT_STABLE { return op2p(); } \
    void addItemsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_GenCaseItem(...) AstNode(VNType::GenCaseItem, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGenFor \
    AstGenFor* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGenFor*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGenFor* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGenFor*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGenFor* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGenFor*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGenFor* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGenFor*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGenFor* clonep() const { return static_cast<AstGenFor*>(AstNode::clonep()); } \
    AstGenFor* addNext(AstGenFor* nodep) { return static_cast<AstGenFor*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGenFor(*this); } \
    AstNode* initsp() const VL_MT_STABLE { return op1p(); } \
    void addInitsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* condp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void condp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* incsp() const VL_MT_STABLE { return op3p(); } \
    void addIncsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* itemsp() const VL_MT_STABLE { return op4p(); } \
    void addItemsp(AstNode* nodep) { addNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_GenFor(...) AstNodeGen(VNType::GenFor, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGenIf \
    AstGenIf* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGenIf*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGenIf* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGenIf*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGenIf* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGenIf*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGenIf* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGenIf*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGenIf* clonep() const { return static_cast<AstGenIf*>(AstNode::clonep()); } \
    AstGenIf* addNext(AstGenIf* nodep) { return static_cast<AstGenIf*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGenIf(*this); } \
    AstNodeExpr* condp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void condp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* thensp() const VL_MT_STABLE { return op2p(); } \
    void addThensp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* elsesp() const VL_MT_STABLE { return op3p(); } \
    void addElsesp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_GenIf(...) AstNodeGen(VNType::GenIf, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGetcN \
    AstGetcN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGetcN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGetcN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGetcN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGetcN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGetcN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGetcN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGetcN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGetcN* clonep() const { return static_cast<AstGetcN*>(AstNode::clonep()); } \
    AstGetcN* addNext(AstGetcN* nodep) { return static_cast<AstGetcN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGetcN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_GetcN(...) AstNodeBiop(VNType::GetcN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGetcRefN \
    AstGetcRefN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGetcRefN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGetcRefN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGetcRefN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGetcRefN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGetcRefN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGetcRefN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGetcRefN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGetcRefN* clonep() const { return static_cast<AstGetcRefN*>(AstNode::clonep()); } \
    AstGetcRefN* addNext(AstGetcRefN* nodep) { return static_cast<AstGetcRefN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGetcRefN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_GetcRefN(...) AstNodeBiop(VNType::GetcRefN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGt \
    AstGt* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGt*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGt* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGt*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGt* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGt*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGt* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGt*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGt* clonep() const { return static_cast<AstGt*>(AstNode::clonep()); } \
    AstGt* addNext(AstGt* nodep) { return static_cast<AstGt*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGt(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Gt(...) AstNodeBiop(VNType::Gt, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGtD \
    AstGtD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGtD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGtD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGtD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGtD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGtD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGtD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGtD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGtD* clonep() const { return static_cast<AstGtD*>(AstNode::clonep()); } \
    AstGtD* addNext(AstGtD* nodep) { return static_cast<AstGtD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGtD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_GtD(...) AstNodeBiop(VNType::GtD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGtN \
    AstGtN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGtN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGtN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGtN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGtN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGtN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGtN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGtN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGtN* clonep() const { return static_cast<AstGtN*>(AstNode::clonep()); } \
    AstGtN* addNext(AstGtN* nodep) { return static_cast<AstGtN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGtN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_GtN(...) AstNodeBiop(VNType::GtN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGtS \
    AstGtS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGtS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGtS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGtS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGtS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGtS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGtS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGtS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGtS* clonep() const { return static_cast<AstGtS*>(AstNode::clonep()); } \
    AstGtS* addNext(AstGtS* nodep) { return static_cast<AstGtS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGtS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_GtS(...) AstNodeBiop(VNType::GtS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGte \
    AstGte* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGte*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGte* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGte*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGte* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGte*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGte* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGte*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGte* clonep() const { return static_cast<AstGte*>(AstNode::clonep()); } \
    AstGte* addNext(AstGte* nodep) { return static_cast<AstGte*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGte(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Gte(...) AstNodeBiop(VNType::Gte, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGteD \
    AstGteD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGteD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGteD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGteD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGteD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGteD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGteD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGteD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGteD* clonep() const { return static_cast<AstGteD*>(AstNode::clonep()); } \
    AstGteD* addNext(AstGteD* nodep) { return static_cast<AstGteD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGteD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_GteD(...) AstNodeBiop(VNType::GteD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGteN \
    AstGteN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGteN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGteN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGteN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGteN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGteN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGteN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGteN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGteN* clonep() const { return static_cast<AstGteN*>(AstNode::clonep()); } \
    AstGteN* addNext(AstGteN* nodep) { return static_cast<AstGteN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGteN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_GteN(...) AstNodeBiop(VNType::GteN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstGteS \
    AstGteS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGteS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstGteS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstGteS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstGteS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstGteS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstGteS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstGteS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstGteS* clonep() const { return static_cast<AstGteS*>(AstNode::clonep()); } \
    AstGteS* addNext(AstGteS* nodep) { return static_cast<AstGteS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstGteS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_GteS(...) AstNodeBiop(VNType::GteS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstHypotD \
    AstHypotD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstHypotD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstHypotD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstHypotD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstHypotD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstHypotD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstHypotD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstHypotD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstHypotD* clonep() const { return static_cast<AstHypotD*>(AstNode::clonep()); } \
    AstHypotD* addNext(AstHypotD* nodep) { return static_cast<AstHypotD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstHypotD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemBiopD::lhsp; \
    using AstNodeSystemBiopD::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_HypotD(...) AstNodeSystemBiopD(VNType::HypotD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstISToRD \
    AstISToRD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstISToRD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstISToRD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstISToRD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstISToRD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstISToRD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstISToRD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstISToRD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstISToRD* clonep() const { return static_cast<AstISToRD*>(AstNode::clonep()); } \
    AstISToRD* addNext(AstISToRD* nodep) { return static_cast<AstISToRD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstISToRD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ISToRD(...) AstNodeUniop(VNType::ISToRD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstIToRD \
    AstIToRD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIToRD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstIToRD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIToRD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstIToRD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstIToRD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstIToRD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstIToRD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstIToRD* clonep() const { return static_cast<AstIToRD*>(AstNode::clonep()); } \
    AstIToRD* addNext(AstIToRD* nodep) { return static_cast<AstIToRD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstIToRD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_IToRD(...) AstNodeUniop(VNType::IToRD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstIf \
    AstIf* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIf*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstIf* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIf*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstIf* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstIf*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstIf* cloneTreePure(bool cloneNext) { \
        return static_cast<AstIf*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstIf* clonep() const { return static_cast<AstIf*>(AstNode::clonep()); } \
    AstIf* addNext(AstIf* nodep) { return static_cast<AstIf*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstIf(*this); } \
    AstNodeExpr* condp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void condp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* thensp() const VL_MT_STABLE { return op2p(); } \
    void addThensp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* elsesp() const VL_MT_STABLE { return op3p(); } \
    void addElsesp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeIf::condp; \
    using AstNodeIf::thensp; \
    using AstNodeIf::addThensp; \
    using AstNodeIf::elsesp; \
    using AstNodeIf::addElsesp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_If(...) AstNodeIf(VNType::If, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstIface \
    AstIface* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIface*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstIface* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIface*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstIface* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstIface*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstIface* cloneTreePure(bool cloneNext) { \
        return static_cast<AstIface*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstIface* clonep() const { return static_cast<AstIface*>(AstNode::clonep()); } \
    AstIface* addNext(AstIface* nodep) { return static_cast<AstIface*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstIface(*this); } \
    AstNode* inlinesp() const VL_MT_STABLE { return op1p(); } \
    void addInlinesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeModule::inlinesp; \
    using AstNodeModule::addInlinesp; \
    using AstNodeModule::stmtsp; \
    using AstNodeModule::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Iface(...) AstNodeModule(VNType::Iface, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstIfaceGenericDType \
    AstIfaceGenericDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIfaceGenericDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstIfaceGenericDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIfaceGenericDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstIfaceGenericDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstIfaceGenericDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstIfaceGenericDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstIfaceGenericDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstIfaceGenericDType* clonep() const { return static_cast<AstIfaceGenericDType*>(AstNode::clonep()); } \
    AstIfaceGenericDType* addNext(AstIfaceGenericDType* nodep) { return static_cast<AstIfaceGenericDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstIfaceGenericDType(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_IfaceGenericDType(...) AstNodeDType(VNType::IfaceGenericDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstIfaceRefDType \
private: \
    AstIface* m_ifacep = nullptr;    AstCell* m_cellp = nullptr;    AstModport* m_modportp = nullptr;public: \
    AstIfaceRefDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIfaceRefDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstIfaceRefDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIfaceRefDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstIfaceRefDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstIfaceRefDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstIfaceRefDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstIfaceRefDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstIfaceRefDType* clonep() const { return static_cast<AstIfaceRefDType*>(AstNode::clonep()); } \
    AstIfaceRefDType* addNext(AstIfaceRefDType* nodep) { return static_cast<AstIfaceRefDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstIfaceRefDType(*this); } \
    AstPin* paramsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), Pin); } \
    void addParamsp(AstPin* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_IfaceRefDType(...) AstNodeDType(VNType::IfaceRefDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstImplication \
    AstImplication* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstImplication*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstImplication* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstImplication*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstImplication* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstImplication*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstImplication* cloneTreePure(bool cloneNext) { \
        return static_cast<AstImplication*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstImplication* clonep() const { return static_cast<AstImplication*>(AstNode::clonep()); } \
    AstImplication* addNext(AstImplication* nodep) { return static_cast<AstImplication*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstImplication(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op3p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Implication(...) AstNodeExpr(VNType::Implication, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstImplicit \
    AstImplicit* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstImplicit*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstImplicit* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstImplicit*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstImplicit* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstImplicit*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstImplicit* cloneTreePure(bool cloneNext) { \
        return static_cast<AstImplicit*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstImplicit* clonep() const { return static_cast<AstImplicit*>(AstNode::clonep()); } \
    AstImplicit* addNext(AstImplicit* nodep) { return static_cast<AstImplicit*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstImplicit(*this); } \
    AstNode* exprsp() const VL_MT_STABLE { return op1p(); } \
    void addExprsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Implicit(...) AstNode(VNType::Implicit, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstInferredDisable \
    AstInferredDisable* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInferredDisable*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstInferredDisable* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInferredDisable*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstInferredDisable* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstInferredDisable*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstInferredDisable* cloneTreePure(bool cloneNext) { \
        return static_cast<AstInferredDisable*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstInferredDisable* clonep() const { return static_cast<AstInferredDisable*>(AstNode::clonep()); } \
    AstInferredDisable* addNext(AstInferredDisable* nodep) { return static_cast<AstInferredDisable*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstInferredDisable(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_InferredDisable(...) AstNodeTermop(VNType::InferredDisable, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstInitArray \
    AstInitArray* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInitArray*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstInitArray* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInitArray*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstInitArray* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstInitArray*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstInitArray* cloneTreePure(bool cloneNext) { \
        return static_cast<AstInitArray*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstInitArray* clonep() const { return static_cast<AstInitArray*>(AstNode::clonep()); } \
    AstInitArray* addNext(AstInitArray* nodep) { return static_cast<AstInitArray*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstInitArray(*this); } \
    AstNodeExpr* defaultp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void defaultp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* initsp() const VL_MT_STABLE { return op2p(); } \
    void addInitsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_InitArray(...) AstNodeExpr(VNType::InitArray, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstInitItem \
    AstInitItem* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInitItem*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstInitItem* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInitItem*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstInitItem* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstInitItem*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstInitItem* cloneTreePure(bool cloneNext) { \
        return static_cast<AstInitItem*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstInitItem* clonep() const { return static_cast<AstInitItem*>(AstNode::clonep()); } \
    AstInitItem* addNext(AstInitItem* nodep) { return static_cast<AstInitItem*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstInitItem(*this); } \
    AstNodeExpr* valuep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void valuep(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_InitItem(...) AstNode(VNType::InitItem, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstInitial \
    AstInitial* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInitial*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstInitial* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInitial*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstInitial* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstInitial*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstInitial* cloneTreePure(bool cloneNext) { \
        return static_cast<AstInitial*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstInitial* clonep() const { return static_cast<AstInitial*>(AstNode::clonep()); } \
    AstInitial* addNext(AstInitial* nodep) { return static_cast<AstInitial*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstInitial(*this); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeProcedure::stmtsp; \
    using AstNodeProcedure::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Initial(...) AstNodeProcedure(VNType::Initial, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstInitialAutomatic \
    AstInitialAutomatic* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInitialAutomatic*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstInitialAutomatic* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInitialAutomatic*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstInitialAutomatic* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstInitialAutomatic*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstInitialAutomatic* cloneTreePure(bool cloneNext) { \
        return static_cast<AstInitialAutomatic*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstInitialAutomatic* clonep() const { return static_cast<AstInitialAutomatic*>(AstNode::clonep()); } \
    AstInitialAutomatic* addNext(AstInitialAutomatic* nodep) { return static_cast<AstInitialAutomatic*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstInitialAutomatic(*this); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeProcedure::stmtsp; \
    using AstNodeProcedure::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_InitialAutomatic(...) AstNodeProcedure(VNType::InitialAutomatic, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstInitialStatic \
    AstInitialStatic* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInitialStatic*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstInitialStatic* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInitialStatic*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstInitialStatic* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstInitialStatic*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstInitialStatic* cloneTreePure(bool cloneNext) { \
        return static_cast<AstInitialStatic*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstInitialStatic* clonep() const { return static_cast<AstInitialStatic*>(AstNode::clonep()); } \
    AstInitialStatic* addNext(AstInitialStatic* nodep) { return static_cast<AstInitialStatic*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstInitialStatic(*this); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeProcedure::stmtsp; \
    using AstNodeProcedure::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_InitialStatic(...) AstNodeProcedure(VNType::InitialStatic, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstInside \
    AstInside* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInside*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstInside* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInside*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstInside* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstInside*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstInside* cloneTreePure(bool cloneNext) { \
        return static_cast<AstInside*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstInside* clonep() const { return static_cast<AstInside*>(AstNode::clonep()); } \
    AstInside* addNext(AstInside* nodep) { return static_cast<AstInside*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstInside(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* itemsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void addItemsp(AstNodeExpr* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Inside(...) AstNodeExpr(VNType::Inside, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstInsideRange \
    AstInsideRange* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInsideRange*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstInsideRange* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstInsideRange*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstInsideRange* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstInsideRange*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstInsideRange* cloneTreePure(bool cloneNext) { \
        return static_cast<AstInsideRange*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstInsideRange* clonep() const { return static_cast<AstInsideRange*>(AstNode::clonep()); } \
    AstInsideRange* addNext(AstInsideRange* nodep) { return static_cast<AstInsideRange*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstInsideRange(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_InsideRange(...) AstNodeExpr(VNType::InsideRange, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstIntfRef \
    AstIntfRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIntfRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstIntfRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIntfRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstIntfRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstIntfRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstIntfRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstIntfRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstIntfRef* clonep() const { return static_cast<AstIntfRef*>(AstNode::clonep()); } \
    AstIntfRef* addNext(AstIntfRef* nodep) { return static_cast<AstIntfRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstIntfRef(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_IntfRef(...) AstNode(VNType::IntfRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstIsUnbounded \
    AstIsUnbounded* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIsUnbounded*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstIsUnbounded* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIsUnbounded*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstIsUnbounded* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstIsUnbounded*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstIsUnbounded* cloneTreePure(bool cloneNext) { \
        return static_cast<AstIsUnbounded*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstIsUnbounded* clonep() const { return static_cast<AstIsUnbounded*>(AstNode::clonep()); } \
    AstIsUnbounded* addNext(AstIsUnbounded* nodep) { return static_cast<AstIsUnbounded*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstIsUnbounded(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_IsUnbounded(...) AstNodeUniop(VNType::IsUnbounded, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstIsUnknown \
    AstIsUnknown* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIsUnknown*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstIsUnknown* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstIsUnknown*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstIsUnknown* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstIsUnknown*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstIsUnknown* cloneTreePure(bool cloneNext) { \
        return static_cast<AstIsUnknown*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstIsUnknown* clonep() const { return static_cast<AstIsUnknown*>(AstNode::clonep()); } \
    AstIsUnknown* addNext(AstIsUnknown* nodep) { return static_cast<AstIsUnknown*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstIsUnknown(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_IsUnknown(...) AstNodeUniop(VNType::IsUnknown, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstJumpBlock \
    AstJumpBlock* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstJumpBlock*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstJumpBlock* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstJumpBlock*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstJumpBlock* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstJumpBlock*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstJumpBlock* cloneTreePure(bool cloneNext) { \
        return static_cast<AstJumpBlock*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstJumpBlock* clonep() const { return static_cast<AstJumpBlock*>(AstNode::clonep()); } \
    AstJumpBlock* addNext(AstJumpBlock* nodep) { return static_cast<AstJumpBlock*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstJumpBlock(*this); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op1p(); } \
    void addStmtsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_JumpBlock(...) AstNodeStmt(VNType::JumpBlock, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstJumpGo \
private: \
    AstJumpBlock* m_blockp = nullptr;public: \
    AstJumpGo* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstJumpGo*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstJumpGo* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstJumpGo*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstJumpGo* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstJumpGo*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstJumpGo* cloneTreePure(bool cloneNext) { \
        return static_cast<AstJumpGo*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstJumpGo* clonep() const { return static_cast<AstJumpGo*>(AstNode::clonep()); } \
    AstJumpGo* addNext(AstJumpGo* nodep) { return static_cast<AstJumpGo*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstJumpGo(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_JumpGo(...) AstNodeStmt(VNType::JumpGo, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLambdaArgRef \
    AstLambdaArgRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLambdaArgRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLambdaArgRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLambdaArgRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLambdaArgRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLambdaArgRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLambdaArgRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLambdaArgRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLambdaArgRef* clonep() const { return static_cast<AstLambdaArgRef*>(AstNode::clonep()); } \
    AstLambdaArgRef* addNext(AstLambdaArgRef* nodep) { return static_cast<AstLambdaArgRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLambdaArgRef(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_LambdaArgRef(...) AstNodeExpr(VNType::LambdaArgRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLenN \
    AstLenN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLenN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLenN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLenN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLenN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLenN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLenN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLenN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLenN* clonep() const { return static_cast<AstLenN*>(AstNode::clonep()); } \
    AstLenN* addNext(AstLenN* nodep) { return static_cast<AstLenN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLenN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LenN(...) AstNodeUniop(VNType::LenN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLet \
    AstLet* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLet*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLet* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLet*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLet* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLet*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLet* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLet*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLet* clonep() const { return static_cast<AstLet*>(AstNode::clonep()); } \
    AstLet* addNext(AstLet* nodep) { return static_cast<AstLet*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLet(*this); } \
    AstNode* fvarp() const VL_MT_STABLE { return op1p(); } \
    void fvarp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* classOrPackagep() const VL_MT_STABLE { return op2p(); } \
    void classOrPackagep(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op3p(); } \
    void addStmtsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScopeName* scopeNamep() const VL_MT_STABLE { return VN_DBG_AS(op4p(), ScopeName); } \
    void scopeNamep(AstScopeName* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeFTask::fvarp; \
    using AstNodeFTask::classOrPackagep; \
    using AstNodeFTask::stmtsp; \
    using AstNodeFTask::addStmtsp; \
    using AstNodeFTask::scopeNamep; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Let(...) AstNodeFTask(VNType::Let, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLibrary \
    AstLibrary* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLibrary*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLibrary* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLibrary*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLibrary* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLibrary*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLibrary* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLibrary*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLibrary* clonep() const { return static_cast<AstLibrary*>(AstNode::clonep()); } \
    AstLibrary* addNext(AstLibrary* nodep) { return static_cast<AstLibrary*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLibrary(*this); } \
    AstNodeExpr* filesp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void addFilesp(AstNodeExpr* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* incdirsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void addIncdirsp(AstNodeExpr* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Library(...) AstNode(VNType::Library, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLog10D \
    AstLog10D* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLog10D*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLog10D* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLog10D*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLog10D* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLog10D*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLog10D* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLog10D*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLog10D* clonep() const { return static_cast<AstLog10D*>(AstNode::clonep()); } \
    AstLog10D* addNext(AstLog10D* nodep) { return static_cast<AstLog10D*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLog10D(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Log10D(...) AstNodeSystemUniopD(VNType::Log10D, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLogAnd \
    AstLogAnd* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLogAnd*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLogAnd* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLogAnd*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLogAnd* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLogAnd*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLogAnd* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLogAnd*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLogAnd* clonep() const { return static_cast<AstLogAnd*>(AstNode::clonep()); } \
    AstLogAnd* addNext(AstLogAnd* nodep) { return static_cast<AstLogAnd*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLogAnd(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LogAnd(...) AstNodeBiop(VNType::LogAnd, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLogD \
    AstLogD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLogD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLogD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLogD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLogD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLogD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLogD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLogD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLogD* clonep() const { return static_cast<AstLogD*>(AstNode::clonep()); } \
    AstLogD* addNext(AstLogD* nodep) { return static_cast<AstLogD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLogD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LogD(...) AstNodeSystemUniopD(VNType::LogD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLogEq \
    AstLogEq* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLogEq*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLogEq* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLogEq*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLogEq* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLogEq*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLogEq* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLogEq*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLogEq* clonep() const { return static_cast<AstLogEq*>(AstNode::clonep()); } \
    AstLogEq* addNext(AstLogEq* nodep) { return static_cast<AstLogEq*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLogEq(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiCom::lhsp; \
    using AstNodeBiCom::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LogEq(...) AstNodeBiCom(VNType::LogEq, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLogIf \
    AstLogIf* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLogIf*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLogIf* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLogIf*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLogIf* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLogIf*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLogIf* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLogIf*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLogIf* clonep() const { return static_cast<AstLogIf*>(AstNode::clonep()); } \
    AstLogIf* addNext(AstLogIf* nodep) { return static_cast<AstLogIf*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLogIf(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LogIf(...) AstNodeBiop(VNType::LogIf, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLogNot \
    AstLogNot* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLogNot*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLogNot* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLogNot*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLogNot* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLogNot*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLogNot* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLogNot*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLogNot* clonep() const { return static_cast<AstLogNot*>(AstNode::clonep()); } \
    AstLogNot* addNext(AstLogNot* nodep) { return static_cast<AstLogNot*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLogNot(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LogNot(...) AstNodeUniop(VNType::LogNot, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLogOr \
    AstLogOr* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLogOr*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLogOr* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLogOr*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLogOr* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLogOr*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLogOr* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLogOr*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLogOr* clonep() const { return static_cast<AstLogOr*>(AstNode::clonep()); } \
    AstLogOr* addNext(AstLogOr* nodep) { return static_cast<AstLogOr*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLogOr(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LogOr(...) AstNodeBiop(VNType::LogOr, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLoop \
    AstLoop* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLoop*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLoop* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLoop*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLoop* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLoop*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLoop* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLoop*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLoop* clonep() const { return static_cast<AstLoop*>(AstNode::clonep()); } \
    AstLoop* addNext(AstLoop* nodep) { return static_cast<AstLoop*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLoop(*this); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op1p(); } \
    void addStmtsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* contsp() const VL_MT_STABLE { return op2p(); } \
    void addContsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Loop(...) AstNodeStmt(VNType::Loop, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLoopTest \
private: \
    AstLoop* m_loopp = nullptr;public: \
    AstLoopTest* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLoopTest*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLoopTest* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLoopTest*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLoopTest* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLoopTest*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLoopTest* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLoopTest*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLoopTest* clonep() const { return static_cast<AstLoopTest*>(AstNode::clonep()); } \
    AstLoopTest* addNext(AstLoopTest* nodep) { return static_cast<AstLoopTest*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLoopTest(*this); } \
    AstNodeExpr* condp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void condp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_LoopTest(...) AstNodeStmt(VNType::LoopTest, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLt \
    AstLt* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLt*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLt* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLt*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLt* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLt*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLt* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLt*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLt* clonep() const { return static_cast<AstLt*>(AstNode::clonep()); } \
    AstLt* addNext(AstLt* nodep) { return static_cast<AstLt*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLt(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Lt(...) AstNodeBiop(VNType::Lt, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLtD \
    AstLtD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLtD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLtD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLtD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLtD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLtD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLtD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLtD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLtD* clonep() const { return static_cast<AstLtD*>(AstNode::clonep()); } \
    AstLtD* addNext(AstLtD* nodep) { return static_cast<AstLtD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLtD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LtD(...) AstNodeBiop(VNType::LtD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLtN \
    AstLtN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLtN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLtN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLtN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLtN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLtN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLtN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLtN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLtN* clonep() const { return static_cast<AstLtN*>(AstNode::clonep()); } \
    AstLtN* addNext(AstLtN* nodep) { return static_cast<AstLtN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLtN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LtN(...) AstNodeBiop(VNType::LtN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLtS \
    AstLtS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLtS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLtS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLtS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLtS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLtS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLtS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLtS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLtS* clonep() const { return static_cast<AstLtS*>(AstNode::clonep()); } \
    AstLtS* addNext(AstLtS* nodep) { return static_cast<AstLtS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLtS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LtS(...) AstNodeBiop(VNType::LtS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLte \
    AstLte* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLte*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLte* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLte*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLte* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLte*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLte* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLte*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLte* clonep() const { return static_cast<AstLte*>(AstNode::clonep()); } \
    AstLte* addNext(AstLte* nodep) { return static_cast<AstLte*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLte(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Lte(...) AstNodeBiop(VNType::Lte, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLteD \
    AstLteD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLteD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLteD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLteD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLteD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLteD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLteD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLteD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLteD* clonep() const { return static_cast<AstLteD*>(AstNode::clonep()); } \
    AstLteD* addNext(AstLteD* nodep) { return static_cast<AstLteD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLteD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LteD(...) AstNodeBiop(VNType::LteD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLteN \
    AstLteN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLteN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLteN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLteN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLteN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLteN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLteN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLteN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLteN* clonep() const { return static_cast<AstLteN*>(AstNode::clonep()); } \
    AstLteN* addNext(AstLteN* nodep) { return static_cast<AstLteN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLteN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LteN(...) AstNodeBiop(VNType::LteN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstLteS \
    AstLteS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLteS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstLteS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstLteS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstLteS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstLteS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstLteS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstLteS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstLteS* clonep() const { return static_cast<AstLteS*>(AstNode::clonep()); } \
    AstLteS* addNext(AstLteS* nodep) { return static_cast<AstLteS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstLteS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_LteS(...) AstNodeBiop(VNType::LteS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstMemberDType \
private: \
    AstNodeDType* m_refDTypep = nullptr;public: \
    AstMemberDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMemberDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstMemberDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMemberDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstMemberDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstMemberDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstMemberDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstMemberDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstMemberDType* clonep() const { return static_cast<AstMemberDType*>(AstNode::clonep()); } \
    AstMemberDType* addNext(AstMemberDType* nodep) { return static_cast<AstMemberDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstMemberDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* valuep() const VL_MT_STABLE { return op3p(); } \
    void valuep(AstNode* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_MemberDType(...) AstNodeDType(VNType::MemberDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstMemberSel \
private: \
    AstVar* m_varp = nullptr;public: \
    AstMemberSel* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMemberSel*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstMemberSel* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMemberSel*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstMemberSel* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstMemberSel*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstMemberSel* cloneTreePure(bool cloneNext) { \
        return static_cast<AstMemberSel*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstMemberSel* clonep() const { return static_cast<AstMemberSel*>(AstNode::clonep()); } \
    AstMemberSel* addNext(AstMemberSel* nodep) { return static_cast<AstMemberSel*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstMemberSel(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_MemberSel(...) AstNodeExpr(VNType::MemberSel, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstMethodCall \
    AstMethodCall* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMethodCall*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstMethodCall* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMethodCall*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstMethodCall* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstMethodCall*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstMethodCall* cloneTreePure(bool cloneNext) { \
        return static_cast<AstMethodCall*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstMethodCall* clonep() const { return static_cast<AstMethodCall*>(AstNode::clonep()); } \
    AstMethodCall* addNext(AstMethodCall* nodep) { return static_cast<AstMethodCall*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstMethodCall(*this); } \
    AstNode* namep() const VL_MT_STABLE { return op1p(); } \
    void namep(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* pinsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void addPinsp(AstNodeExpr* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScopeName* scopeNamep() const VL_MT_STABLE { return VN_DBG_AS(op4p(), ScopeName); } \
    void scopeNamep(AstScopeName* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeFTaskRef::namep; \
    using AstNodeFTaskRef::pinsp; \
    using AstNodeFTaskRef::addPinsp; \
    using AstNodeFTaskRef::scopeNamep; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_MethodCall(...) AstNodeFTaskRef(VNType::MethodCall, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstModDiv \
    AstModDiv* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModDiv*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstModDiv* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModDiv*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstModDiv* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstModDiv*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstModDiv* cloneTreePure(bool cloneNext) { \
        return static_cast<AstModDiv*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstModDiv* clonep() const { return static_cast<AstModDiv*>(AstNode::clonep()); } \
    AstModDiv* addNext(AstModDiv* nodep) { return static_cast<AstModDiv*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstModDiv(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ModDiv(...) AstNodeBiop(VNType::ModDiv, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstModDivS \
    AstModDivS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModDivS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstModDivS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModDivS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstModDivS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstModDivS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstModDivS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstModDivS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstModDivS* clonep() const { return static_cast<AstModDivS*>(AstNode::clonep()); } \
    AstModDivS* addNext(AstModDivS* nodep) { return static_cast<AstModDivS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstModDivS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ModDivS(...) AstNodeBiop(VNType::ModDivS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstModport \
    AstModport* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModport*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstModport* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModport*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstModport* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstModport*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstModport* cloneTreePure(bool cloneNext) { \
        return static_cast<AstModport*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstModport* clonep() const { return static_cast<AstModport*>(AstNode::clonep()); } \
    AstModport* addNext(AstModport* nodep) { return static_cast<AstModport*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstModport(*this); } \
    AstNode* varsp() const VL_MT_STABLE { return op1p(); } \
    void addVarsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Modport(...) AstNode(VNType::Modport, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstModportClockingRef \
private: \
    AstClocking* m_clockingp = nullptr;public: \
    AstModportClockingRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModportClockingRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstModportClockingRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModportClockingRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstModportClockingRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstModportClockingRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstModportClockingRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstModportClockingRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstModportClockingRef* clonep() const { return static_cast<AstModportClockingRef*>(AstNode::clonep()); } \
    AstModportClockingRef* addNext(AstModportClockingRef* nodep) { return static_cast<AstModportClockingRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstModportClockingRef(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ModportClockingRef(...) AstNode(VNType::ModportClockingRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstModportFTaskRef \
private: \
    AstNodeFTask* m_ftaskp = nullptr;public: \
    AstModportFTaskRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModportFTaskRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstModportFTaskRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModportFTaskRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstModportFTaskRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstModportFTaskRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstModportFTaskRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstModportFTaskRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstModportFTaskRef* clonep() const { return static_cast<AstModportFTaskRef*>(AstNode::clonep()); } \
    AstModportFTaskRef* addNext(AstModportFTaskRef* nodep) { return static_cast<AstModportFTaskRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstModportFTaskRef(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ModportFTaskRef(...) AstNode(VNType::ModportFTaskRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstModportVarRef \
private: \
    AstVar* m_varp = nullptr;public: \
    AstModportVarRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModportVarRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstModportVarRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModportVarRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstModportVarRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstModportVarRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstModportVarRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstModportVarRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstModportVarRef* clonep() const { return static_cast<AstModportVarRef*>(AstNode::clonep()); } \
    AstModportVarRef* addNext(AstModportVarRef* nodep) { return static_cast<AstModportVarRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstModportVarRef(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ModportVarRef(...) AstNode(VNType::ModportVarRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstModule \
    AstModule* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModule*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstModule* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstModule*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstModule* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstModule*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstModule* cloneTreePure(bool cloneNext) { \
        return static_cast<AstModule*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstModule* clonep() const { return static_cast<AstModule*>(AstNode::clonep()); } \
    AstModule* addNext(AstModule* nodep) { return static_cast<AstModule*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstModule(*this); } \
    AstNode* inlinesp() const VL_MT_STABLE { return op1p(); } \
    void addInlinesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeModule::inlinesp; \
    using AstNodeModule::addInlinesp; \
    using AstNodeModule::stmtsp; \
    using AstNodeModule::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Module(...) AstNodeModule(VNType::Module, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstMonitorOff \
    AstMonitorOff* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMonitorOff*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstMonitorOff* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMonitorOff*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstMonitorOff* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstMonitorOff*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstMonitorOff* cloneTreePure(bool cloneNext) { \
        return static_cast<AstMonitorOff*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstMonitorOff* clonep() const { return static_cast<AstMonitorOff*>(AstNode::clonep()); } \
    AstMonitorOff* addNext(AstMonitorOff* nodep) { return static_cast<AstMonitorOff*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstMonitorOff(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_MonitorOff(...) AstNodeStmt(VNType::MonitorOff, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstMul \
    AstMul* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMul*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstMul* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMul*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstMul* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstMul*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstMul* cloneTreePure(bool cloneNext) { \
        return static_cast<AstMul*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstMul* clonep() const { return static_cast<AstMul*>(AstNode::clonep()); } \
    AstMul* addNext(AstMul* nodep) { return static_cast<AstMul*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstMul(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiComAsv::lhsp; \
    using AstNodeBiComAsv::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Mul(...) AstNodeBiComAsv(VNType::Mul, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstMulD \
    AstMulD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMulD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstMulD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMulD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstMulD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstMulD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstMulD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstMulD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstMulD* clonep() const { return static_cast<AstMulD*>(AstNode::clonep()); } \
    AstMulD* addNext(AstMulD* nodep) { return static_cast<AstMulD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstMulD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiComAsv::lhsp; \
    using AstNodeBiComAsv::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_MulD(...) AstNodeBiComAsv(VNType::MulD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstMulS \
    AstMulS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMulS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstMulS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstMulS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstMulS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstMulS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstMulS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstMulS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstMulS* clonep() const { return static_cast<AstMulS*>(AstNode::clonep()); } \
    AstMulS* addNext(AstMulS* nodep) { return static_cast<AstMulS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstMulS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiComAsv::lhsp; \
    using AstNodeBiComAsv::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_MulS(...) AstNodeBiComAsv(VNType::MulS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNBACommitQueueDType \
private: \
    AstNodeDType* m_subDTypep = nullptr;public: \
    AstNBACommitQueueDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNBACommitQueueDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNBACommitQueueDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNBACommitQueueDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNBACommitQueueDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNBACommitQueueDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNBACommitQueueDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNBACommitQueueDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNBACommitQueueDType* clonep() const { return static_cast<AstNBACommitQueueDType*>(AstNode::clonep()); } \
    AstNBACommitQueueDType* addNext(AstNBACommitQueueDType* nodep) { return static_cast<AstNBACommitQueueDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNBACommitQueueDType(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_NBACommitQueueDType(...) AstNodeDType(VNType::NBACommitQueueDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNToI \
    AstNToI* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNToI*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNToI* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNToI*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNToI* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNToI*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNToI* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNToI*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNToI* clonep() const { return static_cast<AstNToI*>(AstNode::clonep()); } \
    AstNToI* addNext(AstNToI* nodep) { return static_cast<AstNToI*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNToI(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_NToI(...) AstNodeUniop(VNType::NToI, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNegate \
    AstNegate* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNegate*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNegate* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNegate*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNegate* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNegate*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNegate* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNegate*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNegate* clonep() const { return static_cast<AstNegate*>(AstNode::clonep()); } \
    AstNegate* addNext(AstNegate* nodep) { return static_cast<AstNegate*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNegate(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Negate(...) AstNodeUniop(VNType::Negate, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNegateD \
    AstNegateD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNegateD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNegateD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNegateD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNegateD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNegateD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNegateD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNegateD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNegateD* clonep() const { return static_cast<AstNegateD*>(AstNode::clonep()); } \
    AstNegateD* addNext(AstNegateD* nodep) { return static_cast<AstNegateD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNegateD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_NegateD(...) AstNodeUniop(VNType::NegateD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNeq \
    AstNeq* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNeq*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNeq* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNeq*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNeq* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNeq*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNeq* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNeq*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNeq* clonep() const { return static_cast<AstNeq*>(AstNode::clonep()); } \
    AstNeq* addNext(AstNeq* nodep) { return static_cast<AstNeq*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNeq(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiCom::lhsp; \
    using AstNodeBiCom::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Neq(...) AstNodeBiCom(VNType::Neq, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNeqCase \
    AstNeqCase* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNeqCase*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNeqCase* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNeqCase*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNeqCase* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNeqCase*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNeqCase* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNeqCase*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNeqCase* clonep() const { return static_cast<AstNeqCase*>(AstNode::clonep()); } \
    AstNeqCase* addNext(AstNeqCase* nodep) { return static_cast<AstNeqCase*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNeqCase(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiCom::lhsp; \
    using AstNodeBiCom::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_NeqCase(...) AstNodeBiCom(VNType::NeqCase, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNeqD \
    AstNeqD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNeqD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNeqD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNeqD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNeqD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNeqD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNeqD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNeqD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNeqD* clonep() const { return static_cast<AstNeqD*>(AstNode::clonep()); } \
    AstNeqD* addNext(AstNeqD* nodep) { return static_cast<AstNeqD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNeqD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiCom::lhsp; \
    using AstNodeBiCom::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_NeqD(...) AstNodeBiCom(VNType::NeqD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNeqN \
    AstNeqN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNeqN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNeqN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNeqN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNeqN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNeqN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNeqN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNeqN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNeqN* clonep() const { return static_cast<AstNeqN*>(AstNode::clonep()); } \
    AstNeqN* addNext(AstNeqN* nodep) { return static_cast<AstNeqN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNeqN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiCom::lhsp; \
    using AstNodeBiCom::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_NeqN(...) AstNodeBiCom(VNType::NeqN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNeqT \
    AstNeqT* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNeqT*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNeqT* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNeqT*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNeqT* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNeqT*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNeqT* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNeqT*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNeqT* clonep() const { return static_cast<AstNeqT*>(AstNode::clonep()); } \
    AstNeqT* addNext(AstNeqT* nodep) { return static_cast<AstNeqT*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNeqT(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiCom::lhsp; \
    using AstNodeBiCom::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_NeqT(...) AstNodeBiCom(VNType::NeqT, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNeqWild \
    AstNeqWild* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNeqWild*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNeqWild* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNeqWild*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNeqWild* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNeqWild*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNeqWild* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNeqWild*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNeqWild* clonep() const { return static_cast<AstNeqWild*>(AstNode::clonep()); } \
    AstNeqWild* addNext(AstNeqWild* nodep) { return static_cast<AstNeqWild*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNeqWild(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_NeqWild(...) AstNodeBiop(VNType::NeqWild, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNetlist \
private: \
    AstTypeTable* m_typeTablep = nullptr;    AstConstPool* m_constPoolp = nullptr;    AstPackage* m_dollarUnitPkgp = nullptr;    AstPackage* m_stdPackagep = nullptr;    AstCFunc* m_evalp = nullptr;    AstCFunc* m_evalNbap = nullptr;    AstVarScope* m_dpiExportTriggerp = nullptr;    AstVar* m_delaySchedulerp = nullptr;    AstVarScope* m_nbaEventp = nullptr;    AstVarScope* m_nbaEventTriggerp = nullptr;    AstTopScope* m_topScopep = nullptr;public: \
    AstNetlist* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNetlist*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNetlist* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNetlist*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNetlist* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNetlist*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNetlist* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNetlist*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNetlist* clonep() const { return static_cast<AstNetlist*>(AstNode::clonep()); } \
    AstNetlist* addNext(AstNetlist* nodep) { return static_cast<AstNetlist*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNetlist(*this); } \
    AstNodeModule* modulesp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeModule); } \
    void addModulesp(AstNodeModule* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeFile* filesp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeFile); } \
    void addFilesp(AstNodeFile* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* miscsp() const VL_MT_STABLE { return op3p(); } \
    void addMiscsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Netlist(...) AstNode(VNType::Netlist, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNew \
    AstNew* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNew*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNew* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNew*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNew* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNew*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNew* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNew*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNew* clonep() const { return static_cast<AstNew*>(AstNode::clonep()); } \
    AstNew* addNext(AstNew* nodep) { return static_cast<AstNew*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNew(*this); } \
    AstNode* namep() const VL_MT_STABLE { return op1p(); } \
    void namep(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* pinsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void addPinsp(AstNodeExpr* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScopeName* scopeNamep() const VL_MT_STABLE { return VN_DBG_AS(op4p(), ScopeName); } \
    void scopeNamep(AstScopeName* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeFTaskRef::namep; \
    using AstNodeFTaskRef::pinsp; \
    using AstNodeFTaskRef::addPinsp; \
    using AstNodeFTaskRef::scopeNamep; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_New(...) AstNodeFTaskRef(VNType::New, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNewCopy \
    AstNewCopy* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNewCopy*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNewCopy* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNewCopy*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNewCopy* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNewCopy*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNewCopy* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNewCopy*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNewCopy* clonep() const { return static_cast<AstNewCopy*>(AstNode::clonep()); } \
    AstNewCopy* addNext(AstNewCopy* nodep) { return static_cast<AstNewCopy*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNewCopy(*this); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_NewCopy(...) AstNodeExpr(VNType::NewCopy, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNewDynamic \
    AstNewDynamic* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNewDynamic*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNewDynamic* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNewDynamic*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNewDynamic* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNewDynamic*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNewDynamic* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNewDynamic*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNewDynamic* clonep() const { return static_cast<AstNewDynamic*>(AstNode::clonep()); } \
    AstNewDynamic* addNext(AstNewDynamic* nodep) { return static_cast<AstNewDynamic*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNewDynamic(*this); } \
    AstNodeExpr* sizep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void sizep(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_NewDynamic(...) AstNodeExpr(VNType::NewDynamic, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNode \
    AstNode* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNode*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNode* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNode*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNode* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNode*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNode* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNode*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNode* clonep() const { return static_cast<AstNode*>(AstNode::clonep()); } \
    AstNode* addNext(AstNode* nodep) { return static_cast<AstNode*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeArrayDType \
private: \
    AstNodeDType* m_refDTypep = nullptr;public: \
    AstNodeArrayDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeArrayDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeArrayDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeArrayDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeArrayDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeArrayDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeArrayDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeArrayDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeArrayDType* clonep() const { return static_cast<AstNodeArrayDType*>(AstNode::clonep()); } \
    AstNodeArrayDType* addNext(AstNodeArrayDType* nodep) { return static_cast<AstNodeArrayDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstRange* rangep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), Range); } \
    void rangep(AstRange* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeAssign \
    AstNodeAssign* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeAssign*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeAssign* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeAssign*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeAssign* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeAssign*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeAssign* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeAssign*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeAssign* clonep() const { return static_cast<AstNodeAssign*>(AstNode::clonep()); } \
    AstNodeAssign* addNext(AstNodeAssign* nodep) { return static_cast<AstNodeAssign*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* timingControlp() const VL_MT_STABLE { return op3p(); } \
    void timingControlp(AstNode* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeBiCom \
    AstNodeBiCom* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeBiCom*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeBiCom* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeBiCom*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeBiCom* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeBiCom*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeBiCom* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeBiCom*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeBiCom* clonep() const { return static_cast<AstNodeBiCom*>(AstNode::clonep()); } \
    AstNodeBiCom* addNext(AstNodeBiCom* nodep) { return static_cast<AstNodeBiCom*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeBiComAsv \
    AstNodeBiComAsv* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeBiComAsv*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeBiComAsv* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeBiComAsv*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeBiComAsv* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeBiComAsv*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeBiComAsv* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeBiComAsv*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeBiComAsv* clonep() const { return static_cast<AstNodeBiComAsv*>(AstNode::clonep()); } \
    AstNodeBiComAsv* addNext(AstNodeBiComAsv* nodep) { return static_cast<AstNodeBiComAsv*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiCom::lhsp; \
    using AstNodeBiCom::rhsp; \
public: \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeBiop \
    AstNodeBiop* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeBiop*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeBiop* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeBiop*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeBiop* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeBiop*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeBiop* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeBiop*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeBiop* clonep() const { return static_cast<AstNodeBiop*>(AstNode::clonep()); } \
    AstNodeBiop* addNext(AstNodeBiop* nodep) { return static_cast<AstNodeBiop*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeBlock \
    AstNodeBlock* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeBlock*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeBlock* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeBlock*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeBlock* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeBlock*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeBlock* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeBlock*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeBlock* clonep() const { return static_cast<AstNodeBlock*>(AstNode::clonep()); } \
    AstNodeBlock* addNext(AstNodeBlock* nodep) { return static_cast<AstNodeBlock*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNode* declsp() const VL_MT_STABLE { return op1p(); } \
    void addDeclsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeCCall \
private: \
    AstCFunc* m_funcp = nullptr;public: \
    AstNodeCCall* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeCCall*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeCCall* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeCCall*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeCCall* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeCCall*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeCCall* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeCCall*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeCCall* clonep() const { return static_cast<AstNodeCCall*>(AstNode::clonep()); } \
    AstNodeCCall* addNext(AstNodeCCall* nodep) { return static_cast<AstNodeCCall*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    AstNodeExpr* argsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void addArgsp(AstNodeExpr* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeCoverDecl \
private: \
    AstNodeCoverDecl* m_dataDeclp = nullptr;public: \
    AstNodeCoverDecl* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeCoverDecl*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeCoverDecl* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeCoverDecl*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeCoverDecl* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeCoverDecl*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeCoverDecl* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeCoverDecl*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeCoverDecl* clonep() const { return static_cast<AstNodeCoverDecl*>(AstNode::clonep()); } \
    AstNodeCoverDecl* addNext(AstNodeCoverDecl* nodep) { return static_cast<AstNodeCoverDecl*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeCoverOrAssert \
    AstNodeCoverOrAssert* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeCoverOrAssert*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeCoverOrAssert* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeCoverOrAssert*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeCoverOrAssert* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeCoverOrAssert*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeCoverOrAssert* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeCoverOrAssert*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeCoverOrAssert* clonep() const { return static_cast<AstNodeCoverOrAssert*>(AstNode::clonep()); } \
    AstNodeCoverOrAssert* addNext(AstNodeCoverOrAssert* nodep) { return static_cast<AstNodeCoverOrAssert*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNode* propp() const VL_MT_STABLE { return op1p(); } \
    void propp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* passsp() const VL_MT_STABLE { return op4p(); } \
    void addPasssp(AstNode* nodep) { addNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeDType \
    AstNodeDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeDType* clonep() const { return static_cast<AstNodeDType*>(AstNode::clonep()); } \
    AstNodeDType* addNext(AstNodeDType* nodep) { return static_cast<AstNodeDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeDistBiop \
    AstNodeDistBiop* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeDistBiop*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeDistBiop* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeDistBiop*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeDistBiop* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeDistBiop*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeDistBiop* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeDistBiop*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeDistBiop* clonep() const { return static_cast<AstNodeDistBiop*>(AstNode::clonep()); } \
    AstNodeDistBiop* addNext(AstNodeDistBiop* nodep) { return static_cast<AstNodeDistBiop*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeDistTriop \
    AstNodeDistTriop* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeDistTriop*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeDistTriop* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeDistTriop*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeDistTriop* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeDistTriop*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeDistTriop* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeDistTriop*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeDistTriop* clonep() const { return static_cast<AstNodeDistTriop*>(AstNode::clonep()); } \
    AstNodeDistTriop* addNext(AstNodeDistTriop* nodep) { return static_cast<AstNodeDistTriop*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeTriop::lhsp; \
    using AstNodeTriop::rhsp; \
    using AstNodeTriop::thsp; \
public: \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeExpr \
    AstNodeExpr* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeExpr*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeExpr* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeExpr*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeExpr* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeExpr*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeExpr* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeExpr*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeExpr* clonep() const { return static_cast<AstNodeExpr*>(AstNode::clonep()); } \
    AstNodeExpr* addNext(AstNodeExpr* nodep) { return static_cast<AstNodeExpr*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeFTask \
    AstNodeFTask* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeFTask*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeFTask* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeFTask*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeFTask* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeFTask*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeFTask* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeFTask*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeFTask* clonep() const { return static_cast<AstNodeFTask*>(AstNode::clonep()); } \
    AstNodeFTask* addNext(AstNodeFTask* nodep) { return static_cast<AstNodeFTask*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNode* fvarp() const VL_MT_STABLE { return op1p(); } \
    void fvarp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* classOrPackagep() const VL_MT_STABLE { return op2p(); } \
    void classOrPackagep(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op3p(); } \
    void addStmtsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScopeName* scopeNamep() const VL_MT_STABLE { return VN_DBG_AS(op4p(), ScopeName); } \
    void scopeNamep(AstScopeName* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeFTaskRef \
private: \
    AstNodeFTask* m_taskp = nullptr;    AstNodeModule* m_classOrPackagep = nullptr;public: \
    AstNodeFTaskRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeFTaskRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeFTaskRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeFTaskRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeFTaskRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeFTaskRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeFTaskRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeFTaskRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeFTaskRef* clonep() const { return static_cast<AstNodeFTaskRef*>(AstNode::clonep()); } \
    AstNodeFTaskRef* addNext(AstNodeFTaskRef* nodep) { return static_cast<AstNodeFTaskRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    AstNode* namep() const VL_MT_STABLE { return op1p(); } \
    void namep(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* pinsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void addPinsp(AstNodeExpr* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScopeName* scopeNamep() const VL_MT_STABLE { return VN_DBG_AS(op4p(), ScopeName); } \
    void scopeNamep(AstScopeName* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeFile \
    AstNodeFile* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeFile*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeFile* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeFile*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeFile* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeFile*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeFile* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeFile*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeFile* clonep() const { return static_cast<AstNodeFile*>(AstNode::clonep()); } \
    AstNodeFile* addNext(AstNodeFile* nodep) { return static_cast<AstNodeFile*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstTextBlock* tblockp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), TextBlock); } \
    void tblockp(AstTextBlock* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeForeach \
    AstNodeForeach* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeForeach*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeForeach* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeForeach*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeForeach* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeForeach*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeForeach* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeForeach*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeForeach* clonep() const { return static_cast<AstNodeForeach*>(AstNode::clonep()); } \
    AstNodeForeach* addNext(AstNodeForeach* nodep) { return static_cast<AstNodeForeach*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNode* arrayp() const VL_MT_STABLE { return op1p(); } \
    void arrayp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeGen \
    AstNodeGen* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeGen*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeGen* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeGen*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeGen* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeGen*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeGen* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeGen*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeGen* clonep() const { return static_cast<AstNodeGen*>(AstNode::clonep()); } \
    AstNodeGen* addNext(AstNodeGen* nodep) { return static_cast<AstNodeGen*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeIf \
    AstNodeIf* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeIf*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeIf* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeIf*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeIf* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeIf*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeIf* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeIf*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeIf* clonep() const { return static_cast<AstNodeIf*>(AstNode::clonep()); } \
    AstNodeIf* addNext(AstNodeIf* nodep) { return static_cast<AstNodeIf*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* condp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void condp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* thensp() const VL_MT_STABLE { return op2p(); } \
    void addThensp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* elsesp() const VL_MT_STABLE { return op3p(); } \
    void addElsesp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeModule \
    AstNodeModule* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeModule*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeModule* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeModule*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeModule* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeModule*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeModule* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeModule*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeModule* clonep() const { return static_cast<AstNodeModule*>(AstNode::clonep()); } \
    AstNodeModule* addNext(AstNodeModule* nodep) { return static_cast<AstNodeModule*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNode* inlinesp() const VL_MT_STABLE { return op1p(); } \
    void addInlinesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodePreSel \
    AstNodePreSel* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodePreSel*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodePreSel* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodePreSel*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodePreSel* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodePreSel*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodePreSel* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodePreSel*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodePreSel* clonep() const { return static_cast<AstNodePreSel*>(AstNode::clonep()); } \
    AstNodePreSel* addNext(AstNodePreSel* nodep) { return static_cast<AstNodePreSel*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstAttrOf* attrp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), AttrOf); } \
    void attrp(AstAttrOf* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeProcedure \
    AstNodeProcedure* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeProcedure*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeProcedure* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeProcedure*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeProcedure* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeProcedure*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeProcedure* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeProcedure*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeProcedure* clonep() const { return static_cast<AstNodeProcedure*>(AstNode::clonep()); } \
    AstNodeProcedure* addNext(AstNodeProcedure* nodep) { return static_cast<AstNodeProcedure*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeQuadop \
    AstNodeQuadop* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeQuadop*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeQuadop* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeQuadop*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeQuadop* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeQuadop*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeQuadop* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeQuadop*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeQuadop* clonep() const { return static_cast<AstNodeQuadop*>(AstNode::clonep()); } \
    AstNodeQuadop* addNext(AstNodeQuadop* nodep) { return static_cast<AstNodeQuadop*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* fhsp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), NodeExpr); } \
    void fhsp(AstNodeExpr* nodep) { setOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeRange \
    AstNodeRange* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeRange*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeRange* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeRange*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeRange* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeRange*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeRange* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeRange*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeRange* clonep() const { return static_cast<AstNodeRange*>(AstNode::clonep()); } \
    AstNodeRange* addNext(AstNodeRange* nodep) { return static_cast<AstNodeRange*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeReadWriteMem \
    AstNodeReadWriteMem* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeReadWriteMem*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeReadWriteMem* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeReadWriteMem*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeReadWriteMem* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeReadWriteMem*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeReadWriteMem* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeReadWriteMem*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeReadWriteMem* clonep() const { return static_cast<AstNodeReadWriteMem*>(AstNode::clonep()); } \
    AstNodeReadWriteMem* addNext(AstNodeReadWriteMem* nodep) { return static_cast<AstNodeReadWriteMem*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* filenamep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void filenamep(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* memp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void memp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* lsbp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void lsbp(AstNodeExpr* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* msbp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), NodeExpr); } \
    void msbp(AstNodeExpr* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeSel \
    AstNodeSel* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeSel*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeSel* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeSel*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeSel* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeSel*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeSel* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeSel*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeSel* clonep() const { return static_cast<AstNodeSel*>(AstNode::clonep()); } \
    AstNodeSel* addNext(AstNodeSel* nodep) { return static_cast<AstNodeSel*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* bitp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void bitp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeStmt \
    AstNodeStmt* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeStmt*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeStmt* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeStmt*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeStmt* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeStmt*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeStmt* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeStmt*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeStmt* clonep() const { return static_cast<AstNodeStmt*>(AstNode::clonep()); } \
    AstNodeStmt* addNext(AstNodeStmt* nodep) { return static_cast<AstNodeStmt*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeStream \
    AstNodeStream* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeStream*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeStream* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeStream*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeStream* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeStream*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeStream* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeStream*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeStream* clonep() const { return static_cast<AstNodeStream*>(AstNode::clonep()); } \
    AstNodeStream* addNext(AstNodeStream* nodep) { return static_cast<AstNodeStream*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeSystemBiopD \
    AstNodeSystemBiopD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeSystemBiopD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeSystemBiopD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeSystemBiopD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeSystemBiopD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeSystemBiopD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeSystemBiopD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeSystemBiopD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeSystemBiopD* clonep() const { return static_cast<AstNodeSystemBiopD*>(AstNode::clonep()); } \
    AstNodeSystemBiopD* addNext(AstNodeSystemBiopD* nodep) { return static_cast<AstNodeSystemBiopD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeSystemUniopD \
    AstNodeSystemUniopD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeSystemUniopD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeSystemUniopD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeSystemUniopD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeSystemUniopD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeSystemUniopD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeSystemUniopD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeSystemUniopD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeSystemUniopD* clonep() const { return static_cast<AstNodeSystemUniopD*>(AstNode::clonep()); } \
    AstNodeSystemUniopD* addNext(AstNodeSystemUniopD* nodep) { return static_cast<AstNodeSystemUniopD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeTermop \
    AstNodeTermop* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeTermop*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeTermop* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeTermop*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeTermop* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeTermop*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeTermop* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeTermop*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeTermop* clonep() const { return static_cast<AstNodeTermop*>(AstNode::clonep()); } \
    AstNodeTermop* addNext(AstNodeTermop* nodep) { return static_cast<AstNodeTermop*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeTriop \
    AstNodeTriop* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeTriop*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeTriop* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeTriop*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeTriop* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeTriop*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeTriop* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeTriop*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeTriop* clonep() const { return static_cast<AstNodeTriop*>(AstNode::clonep()); } \
    AstNodeTriop* addNext(AstNodeTriop* nodep) { return static_cast<AstNodeTriop*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeUOrStructDType \
private: \
    AstNodeModule* m_classOrPackagep = nullptr;public: \
    AstNodeUOrStructDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeUOrStructDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeUOrStructDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeUOrStructDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeUOrStructDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeUOrStructDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeUOrStructDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeUOrStructDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeUOrStructDType* clonep() const { return static_cast<AstNodeUOrStructDType*>(AstNode::clonep()); } \
    AstNodeUOrStructDType* addNext(AstNodeUOrStructDType* nodep) { return static_cast<AstNodeUOrStructDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    AstMemberDType* membersp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), MemberDType); } \
    void addMembersp(AstMemberDType* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeUniop \
    AstNodeUniop* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeUniop*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeUniop* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeUniop*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeUniop* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeUniop*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeUniop* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeUniop*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeUniop* clonep() const { return static_cast<AstNodeUniop*>(AstNode::clonep()); } \
    AstNodeUniop* addNext(AstNodeUniop* nodep) { return static_cast<AstNodeUniop*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNodeVarRef \
private: \
    AstVar* m_varp = nullptr;    AstVarScope* m_varScopep = nullptr;    AstNodeModule* m_classOrPackagep = nullptr;public: \
    AstNodeVarRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeVarRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNodeVarRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNodeVarRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNodeVarRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNodeVarRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNodeVarRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNodeVarRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNodeVarRef* clonep() const { return static_cast<AstNodeVarRef*>(AstNode::clonep()); } \
    AstNodeVarRef* addNext(AstNodeVarRef* nodep) { return static_cast<AstNodeVarRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    static_assert(true, "")

#define ASTGEN_MEMBERS_AstNot \
    AstNot* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNot*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNot* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNot*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNot* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNot*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNot* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNot*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNot* clonep() const { return static_cast<AstNot*>(AstNode::clonep()); } \
    AstNot* addNext(AstNot* nodep) { return static_cast<AstNot*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNot(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Not(...) AstNodeUniop(VNType::Not, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNotFoundModule \
    AstNotFoundModule* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNotFoundModule*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNotFoundModule* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNotFoundModule*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNotFoundModule* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNotFoundModule*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNotFoundModule* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNotFoundModule*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNotFoundModule* clonep() const { return static_cast<AstNotFoundModule*>(AstNode::clonep()); } \
    AstNotFoundModule* addNext(AstNotFoundModule* nodep) { return static_cast<AstNotFoundModule*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNotFoundModule(*this); } \
    AstNode* inlinesp() const VL_MT_STABLE { return op1p(); } \
    void addInlinesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeModule::inlinesp; \
    using AstNodeModule::addInlinesp; \
    using AstNodeModule::stmtsp; \
    using AstNodeModule::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_NotFoundModule(...) AstNodeModule(VNType::NotFoundModule, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstNullCheck \
    AstNullCheck* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNullCheck*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstNullCheck* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstNullCheck*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstNullCheck* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstNullCheck*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstNullCheck* cloneTreePure(bool cloneNext) { \
        return static_cast<AstNullCheck*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstNullCheck* clonep() const { return static_cast<AstNullCheck*>(AstNode::clonep()); } \
    AstNullCheck* addNext(AstNullCheck* nodep) { return static_cast<AstNullCheck*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstNullCheck(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_NullCheck(...) AstNodeUniop(VNType::NullCheck, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstOneHot \
    AstOneHot* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstOneHot*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstOneHot* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstOneHot*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstOneHot* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstOneHot*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstOneHot* cloneTreePure(bool cloneNext) { \
        return static_cast<AstOneHot*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstOneHot* clonep() const { return static_cast<AstOneHot*>(AstNode::clonep()); } \
    AstOneHot* addNext(AstOneHot* nodep) { return static_cast<AstOneHot*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstOneHot(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_OneHot(...) AstNodeUniop(VNType::OneHot, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstOneHot0 \
    AstOneHot0* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstOneHot0*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstOneHot0* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstOneHot0*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstOneHot0* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstOneHot0*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstOneHot0* cloneTreePure(bool cloneNext) { \
        return static_cast<AstOneHot0*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstOneHot0* clonep() const { return static_cast<AstOneHot0*>(AstNode::clonep()); } \
    AstOneHot0* addNext(AstOneHot0* nodep) { return static_cast<AstOneHot0*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstOneHot0(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_OneHot0(...) AstNodeUniop(VNType::OneHot0, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstOr \
    AstOr* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstOr*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstOr* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstOr*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstOr* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstOr*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstOr* cloneTreePure(bool cloneNext) { \
        return static_cast<AstOr*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstOr* clonep() const { return static_cast<AstOr*>(AstNode::clonep()); } \
    AstOr* addNext(AstOr* nodep) { return static_cast<AstOr*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstOr(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiComAsv::lhsp; \
    using AstNodeBiComAsv::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Or(...) AstNodeBiComAsv(VNType::Or, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPExpr \
    AstPExpr* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPExpr*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPExpr* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPExpr*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPExpr* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPExpr*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPExpr* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPExpr*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPExpr* clonep() const { return static_cast<AstPExpr*>(AstNode::clonep()); } \
    AstPExpr* addNext(AstPExpr* nodep) { return static_cast<AstPExpr*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPExpr(*this); } \
    AstBegin* bodyp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), Begin); } \
    void bodyp(AstBegin* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_PExpr(...) AstNodeExpr(VNType::PExpr, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPExprClause \
    AstPExprClause* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPExprClause*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPExprClause* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPExprClause*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPExprClause* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPExprClause*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPExprClause* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPExprClause*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPExprClause* clonep() const { return static_cast<AstPExprClause*>(AstNode::clonep()); } \
    AstPExprClause* addNext(AstPExprClause* nodep) { return static_cast<AstPExprClause*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPExprClause(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_PExprClause(...) AstNodeStmt(VNType::PExprClause, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPackArrayDType \
    AstPackArrayDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPackArrayDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPackArrayDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPackArrayDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPackArrayDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPackArrayDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPackArrayDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPackArrayDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPackArrayDType* clonep() const { return static_cast<AstPackArrayDType*>(AstNode::clonep()); } \
    AstPackArrayDType* addNext(AstPackArrayDType* nodep) { return static_cast<AstPackArrayDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPackArrayDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstRange* rangep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), Range); } \
    void rangep(AstRange* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeArrayDType::childDTypep; \
    using AstNodeArrayDType::rangep; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_PackArrayDType(...) AstNodeArrayDType(VNType::PackArrayDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPackage \
    AstPackage* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPackage*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPackage* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPackage*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPackage* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPackage*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPackage* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPackage*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPackage* clonep() const { return static_cast<AstPackage*>(AstNode::clonep()); } \
    AstPackage* addNext(AstPackage* nodep) { return static_cast<AstPackage*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPackage(*this); } \
    AstNode* inlinesp() const VL_MT_STABLE { return op1p(); } \
    void addInlinesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeModule::inlinesp; \
    using AstNodeModule::addInlinesp; \
    using AstNodeModule::stmtsp; \
    using AstNodeModule::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Package(...) AstNodeModule(VNType::Package, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPackageExport \
private: \
    AstPackage* m_packagep = nullptr;public: \
    AstPackageExport* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPackageExport*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPackageExport* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPackageExport*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPackageExport* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPackageExport*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPackageExport* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPackageExport*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPackageExport* clonep() const { return static_cast<AstPackageExport*>(AstNode::clonep()); } \
    AstPackageExport* addNext(AstPackageExport* nodep) { return static_cast<AstPackageExport*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPackageExport(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_PackageExport(...) AstNode(VNType::PackageExport, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPackageExportStarStar \
    AstPackageExportStarStar* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPackageExportStarStar*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPackageExportStarStar* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPackageExportStarStar*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPackageExportStarStar* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPackageExportStarStar*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPackageExportStarStar* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPackageExportStarStar*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPackageExportStarStar* clonep() const { return static_cast<AstPackageExportStarStar*>(AstNode::clonep()); } \
    AstPackageExportStarStar* addNext(AstPackageExportStarStar* nodep) { return static_cast<AstPackageExportStarStar*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPackageExportStarStar(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_PackageExportStarStar(...) AstNode(VNType::PackageExportStarStar, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPackageImport \
private: \
    AstPackage* m_packagep = nullptr;public: \
    AstPackageImport* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPackageImport*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPackageImport* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPackageImport*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPackageImport* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPackageImport*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPackageImport* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPackageImport*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPackageImport* clonep() const { return static_cast<AstPackageImport*>(AstNode::clonep()); } \
    AstPackageImport* addNext(AstPackageImport* nodep) { return static_cast<AstPackageImport*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPackageImport(*this); } \
    AstClassOrPackageRef* resolvedClassp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), ClassOrPackageRef); } \
    void resolvedClassp(AstClassOrPackageRef* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_PackageImport(...) AstNode(VNType::PackageImport, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstParamTypeDType \
    AstParamTypeDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstParamTypeDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstParamTypeDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstParamTypeDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstParamTypeDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstParamTypeDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstParamTypeDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstParamTypeDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstParamTypeDType* clonep() const { return static_cast<AstParamTypeDType*>(AstNode::clonep()); } \
    AstParamTypeDType* addNext(AstParamTypeDType* nodep) { return static_cast<AstParamTypeDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstParamTypeDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ParamTypeDType(...) AstNodeDType(VNType::ParamTypeDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstParseHolder \
    AstParseHolder* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstParseHolder*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstParseHolder* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstParseHolder*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstParseHolder* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstParseHolder*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstParseHolder* cloneTreePure(bool cloneNext) { \
        return static_cast<AstParseHolder*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstParseHolder* clonep() const { return static_cast<AstParseHolder*>(AstNode::clonep()); } \
    AstParseHolder* addNext(AstParseHolder* nodep) { return static_cast<AstParseHolder*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstParseHolder(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ParseHolder(...) AstNodeExpr(VNType::ParseHolder, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstParseRef \
    AstParseRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstParseRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstParseRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstParseRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstParseRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstParseRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstParseRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstParseRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstParseRef* clonep() const { return static_cast<AstParseRef*>(AstNode::clonep()); } \
    AstParseRef* addNext(AstParseRef* nodep) { return static_cast<AstParseRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstParseRef(*this); } \
    AstNode* lhsp() const VL_MT_STABLE { return op1p(); } \
    void lhsp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeFTaskRef* ftaskrefp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeFTaskRef); } \
    void ftaskrefp(AstNodeFTaskRef* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ParseRef(...) AstNodeExpr(VNType::ParseRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstParseTypeDType \
    AstParseTypeDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstParseTypeDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstParseTypeDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstParseTypeDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstParseTypeDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstParseTypeDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstParseTypeDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstParseTypeDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstParseTypeDType* clonep() const { return static_cast<AstParseTypeDType*>(AstNode::clonep()); } \
    AstParseTypeDType* addNext(AstParseTypeDType* nodep) { return static_cast<AstParseTypeDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstParseTypeDType(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ParseTypeDType(...) AstNodeDType(VNType::ParseTypeDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPast \
    AstPast* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPast*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPast* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPast*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPast* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPast*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPast* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPast*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPast* clonep() const { return static_cast<AstPast*>(AstNode::clonep()); } \
    AstPast* addNext(AstPast* nodep) { return static_cast<AstPast*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPast(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* ticksp() const VL_MT_STABLE { return op2p(); } \
    void ticksp(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op3p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Past(...) AstNodeExpr(VNType::Past, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPatMember \
    AstPatMember* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPatMember*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPatMember* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPatMember*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPatMember* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPatMember*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPatMember* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPatMember*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPatMember* clonep() const { return static_cast<AstPatMember*>(AstNode::clonep()); } \
    AstPatMember* addNext(AstPatMember* nodep) { return static_cast<AstPatMember*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPatMember(*this); } \
    AstNodeExpr* lhssp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void addLhssp(AstNodeExpr* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* keyp() const VL_MT_STABLE { return op2p(); } \
    void keyp(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* repp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void repp(AstNodeExpr* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* varrefp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), NodeExpr); } \
    void varrefp(AstNodeExpr* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_PatMember(...) AstNodeExpr(VNType::PatMember, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPattern \
    AstPattern* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPattern*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPattern* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPattern*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPattern* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPattern*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPattern* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPattern*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPattern* clonep() const { return static_cast<AstPattern*>(AstNode::clonep()); } \
    AstPattern* addNext(AstPattern* nodep) { return static_cast<AstPattern*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPattern(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* itemsp() const VL_MT_STABLE { return op2p(); } \
    void addItemsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Pattern(...) AstNodeExpr(VNType::Pattern, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPin \
private: \
    AstVar* m_modVarp = nullptr;    AstParamTypeDType* m_modPTypep = nullptr;public: \
    AstPin* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPin*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPin* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPin*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPin* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPin*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPin* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPin*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPin* clonep() const { return static_cast<AstPin*>(AstNode::clonep()); } \
    AstPin* addNext(AstPin* nodep) { return static_cast<AstPin*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPin(*this); } \
    AstNode* exprp() const VL_MT_STABLE { return op1p(); } \
    void exprp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Pin(...) AstNode(VNType::Pin, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPort \
    AstPort* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPort*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPort* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPort*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPort* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPort*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPort* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPort*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPort* clonep() const { return static_cast<AstPort*>(AstNode::clonep()); } \
    AstPort* addNext(AstPort* nodep) { return static_cast<AstPort*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPort(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Port(...) AstNode(VNType::Port, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPostAdd \
    AstPostAdd* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPostAdd*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPostAdd* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPostAdd*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPostAdd* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPostAdd*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPostAdd* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPostAdd*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPostAdd* clonep() const { return static_cast<AstPostAdd*>(AstNode::clonep()); } \
    AstPostAdd* addNext(AstPostAdd* nodep) { return static_cast<AstPostAdd*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPostAdd(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeTriop::lhsp; \
    using AstNodeTriop::rhsp; \
    using AstNodeTriop::thsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_PostAdd(...) AstNodeTriop(VNType::PostAdd, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPostSub \
    AstPostSub* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPostSub*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPostSub* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPostSub*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPostSub* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPostSub*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPostSub* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPostSub*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPostSub* clonep() const { return static_cast<AstPostSub*>(AstNode::clonep()); } \
    AstPostSub* addNext(AstPostSub* nodep) { return static_cast<AstPostSub*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPostSub(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeTriop::lhsp; \
    using AstNodeTriop::rhsp; \
    using AstNodeTriop::thsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_PostSub(...) AstNodeTriop(VNType::PostSub, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPow \
    AstPow* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPow*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPow* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPow*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPow* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPow*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPow* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPow*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPow* clonep() const { return static_cast<AstPow*>(AstNode::clonep()); } \
    AstPow* addNext(AstPow* nodep) { return static_cast<AstPow*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPow(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Pow(...) AstNodeBiop(VNType::Pow, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPowD \
    AstPowD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPowD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPowD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPowD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPowD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPowD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPowD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPowD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPowD* clonep() const { return static_cast<AstPowD*>(AstNode::clonep()); } \
    AstPowD* addNext(AstPowD* nodep) { return static_cast<AstPowD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPowD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_PowD(...) AstNodeBiop(VNType::PowD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPowSS \
    AstPowSS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPowSS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPowSS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPowSS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPowSS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPowSS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPowSS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPowSS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPowSS* clonep() const { return static_cast<AstPowSS*>(AstNode::clonep()); } \
    AstPowSS* addNext(AstPowSS* nodep) { return static_cast<AstPowSS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPowSS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_PowSS(...) AstNodeBiop(VNType::PowSS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPowSU \
    AstPowSU* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPowSU*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPowSU* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPowSU*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPowSU* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPowSU*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPowSU* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPowSU*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPowSU* clonep() const { return static_cast<AstPowSU*>(AstNode::clonep()); } \
    AstPowSU* addNext(AstPowSU* nodep) { return static_cast<AstPowSU*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPowSU(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_PowSU(...) AstNodeBiop(VNType::PowSU, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPowUS \
    AstPowUS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPowUS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPowUS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPowUS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPowUS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPowUS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPowUS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPowUS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPowUS* clonep() const { return static_cast<AstPowUS*>(AstNode::clonep()); } \
    AstPowUS* addNext(AstPowUS* nodep) { return static_cast<AstPowUS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPowUS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_PowUS(...) AstNodeBiop(VNType::PowUS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPragma \
    AstPragma* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPragma*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPragma* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPragma*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPragma* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPragma*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPragma* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPragma*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPragma* clonep() const { return static_cast<AstPragma*>(AstNode::clonep()); } \
    AstPragma* addNext(AstPragma* nodep) { return static_cast<AstPragma*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPragma(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Pragma(...) AstNode(VNType::Pragma, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPreAdd \
    AstPreAdd* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPreAdd*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPreAdd* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPreAdd*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPreAdd* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPreAdd*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPreAdd* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPreAdd*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPreAdd* clonep() const { return static_cast<AstPreAdd*>(AstNode::clonep()); } \
    AstPreAdd* addNext(AstPreAdd* nodep) { return static_cast<AstPreAdd*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPreAdd(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeTriop::lhsp; \
    using AstNodeTriop::rhsp; \
    using AstNodeTriop::thsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_PreAdd(...) AstNodeTriop(VNType::PreAdd, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPreSub \
    AstPreSub* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPreSub*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPreSub* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPreSub*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPreSub* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPreSub*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPreSub* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPreSub*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPreSub* clonep() const { return static_cast<AstPreSub*>(AstNode::clonep()); } \
    AstPreSub* addNext(AstPreSub* nodep) { return static_cast<AstPreSub*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPreSub(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeTriop::lhsp; \
    using AstNodeTriop::rhsp; \
    using AstNodeTriop::thsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_PreSub(...) AstNodeTriop(VNType::PreSub, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPrimitive \
    AstPrimitive* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPrimitive*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPrimitive* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPrimitive*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPrimitive* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPrimitive*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPrimitive* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPrimitive*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPrimitive* clonep() const { return static_cast<AstPrimitive*>(AstNode::clonep()); } \
    AstPrimitive* addNext(AstPrimitive* nodep) { return static_cast<AstPrimitive*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPrimitive(*this); } \
    AstNode* inlinesp() const VL_MT_STABLE { return op1p(); } \
    void addInlinesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeModule::inlinesp; \
    using AstNodeModule::addInlinesp; \
    using AstNodeModule::stmtsp; \
    using AstNodeModule::addStmtsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Primitive(...) AstNodeModule(VNType::Primitive, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPrintTimeScale \
    AstPrintTimeScale* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPrintTimeScale*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPrintTimeScale* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPrintTimeScale*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPrintTimeScale* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPrintTimeScale*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPrintTimeScale* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPrintTimeScale*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPrintTimeScale* clonep() const { return static_cast<AstPrintTimeScale*>(AstNode::clonep()); } \
    AstPrintTimeScale* addNext(AstPrintTimeScale* nodep) { return static_cast<AstPrintTimeScale*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPrintTimeScale(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_PrintTimeScale(...) AstNodeStmt(VNType::PrintTimeScale, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPropSpec \
    AstPropSpec* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPropSpec*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPropSpec* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPropSpec*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPropSpec* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPropSpec*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPropSpec* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPropSpec*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPropSpec* clonep() const { return static_cast<AstPropSpec*>(AstNode::clonep()); } \
    AstPropSpec* addNext(AstPropSpec* nodep) { return static_cast<AstPropSpec*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPropSpec(*this); } \
    AstSenItem* sensesp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), SenItem); } \
    void sensesp(AstSenItem* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* disablep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void disablep(AstNodeExpr* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* propp() const VL_MT_STABLE { return op3p(); } \
    void propp(AstNode* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_PropSpec(...) AstNode(VNType::PropSpec, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstProperty \
    AstProperty* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstProperty*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstProperty* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstProperty*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstProperty* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstProperty*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstProperty* cloneTreePure(bool cloneNext) { \
        return static_cast<AstProperty*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstProperty* clonep() const { return static_cast<AstProperty*>(AstNode::clonep()); } \
    AstProperty* addNext(AstProperty* nodep) { return static_cast<AstProperty*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstProperty(*this); } \
    AstNode* fvarp() const VL_MT_STABLE { return op1p(); } \
    void fvarp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* classOrPackagep() const VL_MT_STABLE { return op2p(); } \
    void classOrPackagep(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op3p(); } \
    void addStmtsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScopeName* scopeNamep() const VL_MT_STABLE { return VN_DBG_AS(op4p(), ScopeName); } \
    void scopeNamep(AstScopeName* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeFTask::fvarp; \
    using AstNodeFTask::classOrPackagep; \
    using AstNodeFTask::stmtsp; \
    using AstNodeFTask::addStmtsp; \
    using AstNodeFTask::scopeNamep; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Property(...) AstNodeFTask(VNType::Property, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPull \
    AstPull* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPull*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPull* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPull*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPull* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPull*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPull* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPull*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPull* clonep() const { return static_cast<AstPull*>(AstNode::clonep()); } \
    AstPull* addNext(AstPull* nodep) { return static_cast<AstPull*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPull(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Pull(...) AstNode(VNType::Pull, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstPutcN \
    AstPutcN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPutcN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstPutcN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstPutcN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstPutcN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstPutcN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstPutcN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstPutcN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstPutcN* clonep() const { return static_cast<AstPutcN*>(AstNode::clonep()); } \
    AstPutcN* addNext(AstPutcN* nodep) { return static_cast<AstPutcN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstPutcN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeTriop::lhsp; \
    using AstNodeTriop::rhsp; \
    using AstNodeTriop::thsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_PutcN(...) AstNodeTriop(VNType::PutcN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstQueueDType \
private: \
    AstNodeDType* m_refDTypep = nullptr;public: \
    AstQueueDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstQueueDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstQueueDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstQueueDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstQueueDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstQueueDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstQueueDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstQueueDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstQueueDType* clonep() const { return static_cast<AstQueueDType*>(AstNode::clonep()); } \
    AstQueueDType* addNext(AstQueueDType* nodep) { return static_cast<AstQueueDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstQueueDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* boundp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void boundp(AstNodeExpr* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_QueueDType(...) AstNodeDType(VNType::QueueDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRSBreak \
    AstRSBreak* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRSBreak*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRSBreak* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRSBreak*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRSBreak* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRSBreak*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRSBreak* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRSBreak*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRSBreak* clonep() const { return static_cast<AstRSBreak*>(AstNode::clonep()); } \
    AstRSBreak* addNext(AstRSBreak* nodep) { return static_cast<AstRSBreak*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRSBreak(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_RSBreak(...) AstNodeStmt(VNType::RSBreak, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRSProd \
    AstRSProd* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRSProd*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRSProd* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRSProd*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRSProd* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRSProd*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRSProd* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRSProd*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRSProd* clonep() const { return static_cast<AstRSProd*>(AstNode::clonep()); } \
    AstRSProd* addNext(AstRSProd* nodep) { return static_cast<AstRSProd*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRSProd(*this); } \
    AstVar* fvarp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), Var); } \
    void fvarp(AstVar* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* portsp() const VL_MT_STABLE { return op2p(); } \
    void addPortsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstRSRule* rulesp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), RSRule); } \
    void addRulesp(AstRSRule* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_RSProd(...) AstNodeStmt(VNType::RSProd, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRSProdItem \
private: \
    AstRSProd* m_prodp = nullptr;public: \
    AstRSProdItem* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRSProdItem*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRSProdItem* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRSProdItem*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRSProdItem* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRSProdItem*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRSProdItem* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRSProdItem*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRSProdItem* clonep() const { return static_cast<AstRSProdItem*>(AstNode::clonep()); } \
    AstRSProdItem* addNext(AstRSProdItem* nodep) { return static_cast<AstRSProdItem*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRSProdItem(*this); } \
    AstNodeExpr* argsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void addArgsp(AstNodeExpr* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_RSProdItem(...) AstNodeStmt(VNType::RSProdItem, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRSProdList \
    AstRSProdList* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRSProdList*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRSProdList* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRSProdList*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRSProdList* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRSProdList*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRSProdList* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRSProdList*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRSProdList* clonep() const { return static_cast<AstRSProdList*>(AstNode::clonep()); } \
    AstRSProdList* addNext(AstRSProdList* nodep) { return static_cast<AstRSProdList*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRSProdList(*this); } \
    AstNodeExpr* weightp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void weightp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* prodsp() const VL_MT_STABLE { return op2p(); } \
    void addProdsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_RSProdList(...) AstNodeStmt(VNType::RSProdList, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRSReturn \
    AstRSReturn* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRSReturn*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRSReturn* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRSReturn*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRSReturn* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRSReturn*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRSReturn* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRSReturn*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRSReturn* clonep() const { return static_cast<AstRSReturn*>(AstNode::clonep()); } \
    AstRSReturn* addNext(AstRSReturn* nodep) { return static_cast<AstRSReturn*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRSReturn(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_RSReturn(...) AstNodeStmt(VNType::RSReturn, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRSRule \
    AstRSRule* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRSRule*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRSRule* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRSRule*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRSRule* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRSRule*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRSRule* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRSRule*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRSRule* clonep() const { return static_cast<AstRSRule*>(AstNode::clonep()); } \
    AstRSRule* addNext(AstRSRule* nodep) { return static_cast<AstRSRule*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRSRule(*this); } \
    AstNodeExpr* weightp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void weightp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstRSProdList* prodlistsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), RSProdList); } \
    void addProdlistsp(AstRSProdList* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* weightStmtsp() const VL_MT_STABLE { return op3p(); } \
    void addWeightStmtsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_RSRule(...) AstNodeStmt(VNType::RSRule, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRToIRoundS \
    AstRToIRoundS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRToIRoundS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRToIRoundS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRToIRoundS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRToIRoundS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRToIRoundS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRToIRoundS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRToIRoundS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRToIRoundS* clonep() const { return static_cast<AstRToIRoundS*>(AstNode::clonep()); } \
    AstRToIRoundS* addNext(AstRToIRoundS* nodep) { return static_cast<AstRToIRoundS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRToIRoundS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_RToIRoundS(...) AstNodeUniop(VNType::RToIRoundS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRToIS \
    AstRToIS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRToIS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRToIS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRToIS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRToIS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRToIS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRToIS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRToIS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRToIS* clonep() const { return static_cast<AstRToIS*>(AstNode::clonep()); } \
    AstRToIS* addNext(AstRToIS* nodep) { return static_cast<AstRToIS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRToIS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_RToIS(...) AstNodeUniop(VNType::RToIS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRand \
    AstRand* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRand*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRand* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRand*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRand* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRand*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRand* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRand*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRand* clonep() const { return static_cast<AstRand*>(AstNode::clonep()); } \
    AstRand* addNext(AstRand* nodep) { return static_cast<AstRand*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRand(*this); } \
    AstNode* seedp() const VL_MT_STABLE { return op1p(); } \
    void seedp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Rand(...) AstNodeExpr(VNType::Rand, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRandCase \
    AstRandCase* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRandCase*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRandCase* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRandCase*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRandCase* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRandCase*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRandCase* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRandCase*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRandCase* clonep() const { return static_cast<AstRandCase*>(AstNode::clonep()); } \
    AstRandCase* addNext(AstRandCase* nodep) { return static_cast<AstRandCase*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRandCase(*this); } \
    AstCaseItem* itemsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), CaseItem); } \
    void addItemsp(AstCaseItem* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_RandCase(...) AstNodeStmt(VNType::RandCase, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRandRNG \
    AstRandRNG* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRandRNG*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRandRNG* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRandRNG*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRandRNG* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRandRNG*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRandRNG* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRandRNG*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRandRNG* clonep() const { return static_cast<AstRandRNG*>(AstNode::clonep()); } \
    AstRandRNG* addNext(AstRandRNG* nodep) { return static_cast<AstRandRNG*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRandRNG(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_RandRNG(...) AstNodeExpr(VNType::RandRNG, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRandSequence \
private: \
    AstRSProd* m_prodp = nullptr;public: \
    AstRandSequence* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRandSequence*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRandSequence* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRandSequence*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRandSequence* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRandSequence*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRandSequence* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRandSequence*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRandSequence* clonep() const { return static_cast<AstRandSequence*>(AstNode::clonep()); } \
    AstRandSequence* addNext(AstRandSequence* nodep) { return static_cast<AstRandSequence*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRandSequence(*this); } \
    AstRSProd* prodsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), RSProd); } \
    void addProdsp(AstRSProd* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_RandSequence(...) AstNodeStmt(VNType::RandSequence, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRange \
    AstRange* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRange*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRange* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRange*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRange* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRange*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRange* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRange*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRange* clonep() const { return static_cast<AstRange*>(AstNode::clonep()); } \
    AstRange* addNext(AstRange* nodep) { return static_cast<AstRange*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRange(*this); } \
    AstNodeExpr* leftp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void leftp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rightp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rightp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Range(...) AstNodeRange(VNType::Range, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstReadMem \
    AstReadMem* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstReadMem*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstReadMem* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstReadMem*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstReadMem* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstReadMem*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstReadMem* cloneTreePure(bool cloneNext) { \
        return static_cast<AstReadMem*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstReadMem* clonep() const { return static_cast<AstReadMem*>(AstNode::clonep()); } \
    AstReadMem* addNext(AstReadMem* nodep) { return static_cast<AstReadMem*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstReadMem(*this); } \
    AstNodeExpr* filenamep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void filenamep(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* memp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void memp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* lsbp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void lsbp(AstNodeExpr* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* msbp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), NodeExpr); } \
    void msbp(AstNodeExpr* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeReadWriteMem::filenamep; \
    using AstNodeReadWriteMem::memp; \
    using AstNodeReadWriteMem::lsbp; \
    using AstNodeReadWriteMem::msbp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ReadMem(...) AstNodeReadWriteMem(VNType::ReadMem, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRealToBits \
    AstRealToBits* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRealToBits*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRealToBits* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRealToBits*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRealToBits* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRealToBits*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRealToBits* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRealToBits*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRealToBits* clonep() const { return static_cast<AstRealToBits*>(AstNode::clonep()); } \
    AstRealToBits* addNext(AstRealToBits* nodep) { return static_cast<AstRealToBits*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRealToBits(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_RealToBits(...) AstNodeUniop(VNType::RealToBits, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRedAnd \
    AstRedAnd* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRedAnd*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRedAnd* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRedAnd*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRedAnd* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRedAnd*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRedAnd* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRedAnd*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRedAnd* clonep() const { return static_cast<AstRedAnd*>(AstNode::clonep()); } \
    AstRedAnd* addNext(AstRedAnd* nodep) { return static_cast<AstRedAnd*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRedAnd(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_RedAnd(...) AstNodeUniop(VNType::RedAnd, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRedOr \
    AstRedOr* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRedOr*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRedOr* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRedOr*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRedOr* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRedOr*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRedOr* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRedOr*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRedOr* clonep() const { return static_cast<AstRedOr*>(AstNode::clonep()); } \
    AstRedOr* addNext(AstRedOr* nodep) { return static_cast<AstRedOr*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRedOr(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_RedOr(...) AstNodeUniop(VNType::RedOr, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRedXor \
    AstRedXor* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRedXor*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRedXor* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRedXor*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRedXor* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRedXor*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRedXor* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRedXor*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRedXor* clonep() const { return static_cast<AstRedXor*>(AstNode::clonep()); } \
    AstRedXor* addNext(AstRedXor* nodep) { return static_cast<AstRedXor*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRedXor(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_RedXor(...) AstNodeUniop(VNType::RedXor, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRefDType \
private: \
    AstTypedef* m_typedefp = nullptr;    AstNodeDType* m_refDTypep = nullptr;    AstNodeModule* m_classOrPackagep = nullptr;public: \
    AstRefDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRefDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRefDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRefDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRefDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRefDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRefDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRefDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRefDType* clonep() const { return static_cast<AstRefDType*>(AstNode::clonep()); } \
    AstRefDType* addNext(AstRefDType* nodep) { return static_cast<AstRefDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRefDType(*this); } \
    AstNode* typeofp() const VL_MT_STABLE { return op1p(); } \
    void typeofp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* classOrPackageOpp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void classOrPackageOpp(AstNodeExpr* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstPin* paramsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), Pin); } \
    void addParamsp(AstPin* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_RefDType(...) AstNodeDType(VNType::RefDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRelease \
    AstRelease* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRelease*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRelease* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRelease*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRelease* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRelease*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRelease* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRelease*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRelease* clonep() const { return static_cast<AstRelease*>(AstNode::clonep()); } \
    AstRelease* addNext(AstRelease* nodep) { return static_cast<AstRelease*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRelease(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Release(...) AstNodeStmt(VNType::Release, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRepeat \
    AstRepeat* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRepeat*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRepeat* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRepeat*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRepeat* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRepeat*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRepeat* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRepeat*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRepeat* clonep() const { return static_cast<AstRepeat*>(AstNode::clonep()); } \
    AstRepeat* addNext(AstRepeat* nodep) { return static_cast<AstRepeat*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRepeat(*this); } \
    AstNodeExpr* countp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void countp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Repeat(...) AstNodeStmt(VNType::Repeat, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstReplicate \
    AstReplicate* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstReplicate*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstReplicate* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstReplicate*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstReplicate* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstReplicate*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstReplicate* cloneTreePure(bool cloneNext) { \
        return static_cast<AstReplicate*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstReplicate* clonep() const { return static_cast<AstReplicate*>(AstNode::clonep()); } \
    AstReplicate* addNext(AstReplicate* nodep) { return static_cast<AstReplicate*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstReplicate(*this); } \
    AstNodeExpr* srcp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void srcp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* countp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void countp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Replicate(...) AstNodeBiop(VNType::Replicate, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstReplicateN \
    AstReplicateN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstReplicateN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstReplicateN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstReplicateN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstReplicateN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstReplicateN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstReplicateN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstReplicateN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstReplicateN* clonep() const { return static_cast<AstReplicateN*>(AstNode::clonep()); } \
    AstReplicateN* addNext(AstReplicateN* nodep) { return static_cast<AstReplicateN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstReplicateN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ReplicateN(...) AstNodeBiop(VNType::ReplicateN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRequireDType \
    AstRequireDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRequireDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRequireDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRequireDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRequireDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRequireDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRequireDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRequireDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRequireDType* clonep() const { return static_cast<AstRequireDType*>(AstNode::clonep()); } \
    AstRequireDType* addNext(AstRequireDType* nodep) { return static_cast<AstRequireDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRequireDType(*this); } \
    AstNode* lhsp() const VL_MT_STABLE { return op1p(); } \
    void lhsp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_RequireDType(...) AstNodeDType(VNType::RequireDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstResizeLValue \
    AstResizeLValue* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstResizeLValue*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstResizeLValue* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstResizeLValue*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstResizeLValue* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstResizeLValue*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstResizeLValue* cloneTreePure(bool cloneNext) { \
        return static_cast<AstResizeLValue*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstResizeLValue* clonep() const { return static_cast<AstResizeLValue*>(AstNode::clonep()); } \
    AstResizeLValue* addNext(AstResizeLValue* nodep) { return static_cast<AstResizeLValue*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstResizeLValue(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ResizeLValue(...) AstNodeUniop(VNType::ResizeLValue, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRestrict \
    AstRestrict* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRestrict*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRestrict* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRestrict*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRestrict* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRestrict*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRestrict* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRestrict*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRestrict* clonep() const { return static_cast<AstRestrict*>(AstNode::clonep()); } \
    AstRestrict* addNext(AstRestrict* nodep) { return static_cast<AstRestrict*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRestrict(*this); } \
    AstNode* propp() const VL_MT_STABLE { return op1p(); } \
    void propp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* passsp() const VL_MT_STABLE { return op4p(); } \
    void addPasssp(AstNode* nodep) { addNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeCoverOrAssert::propp; \
    using AstNodeCoverOrAssert::sentreep; \
    using AstNodeCoverOrAssert::passsp; \
    using AstNodeCoverOrAssert::addPasssp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Restrict(...) AstNodeCoverOrAssert(VNType::Restrict, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstReturn \
    AstReturn* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstReturn*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstReturn* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstReturn*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstReturn* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstReturn*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstReturn* cloneTreePure(bool cloneNext) { \
        return static_cast<AstReturn*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstReturn* clonep() const { return static_cast<AstReturn*>(AstNode::clonep()); } \
    AstReturn* addNext(AstReturn* nodep) { return static_cast<AstReturn*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstReturn(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Return(...) AstNodeStmt(VNType::Return, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRising \
    AstRising* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRising*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRising* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRising*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRising* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRising*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRising* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRising*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRising* clonep() const { return static_cast<AstRising*>(AstNode::clonep()); } \
    AstRising* addNext(AstRising* nodep) { return static_cast<AstRising*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRising(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Rising(...) AstNodeExpr(VNType::Rising, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstRose \
    AstRose* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRose*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstRose* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstRose*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstRose* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstRose*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstRose* cloneTreePure(bool cloneNext) { \
        return static_cast<AstRose*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstRose* clonep() const { return static_cast<AstRose*>(AstNode::clonep()); } \
    AstRose* addNext(AstRose* nodep) { return static_cast<AstRose*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstRose(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Rose(...) AstNodeExpr(VNType::Rose, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSExpr \
    AstSExpr* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSExpr*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSExpr* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSExpr*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSExpr* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSExpr*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSExpr* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSExpr*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSExpr* clonep() const { return static_cast<AstSExpr*>(AstNode::clonep()); } \
    AstSExpr* addNext(AstSExpr* nodep) { return static_cast<AstSExpr*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSExpr(*this); } \
    AstNodeExpr* preExprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void preExprp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeStmt* delayp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeStmt); } \
    void delayp(AstNodeStmt* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SExpr(...) AstNodeExpr(VNType::SExpr, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSFormat \
    AstSFormat* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSFormat*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSFormat* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSFormat*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSFormat* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSFormat*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSFormat* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSFormat*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSFormat* clonep() const { return static_cast<AstSFormat*>(AstNode::clonep()); } \
    AstSFormat* addNext(AstSFormat* nodep) { return static_cast<AstSFormat*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSFormat(*this); } \
    AstSFormatF* fmtp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), SFormatF); } \
    void fmtp(AstSFormatF* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SFormat(...) AstNodeStmt(VNType::SFormat, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSFormatF \
    AstSFormatF* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSFormatF*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSFormatF* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSFormatF*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSFormatF* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSFormatF*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSFormatF* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSFormatF*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSFormatF* clonep() const { return static_cast<AstSFormatF*>(AstNode::clonep()); } \
    AstSFormatF* addNext(AstSFormatF* nodep) { return static_cast<AstSFormatF*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSFormatF(*this); } \
    AstNodeExpr* exprsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void addExprsp(AstNodeExpr* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScopeName* scopeNamep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), ScopeName); } \
    void scopeNamep(AstScopeName* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SFormatF(...) AstNodeExpr(VNType::SFormatF, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSScanF \
    AstSScanF* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSScanF*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSScanF* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSScanF*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSScanF* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSScanF*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSScanF* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSScanF*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSScanF* clonep() const { return static_cast<AstSScanF*>(AstNode::clonep()); } \
    AstSScanF* addNext(AstSScanF* nodep) { return static_cast<AstSScanF*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSScanF(*this); } \
    AstNode* exprsp() const VL_MT_STABLE { return op1p(); } \
    void addExprsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* fromp() const VL_MT_STABLE { return op2p(); } \
    void fromp(AstNode* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SScanF(...) AstNodeExpr(VNType::SScanF, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSampleQueueDType \
private: \
    AstNodeDType* m_refDTypep = nullptr;public: \
    AstSampleQueueDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSampleQueueDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSampleQueueDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSampleQueueDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSampleQueueDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSampleQueueDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSampleQueueDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSampleQueueDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSampleQueueDType* clonep() const { return static_cast<AstSampleQueueDType*>(AstNode::clonep()); } \
    AstSampleQueueDType* addNext(AstSampleQueueDType* nodep) { return static_cast<AstSampleQueueDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSampleQueueDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SampleQueueDType(...) AstNodeDType(VNType::SampleQueueDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSampled \
    AstSampled* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSampled*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSampled* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSampled*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSampled* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSampled*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSampled* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSampled*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSampled* clonep() const { return static_cast<AstSampled*>(AstNode::clonep()); } \
    AstSampled* addNext(AstSampled* nodep) { return static_cast<AstSampled*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSampled(*this); } \
    AstNode* exprp() const VL_MT_STABLE { return op1p(); } \
    void exprp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Sampled(...) AstNodeExpr(VNType::Sampled, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstScope \
private: \
    AstScope* m_aboveScopep = nullptr;    AstCell* m_aboveCellp = nullptr;    AstNodeModule* m_modp = nullptr;public: \
    AstScope* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstScope*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstScope* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstScope*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstScope* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstScope*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstScope* cloneTreePure(bool cloneNext) { \
        return static_cast<AstScope*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstScope* clonep() const { return static_cast<AstScope*>(AstNode::clonep()); } \
    AstScope* addNext(AstScope* nodep) { return static_cast<AstScope*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstScope(*this); } \
    AstVarScope* varsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), VarScope); } \
    void addVarsp(AstVarScope* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* blocksp() const VL_MT_STABLE { return op2p(); } \
    void addBlocksp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstCellInlineScope* inlinesp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), CellInlineScope); } \
    void addInlinesp(AstCellInlineScope* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Scope(...) AstNode(VNType::Scope, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstScopeName \
    AstScopeName* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstScopeName*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstScopeName* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstScopeName*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstScopeName* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstScopeName*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstScopeName* cloneTreePure(bool cloneNext) { \
        return static_cast<AstScopeName*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstScopeName* clonep() const { return static_cast<AstScopeName*>(AstNode::clonep()); } \
    AstScopeName* addNext(AstScopeName* nodep) { return static_cast<AstScopeName*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstScopeName(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ScopeName(...) AstNodeExpr(VNType::ScopeName, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSel \
    AstSel* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSel*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSel* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSel*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSel* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSel*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSel* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSel*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSel* clonep() const { return static_cast<AstSel*>(AstNode::clonep()); } \
    AstSel* addNext(AstSel* nodep) { return static_cast<AstSel*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSel(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* lsbp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void lsbp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Sel(...) AstNodeBiop(VNType::Sel, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSelBit \
    AstSelBit* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSelBit*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSelBit* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSelBit*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSelBit* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSelBit*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSelBit* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSelBit*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSelBit* clonep() const { return static_cast<AstSelBit*>(AstNode::clonep()); } \
    AstSelBit* addNext(AstSelBit* nodep) { return static_cast<AstSelBit*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSelBit(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* bitp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void bitp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstAttrOf* attrp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), AttrOf); } \
    void attrp(AstAttrOf* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodePreSel::fromp; \
    using AstNodePreSel::rhsp; \
    using AstNodePreSel::thsp; \
    using AstNodePreSel::attrp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_SelBit(...) AstNodePreSel(VNType::SelBit, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSelExtract \
    AstSelExtract* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSelExtract*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSelExtract* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSelExtract*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSelExtract* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSelExtract*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSelExtract* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSelExtract*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSelExtract* clonep() const { return static_cast<AstSelExtract*>(AstNode::clonep()); } \
    AstSelExtract* addNext(AstSelExtract* nodep) { return static_cast<AstSelExtract*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSelExtract(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* leftp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void leftp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rightp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void rightp(AstNodeExpr* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstAttrOf* attrp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), AttrOf); } \
    void attrp(AstAttrOf* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodePreSel::fromp; \
    using AstNodePreSel::rhsp; \
    using AstNodePreSel::thsp; \
    using AstNodePreSel::attrp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_SelExtract(...) AstNodePreSel(VNType::SelExtract, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSelLoopVars \
    AstSelLoopVars* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSelLoopVars*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSelLoopVars* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSelLoopVars*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSelLoopVars* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSelLoopVars*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSelLoopVars* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSelLoopVars*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSelLoopVars* clonep() const { return static_cast<AstSelLoopVars*>(AstNode::clonep()); } \
    AstSelLoopVars* addNext(AstSelLoopVars* nodep) { return static_cast<AstSelLoopVars*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSelLoopVars(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* elementsp() const VL_MT_STABLE { return op2p(); } \
    void addElementsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SelLoopVars(...) AstNodeExpr(VNType::SelLoopVars, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSelMinus \
    AstSelMinus* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSelMinus*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSelMinus* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSelMinus*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSelMinus* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSelMinus*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSelMinus* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSelMinus*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSelMinus* clonep() const { return static_cast<AstSelMinus*>(AstNode::clonep()); } \
    AstSelMinus* addNext(AstSelMinus* nodep) { return static_cast<AstSelMinus*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSelMinus(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* bitp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void bitp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* widthp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void widthp(AstNodeExpr* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstAttrOf* attrp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), AttrOf); } \
    void attrp(AstAttrOf* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodePreSel::fromp; \
    using AstNodePreSel::rhsp; \
    using AstNodePreSel::thsp; \
    using AstNodePreSel::attrp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_SelMinus(...) AstNodePreSel(VNType::SelMinus, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSelPlus \
    AstSelPlus* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSelPlus*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSelPlus* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSelPlus*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSelPlus* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSelPlus*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSelPlus* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSelPlus*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSelPlus* clonep() const { return static_cast<AstSelPlus*>(AstNode::clonep()); } \
    AstSelPlus* addNext(AstSelPlus* nodep) { return static_cast<AstSelPlus*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSelPlus(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* bitp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void bitp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* widthp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void widthp(AstNodeExpr* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstAttrOf* attrp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), AttrOf); } \
    void attrp(AstAttrOf* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodePreSel::fromp; \
    using AstNodePreSel::rhsp; \
    using AstNodePreSel::thsp; \
    using AstNodePreSel::attrp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_SelPlus(...) AstNodePreSel(VNType::SelPlus, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSenItem \
    AstSenItem* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSenItem*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSenItem* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSenItem*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSenItem* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSenItem*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSenItem* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSenItem*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSenItem* clonep() const { return static_cast<AstSenItem*>(AstNode::clonep()); } \
    AstSenItem* addNext(AstSenItem* nodep) { return static_cast<AstSenItem*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSenItem(*this); } \
    AstNodeExpr* sensp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void sensp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* condp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void condp(AstNodeExpr* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SenItem(...) AstNode(VNType::SenItem, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSenTree \
    AstSenTree* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSenTree*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSenTree* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSenTree*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSenTree* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSenTree*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSenTree* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSenTree*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSenTree* clonep() const { return static_cast<AstSenTree*>(AstNode::clonep()); } \
    AstSenTree* addNext(AstSenTree* nodep) { return static_cast<AstSenTree*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSenTree(*this); } \
    AstSenItem* sensesp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), SenItem); } \
    void addSensesp(AstSenItem* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SenTree(...) AstNode(VNType::SenTree, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSequence \
    AstSequence* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSequence*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSequence* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSequence*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSequence* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSequence*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSequence* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSequence*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSequence* clonep() const { return static_cast<AstSequence*>(AstNode::clonep()); } \
    AstSequence* addNext(AstSequence* nodep) { return static_cast<AstSequence*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSequence(*this); } \
    AstNode* fvarp() const VL_MT_STABLE { return op1p(); } \
    void fvarp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* classOrPackagep() const VL_MT_STABLE { return op2p(); } \
    void classOrPackagep(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op3p(); } \
    void addStmtsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScopeName* scopeNamep() const VL_MT_STABLE { return VN_DBG_AS(op4p(), ScopeName); } \
    void scopeNamep(AstScopeName* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeFTask::fvarp; \
    using AstNodeFTask::classOrPackagep; \
    using AstNodeFTask::stmtsp; \
    using AstNodeFTask::addStmtsp; \
    using AstNodeFTask::scopeNamep; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Sequence(...) AstNodeFTask(VNType::Sequence, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSetAssoc \
    AstSetAssoc* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSetAssoc*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSetAssoc* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSetAssoc*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSetAssoc* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSetAssoc*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSetAssoc* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSetAssoc*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSetAssoc* clonep() const { return static_cast<AstSetAssoc*>(AstNode::clonep()); } \
    AstSetAssoc* addNext(AstSetAssoc* nodep) { return static_cast<AstSetAssoc*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSetAssoc(*this); } \
    AstNode* lhsp() const VL_MT_STABLE { return op1p(); } \
    void lhsp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* keyp() const VL_MT_STABLE { return op2p(); } \
    void keyp(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* valuep() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void valuep(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SetAssoc(...) AstNodeExpr(VNType::SetAssoc, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSetWildcard \
    AstSetWildcard* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSetWildcard*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSetWildcard* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSetWildcard*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSetWildcard* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSetWildcard*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSetWildcard* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSetWildcard*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSetWildcard* clonep() const { return static_cast<AstSetWildcard*>(AstNode::clonep()); } \
    AstSetWildcard* addNext(AstSetWildcard* nodep) { return static_cast<AstSetWildcard*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSetWildcard(*this); } \
    AstNode* lhsp() const VL_MT_STABLE { return op1p(); } \
    void lhsp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* keyp() const VL_MT_STABLE { return op2p(); } \
    void keyp(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* valuep() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void valuep(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SetWildcard(...) AstNodeExpr(VNType::SetWildcard, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSetuphold \
    AstSetuphold* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSetuphold*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSetuphold* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSetuphold*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSetuphold* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSetuphold*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSetuphold* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSetuphold*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSetuphold* clonep() const { return static_cast<AstSetuphold*>(AstNode::clonep()); } \
    AstSetuphold* addNext(AstSetuphold* nodep) { return static_cast<AstSetuphold*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSetuphold(*this); } \
    AstNodeExpr* refevp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void refevp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* dataevp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void dataevp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* delrefp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void delrefp(AstNodeExpr* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* deldatap() const VL_MT_STABLE { return VN_DBG_AS(op4p(), NodeExpr); } \
    void deldatap(AstNodeExpr* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Setuphold(...) AstNodeStmt(VNType::Setuphold, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstShiftL \
    AstShiftL* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstShiftL*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstShiftL* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstShiftL*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstShiftL* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstShiftL*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstShiftL* cloneTreePure(bool cloneNext) { \
        return static_cast<AstShiftL*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstShiftL* clonep() const { return static_cast<AstShiftL*>(AstNode::clonep()); } \
    AstShiftL* addNext(AstShiftL* nodep) { return static_cast<AstShiftL*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstShiftL(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ShiftL(...) AstNodeBiop(VNType::ShiftL, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstShiftLOvr \
    AstShiftLOvr* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstShiftLOvr*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstShiftLOvr* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstShiftLOvr*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstShiftLOvr* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstShiftLOvr*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstShiftLOvr* cloneTreePure(bool cloneNext) { \
        return static_cast<AstShiftLOvr*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstShiftLOvr* clonep() const { return static_cast<AstShiftLOvr*>(AstNode::clonep()); } \
    AstShiftLOvr* addNext(AstShiftLOvr* nodep) { return static_cast<AstShiftLOvr*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstShiftLOvr(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ShiftLOvr(...) AstNodeBiop(VNType::ShiftLOvr, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstShiftR \
    AstShiftR* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstShiftR*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstShiftR* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstShiftR*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstShiftR* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstShiftR*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstShiftR* cloneTreePure(bool cloneNext) { \
        return static_cast<AstShiftR*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstShiftR* clonep() const { return static_cast<AstShiftR*>(AstNode::clonep()); } \
    AstShiftR* addNext(AstShiftR* nodep) { return static_cast<AstShiftR*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstShiftR(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ShiftR(...) AstNodeBiop(VNType::ShiftR, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstShiftROvr \
    AstShiftROvr* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstShiftROvr*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstShiftROvr* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstShiftROvr*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstShiftROvr* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstShiftROvr*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstShiftROvr* cloneTreePure(bool cloneNext) { \
        return static_cast<AstShiftROvr*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstShiftROvr* clonep() const { return static_cast<AstShiftROvr*>(AstNode::clonep()); } \
    AstShiftROvr* addNext(AstShiftROvr* nodep) { return static_cast<AstShiftROvr*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstShiftROvr(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ShiftROvr(...) AstNodeBiop(VNType::ShiftROvr, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstShiftRS \
    AstShiftRS* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstShiftRS*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstShiftRS* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstShiftRS*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstShiftRS* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstShiftRS*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstShiftRS* cloneTreePure(bool cloneNext) { \
        return static_cast<AstShiftRS*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstShiftRS* clonep() const { return static_cast<AstShiftRS*>(AstNode::clonep()); } \
    AstShiftRS* addNext(AstShiftRS* nodep) { return static_cast<AstShiftRS*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstShiftRS(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ShiftRS(...) AstNodeBiop(VNType::ShiftRS, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstShiftRSOvr \
    AstShiftRSOvr* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstShiftRSOvr*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstShiftRSOvr* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstShiftRSOvr*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstShiftRSOvr* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstShiftRSOvr*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstShiftRSOvr* cloneTreePure(bool cloneNext) { \
        return static_cast<AstShiftRSOvr*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstShiftRSOvr* clonep() const { return static_cast<AstShiftRSOvr*>(AstNode::clonep()); } \
    AstShiftRSOvr* addNext(AstShiftRSOvr* nodep) { return static_cast<AstShiftRSOvr*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstShiftRSOvr(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ShiftRSOvr(...) AstNodeBiop(VNType::ShiftRSOvr, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSigned \
    AstSigned* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSigned*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSigned* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSigned*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSigned* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSigned*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSigned* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSigned*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSigned* clonep() const { return static_cast<AstSigned*>(AstNode::clonep()); } \
    AstSigned* addNext(AstSigned* nodep) { return static_cast<AstSigned*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSigned(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Signed(...) AstNodeUniop(VNType::Signed, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSinD \
    AstSinD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSinD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSinD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSinD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSinD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSinD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSinD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSinD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSinD* clonep() const { return static_cast<AstSinD*>(AstNode::clonep()); } \
    AstSinD* addNext(AstSinD* nodep) { return static_cast<AstSinD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSinD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_SinD(...) AstNodeSystemUniopD(VNType::SinD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSinhD \
    AstSinhD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSinhD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSinhD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSinhD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSinhD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSinhD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSinhD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSinhD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSinhD* clonep() const { return static_cast<AstSinhD*>(AstNode::clonep()); } \
    AstSinhD* addNext(AstSinhD* nodep) { return static_cast<AstSinhD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSinhD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_SinhD(...) AstNodeSystemUniopD(VNType::SinhD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSliceSel \
    AstSliceSel* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSliceSel*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSliceSel* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSliceSel*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSliceSel* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSliceSel*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSliceSel* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSliceSel*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSliceSel* clonep() const { return static_cast<AstSliceSel*>(AstNode::clonep()); } \
    AstSliceSel* addNext(AstSliceSel* nodep) { return static_cast<AstSliceSel*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSliceSel(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeTriop::lhsp; \
    using AstNodeTriop::rhsp; \
    using AstNodeTriop::thsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_SliceSel(...) AstNodeTriop(VNType::SliceSel, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSplitPlaceholder \
    AstSplitPlaceholder* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSplitPlaceholder*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSplitPlaceholder* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSplitPlaceholder*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSplitPlaceholder* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSplitPlaceholder*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSplitPlaceholder* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSplitPlaceholder*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSplitPlaceholder* clonep() const { return static_cast<AstSplitPlaceholder*>(AstNode::clonep()); } \
    AstSplitPlaceholder* addNext(AstSplitPlaceholder* nodep) { return static_cast<AstSplitPlaceholder*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSplitPlaceholder(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SplitPlaceholder(...) AstNodeStmt(VNType::SplitPlaceholder, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSqrtD \
    AstSqrtD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSqrtD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSqrtD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSqrtD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSqrtD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSqrtD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSqrtD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSqrtD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSqrtD* clonep() const { return static_cast<AstSqrtD*>(AstNode::clonep()); } \
    AstSqrtD* addNext(AstSqrtD* nodep) { return static_cast<AstSqrtD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSqrtD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_SqrtD(...) AstNodeSystemUniopD(VNType::SqrtD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstStable \
    AstStable* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStable*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstStable* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStable*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstStable* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstStable*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstStable* cloneTreePure(bool cloneNext) { \
        return static_cast<AstStable*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstStable* clonep() const { return static_cast<AstStable*>(AstNode::clonep()); } \
    AstStable* addNext(AstStable* nodep) { return static_cast<AstStable*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstStable(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstSenTree* sentreep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), SenTree); } \
    void sentreep(AstSenTree* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Stable(...) AstNodeExpr(VNType::Stable, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstStackTraceF \
    AstStackTraceF* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStackTraceF*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstStackTraceF* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStackTraceF*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstStackTraceF* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstStackTraceF*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstStackTraceF* cloneTreePure(bool cloneNext) { \
        return static_cast<AstStackTraceF*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstStackTraceF* clonep() const { return static_cast<AstStackTraceF*>(AstNode::clonep()); } \
    AstStackTraceF* addNext(AstStackTraceF* nodep) { return static_cast<AstStackTraceF*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstStackTraceF(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_StackTraceF(...) AstNodeExpr(VNType::StackTraceF, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstStackTraceT \
    AstStackTraceT* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStackTraceT*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstStackTraceT* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStackTraceT*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstStackTraceT* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstStackTraceT*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstStackTraceT* cloneTreePure(bool cloneNext) { \
        return static_cast<AstStackTraceT*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstStackTraceT* clonep() const { return static_cast<AstStackTraceT*>(AstNode::clonep()); } \
    AstStackTraceT* addNext(AstStackTraceT* nodep) { return static_cast<AstStackTraceT*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstStackTraceT(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_StackTraceT(...) AstNodeStmt(VNType::StackTraceT, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSteady \
    AstSteady* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSteady*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSteady* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSteady*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSteady* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSteady*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSteady* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSteady*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSteady* clonep() const { return static_cast<AstSteady*>(AstNode::clonep()); } \
    AstSteady* addNext(AstSteady* nodep) { return static_cast<AstSteady*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSteady(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Steady(...) AstNodeExpr(VNType::Steady, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstStmtExpr \
    AstStmtExpr* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStmtExpr*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstStmtExpr* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStmtExpr*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstStmtExpr* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstStmtExpr*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstStmtExpr* cloneTreePure(bool cloneNext) { \
        return static_cast<AstStmtExpr*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstStmtExpr* clonep() const { return static_cast<AstStmtExpr*>(AstNode::clonep()); } \
    AstStmtExpr* addNext(AstStmtExpr* nodep) { return static_cast<AstStmtExpr*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstStmtExpr(*this); } \
    AstNodeExpr* exprp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void exprp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_StmtExpr(...) AstNodeStmt(VNType::StmtExpr, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstStmtPragma \
    AstStmtPragma* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStmtPragma*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstStmtPragma* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStmtPragma*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstStmtPragma* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstStmtPragma*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstStmtPragma* cloneTreePure(bool cloneNext) { \
        return static_cast<AstStmtPragma*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstStmtPragma* clonep() const { return static_cast<AstStmtPragma*>(AstNode::clonep()); } \
    AstStmtPragma* addNext(AstStmtPragma* nodep) { return static_cast<AstStmtPragma*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstStmtPragma(*this); } \
    AstPragma* pragp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), Pragma); } \
    void pragp(AstPragma* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_StmtPragma(...) AstNodeStmt(VNType::StmtPragma, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstStop \
    AstStop* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStop*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstStop* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStop*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstStop* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstStop*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstStop* cloneTreePure(bool cloneNext) { \
        return static_cast<AstStop*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstStop* clonep() const { return static_cast<AstStop*>(AstNode::clonep()); } \
    AstStop* addNext(AstStop* nodep) { return static_cast<AstStop*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstStop(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Stop(...) AstNodeStmt(VNType::Stop, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstStreamDType \
    AstStreamDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStreamDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstStreamDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStreamDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstStreamDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstStreamDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstStreamDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstStreamDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstStreamDType* clonep() const { return static_cast<AstStreamDType*>(AstNode::clonep()); } \
    AstStreamDType* addNext(AstStreamDType* nodep) { return static_cast<AstStreamDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstStreamDType(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_StreamDType(...) AstNodeDType(VNType::StreamDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstStreamL \
    AstStreamL* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStreamL*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstStreamL* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStreamL*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstStreamL* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstStreamL*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstStreamL* cloneTreePure(bool cloneNext) { \
        return static_cast<AstStreamL*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstStreamL* clonep() const { return static_cast<AstStreamL*>(AstNode::clonep()); } \
    AstStreamL* addNext(AstStreamL* nodep) { return static_cast<AstStreamL*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstStreamL(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeStream::lhsp; \
    using AstNodeStream::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_StreamL(...) AstNodeStream(VNType::StreamL, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstStreamR \
    AstStreamR* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStreamR*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstStreamR* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStreamR*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstStreamR* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstStreamR*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstStreamR* cloneTreePure(bool cloneNext) { \
        return static_cast<AstStreamR*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstStreamR* clonep() const { return static_cast<AstStreamR*>(AstNode::clonep()); } \
    AstStreamR* addNext(AstStreamR* nodep) { return static_cast<AstStreamR*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstStreamR(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeStream::lhsp; \
    using AstNodeStream::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_StreamR(...) AstNodeStream(VNType::StreamR, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstStrengthSpec \
    AstStrengthSpec* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStrengthSpec*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstStrengthSpec* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStrengthSpec*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstStrengthSpec* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstStrengthSpec*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstStrengthSpec* cloneTreePure(bool cloneNext) { \
        return static_cast<AstStrengthSpec*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstStrengthSpec* clonep() const { return static_cast<AstStrengthSpec*>(AstNode::clonep()); } \
    AstStrengthSpec* addNext(AstStrengthSpec* nodep) { return static_cast<AstStrengthSpec*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstStrengthSpec(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_StrengthSpec(...) AstNode(VNType::StrengthSpec, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstStructDType \
    AstStructDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStructDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstStructDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStructDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstStructDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstStructDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstStructDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstStructDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstStructDType* clonep() const { return static_cast<AstStructDType*>(AstNode::clonep()); } \
    AstStructDType* addNext(AstStructDType* nodep) { return static_cast<AstStructDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstStructDType(*this); } \
    AstMemberDType* membersp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), MemberDType); } \
    void addMembersp(AstMemberDType* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUOrStructDType::membersp; \
    using AstNodeUOrStructDType::addMembersp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_StructDType(...) AstNodeUOrStructDType(VNType::StructDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstStructSel \
    AstStructSel* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStructSel*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstStructSel* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstStructSel*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstStructSel* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstStructSel*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstStructSel* cloneTreePure(bool cloneNext) { \
        return static_cast<AstStructSel*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstStructSel* clonep() const { return static_cast<AstStructSel*>(AstNode::clonep()); } \
    AstStructSel* addNext(AstStructSel* nodep) { return static_cast<AstStructSel*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstStructSel(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_StructSel(...) AstNodeExpr(VNType::StructSel, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSub \
    AstSub* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSub*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSub* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSub*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSub* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSub*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSub* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSub*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSub* clonep() const { return static_cast<AstSub*>(AstNode::clonep()); } \
    AstSub* addNext(AstSub* nodep) { return static_cast<AstSub*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSub(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Sub(...) AstNodeBiop(VNType::Sub, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSubD \
    AstSubD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSubD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSubD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSubD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSubD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSubD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSubD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSubD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSubD* clonep() const { return static_cast<AstSubD*>(AstNode::clonep()); } \
    AstSubD* addNext(AstSubD* nodep) { return static_cast<AstSubD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSubD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_SubD(...) AstNodeBiop(VNType::SubD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSubstrN \
    AstSubstrN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSubstrN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSubstrN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSubstrN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSubstrN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSubstrN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSubstrN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSubstrN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSubstrN* clonep() const { return static_cast<AstSubstrN*>(AstNode::clonep()); } \
    AstSubstrN* addNext(AstSubstrN* nodep) { return static_cast<AstSubstrN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSubstrN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* thsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void thsp(AstNodeExpr* nodep) { setOp3p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeTriop::lhsp; \
    using AstNodeTriop::rhsp; \
    using AstNodeTriop::thsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_SubstrN(...) AstNodeTriop(VNType::SubstrN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSysIgnore \
    AstSysIgnore* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSysIgnore*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSysIgnore* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSysIgnore*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSysIgnore* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSysIgnore*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSysIgnore* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSysIgnore*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSysIgnore* clonep() const { return static_cast<AstSysIgnore*>(AstNode::clonep()); } \
    AstSysIgnore* addNext(AstSysIgnore* nodep) { return static_cast<AstSysIgnore*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSysIgnore(*this); } \
    AstNode* exprsp() const VL_MT_STABLE { return op1p(); } \
    void addExprsp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SysIgnore(...) AstNodeExpr(VNType::SysIgnore, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSystemCSection \
    AstSystemCSection* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSystemCSection*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSystemCSection* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSystemCSection*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSystemCSection* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSystemCSection*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSystemCSection* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSystemCSection*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSystemCSection* clonep() const { return static_cast<AstSystemCSection*>(AstNode::clonep()); } \
    AstSystemCSection* addNext(AstSystemCSection* nodep) { return static_cast<AstSystemCSection*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSystemCSection(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SystemCSection(...) AstNode(VNType::SystemCSection, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSystemF \
    AstSystemF* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSystemF*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSystemF* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSystemF*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSystemF* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSystemF*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSystemF* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSystemF*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSystemF* clonep() const { return static_cast<AstSystemF*>(AstNode::clonep()); } \
    AstSystemF* addNext(AstSystemF* nodep) { return static_cast<AstSystemF*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSystemF(*this); } \
    AstNode* lhsp() const VL_MT_STABLE { return op1p(); } \
    void lhsp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SystemF(...) AstNodeExpr(VNType::SystemF, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstSystemT \
    AstSystemT* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSystemT*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstSystemT* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstSystemT*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstSystemT* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstSystemT*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstSystemT* cloneTreePure(bool cloneNext) { \
        return static_cast<AstSystemT*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstSystemT* clonep() const { return static_cast<AstSystemT*>(AstNode::clonep()); } \
    AstSystemT* addNext(AstSystemT* nodep) { return static_cast<AstSystemT*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstSystemT(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_SystemT(...) AstNodeStmt(VNType::SystemT, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTanD \
    AstTanD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTanD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTanD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTanD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTanD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTanD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTanD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTanD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTanD* clonep() const { return static_cast<AstTanD*>(AstNode::clonep()); } \
    AstTanD* addNext(AstTanD* nodep) { return static_cast<AstTanD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTanD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_TanD(...) AstNodeSystemUniopD(VNType::TanD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTanhD \
    AstTanhD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTanhD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTanhD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTanhD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTanhD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTanhD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTanhD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTanhD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTanhD* clonep() const { return static_cast<AstTanhD*>(AstNode::clonep()); } \
    AstTanhD* addNext(AstTanhD* nodep) { return static_cast<AstTanhD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTanhD(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSystemUniopD::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_TanhD(...) AstNodeSystemUniopD(VNType::TanhD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTask \
    AstTask* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTask*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTask* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTask*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTask* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTask*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTask* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTask*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTask* clonep() const { return static_cast<AstTask*>(AstNode::clonep()); } \
    AstTask* addNext(AstTask* nodep) { return static_cast<AstTask*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTask(*this); } \
    AstNode* fvarp() const VL_MT_STABLE { return op1p(); } \
    void fvarp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* classOrPackagep() const VL_MT_STABLE { return op2p(); } \
    void classOrPackagep(AstNode* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op3p(); } \
    void addStmtsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScopeName* scopeNamep() const VL_MT_STABLE { return VN_DBG_AS(op4p(), ScopeName); } \
    void scopeNamep(AstScopeName* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeFTask::fvarp; \
    using AstNodeFTask::classOrPackagep; \
    using AstNodeFTask::stmtsp; \
    using AstNodeFTask::addStmtsp; \
    using AstNodeFTask::scopeNamep; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Task(...) AstNodeFTask(VNType::Task, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTaskRef \
    AstTaskRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTaskRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTaskRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTaskRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTaskRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTaskRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTaskRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTaskRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTaskRef* clonep() const { return static_cast<AstTaskRef*>(AstNode::clonep()); } \
    AstTaskRef* addNext(AstTaskRef* nodep) { return static_cast<AstTaskRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTaskRef(*this); } \
    AstNode* namep() const VL_MT_STABLE { return op1p(); } \
    void namep(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* pinsp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void addPinsp(AstNodeExpr* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScopeName* scopeNamep() const VL_MT_STABLE { return VN_DBG_AS(op4p(), ScopeName); } \
    void scopeNamep(AstScopeName* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeFTaskRef::namep; \
    using AstNodeFTaskRef::pinsp; \
    using AstNodeFTaskRef::addPinsp; \
    using AstNodeFTaskRef::scopeNamep; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_TaskRef(...) AstNodeFTaskRef(VNType::TaskRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTestPlusArgs \
    AstTestPlusArgs* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTestPlusArgs*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTestPlusArgs* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTestPlusArgs*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTestPlusArgs* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTestPlusArgs*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTestPlusArgs* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTestPlusArgs*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTestPlusArgs* clonep() const { return static_cast<AstTestPlusArgs*>(AstNode::clonep()); } \
    AstTestPlusArgs* addNext(AstTestPlusArgs* nodep) { return static_cast<AstTestPlusArgs*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTestPlusArgs(*this); } \
    AstNode* searchp() const VL_MT_STABLE { return op1p(); } \
    void searchp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TestPlusArgs(...) AstNodeExpr(VNType::TestPlusArgs, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstText \
    AstText* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstText*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstText* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstText*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstText* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstText*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstText* cloneTreePure(bool cloneNext) { \
        return static_cast<AstText*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstText* clonep() const { return static_cast<AstText*>(AstNode::clonep()); } \
    AstText* addNext(AstText* nodep) { return static_cast<AstText*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstText(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Text(...) AstNode(VNType::Text, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTextBlock \
    AstTextBlock* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTextBlock*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTextBlock* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTextBlock*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTextBlock* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTextBlock*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTextBlock* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTextBlock*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTextBlock* clonep() const { return static_cast<AstTextBlock*>(AstNode::clonep()); } \
    AstTextBlock* addNext(AstTextBlock* nodep) { return static_cast<AstTextBlock*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTextBlock(*this); } \
    AstNode* nodesp() const VL_MT_STABLE { return op1p(); } \
    void addNodesp(AstNode* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TextBlock(...) AstNode(VNType::TextBlock, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstThisRef \
    AstThisRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstThisRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstThisRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstThisRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstThisRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstThisRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstThisRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstThisRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstThisRef* clonep() const { return static_cast<AstThisRef*>(AstNode::clonep()); } \
    AstThisRef* addNext(AstThisRef* nodep) { return static_cast<AstThisRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstThisRef(*this); } \
    AstClassRefDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), ClassRefDType); } \
    void childDTypep(AstClassRefDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ThisRef(...) AstNodeExpr(VNType::ThisRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTime \
    AstTime* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTime*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTime* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTime*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTime* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTime*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTime* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTime*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTime* clonep() const { return static_cast<AstTime*>(AstNode::clonep()); } \
    AstTime* addNext(AstTime* nodep) { return static_cast<AstTime*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTime(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Time(...) AstNodeTermop(VNType::Time, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTimeD \
    AstTimeD* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTimeD*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTimeD* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTimeD*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTimeD* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTimeD*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTimeD* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTimeD*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTimeD* clonep() const { return static_cast<AstTimeD*>(AstNode::clonep()); } \
    AstTimeD* addNext(AstTimeD* nodep) { return static_cast<AstTimeD*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTimeD(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TimeD(...) AstNodeTermop(VNType::TimeD, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTimeFormat \
    AstTimeFormat* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTimeFormat*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTimeFormat* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTimeFormat*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTimeFormat* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTimeFormat*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTimeFormat* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTimeFormat*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTimeFormat* clonep() const { return static_cast<AstTimeFormat*>(AstNode::clonep()); } \
    AstTimeFormat* addNext(AstTimeFormat* nodep) { return static_cast<AstTimeFormat*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTimeFormat(*this); } \
    AstNodeExpr* unitsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void unitsp(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* precisionp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void precisionp(AstNodeExpr* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* suffixp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void suffixp(AstNodeExpr* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* widthp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), NodeExpr); } \
    void widthp(AstNodeExpr* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TimeFormat(...) AstNodeStmt(VNType::TimeFormat, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTimeImport \
    AstTimeImport* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTimeImport*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTimeImport* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTimeImport*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTimeImport* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTimeImport*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTimeImport* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTimeImport*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTimeImport* clonep() const { return static_cast<AstTimeImport*>(AstNode::clonep()); } \
    AstTimeImport* addNext(AstTimeImport* nodep) { return static_cast<AstTimeImport*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTimeImport(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_TimeImport(...) AstNodeUniop(VNType::TimeImport, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTimePrecision \
    AstTimePrecision* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTimePrecision*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTimePrecision* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTimePrecision*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTimePrecision* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTimePrecision*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTimePrecision* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTimePrecision*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTimePrecision* clonep() const { return static_cast<AstTimePrecision*>(AstNode::clonep()); } \
    AstTimePrecision* addNext(AstTimePrecision* nodep) { return static_cast<AstTimePrecision*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTimePrecision(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TimePrecision(...) AstNodeExpr(VNType::TimePrecision, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTimeUnit \
    AstTimeUnit* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTimeUnit*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTimeUnit* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTimeUnit*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTimeUnit* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTimeUnit*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTimeUnit* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTimeUnit*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTimeUnit* clonep() const { return static_cast<AstTimeUnit*>(AstNode::clonep()); } \
    AstTimeUnit* addNext(AstTimeUnit* nodep) { return static_cast<AstTimeUnit*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTimeUnit(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TimeUnit(...) AstNodeExpr(VNType::TimeUnit, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstToLowerN \
    AstToLowerN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstToLowerN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstToLowerN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstToLowerN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstToLowerN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstToLowerN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstToLowerN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstToLowerN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstToLowerN* clonep() const { return static_cast<AstToLowerN*>(AstNode::clonep()); } \
    AstToLowerN* addNext(AstToLowerN* nodep) { return static_cast<AstToLowerN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstToLowerN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ToLowerN(...) AstNodeUniop(VNType::ToLowerN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstToStringN \
    AstToStringN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstToStringN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstToStringN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstToStringN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstToStringN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstToStringN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstToStringN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstToStringN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstToStringN* clonep() const { return static_cast<AstToStringN*>(AstNode::clonep()); } \
    AstToStringN* addNext(AstToStringN* nodep) { return static_cast<AstToStringN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstToStringN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ToStringN(...) AstNodeUniop(VNType::ToStringN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstToUpperN \
    AstToUpperN* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstToUpperN*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstToUpperN* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstToUpperN*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstToUpperN* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstToUpperN*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstToUpperN* cloneTreePure(bool cloneNext) { \
        return static_cast<AstToUpperN*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstToUpperN* clonep() const { return static_cast<AstToUpperN*>(AstNode::clonep()); } \
    AstToUpperN* addNext(AstToUpperN* nodep) { return static_cast<AstToUpperN*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstToUpperN(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_ToUpperN(...) AstNodeUniop(VNType::ToUpperN, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTopScope \
    AstTopScope* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTopScope*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTopScope* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTopScope*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTopScope* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTopScope*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTopScope* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTopScope*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTopScope* clonep() const { return static_cast<AstTopScope*>(AstNode::clonep()); } \
    AstTopScope* addNext(AstTopScope* nodep) { return static_cast<AstTopScope*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTopScope(*this); } \
    AstSenTree* senTreesp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), SenTree); } \
    void addSenTreesp(AstSenTree* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstScope* scopep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), Scope); } \
    void scopep(AstScope* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TopScope(...) AstNode(VNType::TopScope, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTraceDecl \
    AstTraceDecl* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTraceDecl*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTraceDecl* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTraceDecl*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTraceDecl* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTraceDecl*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTraceDecl* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTraceDecl*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTraceDecl* clonep() const { return static_cast<AstTraceDecl*>(AstNode::clonep()); } \
    AstTraceDecl* addNext(AstTraceDecl* nodep) { return static_cast<AstTraceDecl*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTraceDecl(*this); } \
    AstNodeExpr* valuep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void valuep(AstNodeExpr* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TraceDecl(...) AstNodeStmt(VNType::TraceDecl, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTraceInc \
private: \
    AstTraceDecl* m_declp = nullptr;public: \
    AstTraceInc* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTraceInc*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTraceInc* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTraceInc*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTraceInc* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTraceInc*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTraceInc* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTraceInc*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTraceInc* clonep() const { return static_cast<AstTraceInc*>(AstNode::clonep()); } \
    AstTraceInc* addNext(AstTraceInc* nodep) { return static_cast<AstTraceInc*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTraceInc(*this); } \
    AstNodeExpr* valuep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void valuep(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TraceInc(...) AstNodeStmt(VNType::TraceInc, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTracePopPrefix \
    AstTracePopPrefix* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTracePopPrefix*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTracePopPrefix* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTracePopPrefix*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTracePopPrefix* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTracePopPrefix*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTracePopPrefix* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTracePopPrefix*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTracePopPrefix* clonep() const { return static_cast<AstTracePopPrefix*>(AstNode::clonep()); } \
    AstTracePopPrefix* addNext(AstTracePopPrefix* nodep) { return static_cast<AstTracePopPrefix*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTracePopPrefix(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TracePopPrefix(...) AstNodeStmt(VNType::TracePopPrefix, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTracePushPrefix \
    AstTracePushPrefix* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTracePushPrefix*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTracePushPrefix* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTracePushPrefix*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTracePushPrefix* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTracePushPrefix*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTracePushPrefix* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTracePushPrefix*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTracePushPrefix* clonep() const { return static_cast<AstTracePushPrefix*>(AstNode::clonep()); } \
    AstTracePushPrefix* addNext(AstTracePushPrefix* nodep) { return static_cast<AstTracePushPrefix*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTracePushPrefix(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TracePushPrefix(...) AstNodeStmt(VNType::TracePushPrefix, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTypeTable \
private: \
    AstConstraintRefDType* m_constraintRefp = nullptr;    AstEmptyQueueDType* m_emptyQueuep = nullptr;    AstQueueDType* m_queueIndexp = nullptr;    AstStreamDType* m_streamp = nullptr;    AstVoidDType* m_voidp = nullptr;public: \
    AstTypeTable* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTypeTable*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTypeTable* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTypeTable*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTypeTable* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTypeTable*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTypeTable* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTypeTable*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTypeTable* clonep() const { return static_cast<AstTypeTable*>(AstNode::clonep()); } \
    AstTypeTable* addNext(AstTypeTable* nodep) { return static_cast<AstTypeTable*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTypeTable(*this); } \
    AstNodeDType* typesp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void addTypesp(AstNodeDType* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TypeTable(...) AstNode(VNType::TypeTable, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTypedef \
    AstTypedef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTypedef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTypedef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTypedef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTypedef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTypedef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTypedef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTypedef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTypedef* clonep() const { return static_cast<AstTypedef*>(AstNode::clonep()); } \
    AstTypedef* addNext(AstTypedef* nodep) { return static_cast<AstTypedef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTypedef(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* attrsp() const VL_MT_STABLE { return op4p(); } \
    void addAttrsp(AstNode* nodep) { addNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Typedef(...) AstNode(VNType::Typedef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstTypedefFwd \
    AstTypedefFwd* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTypedefFwd*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstTypedefFwd* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstTypedefFwd*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstTypedefFwd* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstTypedefFwd*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstTypedefFwd* cloneTreePure(bool cloneNext) { \
        return static_cast<AstTypedefFwd*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstTypedefFwd* clonep() const { return static_cast<AstTypedefFwd*>(AstNode::clonep()); } \
    AstTypedefFwd* addNext(AstTypedefFwd* nodep) { return static_cast<AstTypedefFwd*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstTypedefFwd(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_TypedefFwd(...) AstNode(VNType::TypedefFwd, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstURandomRange \
    AstURandomRange* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstURandomRange*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstURandomRange* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstURandomRange*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstURandomRange* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstURandomRange*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstURandomRange* cloneTreePure(bool cloneNext) { \
        return static_cast<AstURandomRange*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstURandomRange* clonep() const { return static_cast<AstURandomRange*>(AstNode::clonep()); } \
    AstURandomRange* addNext(AstURandomRange* nodep) { return static_cast<AstURandomRange*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstURandomRange(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiop::lhsp; \
    using AstNodeBiop::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_URandomRange(...) AstNodeBiop(VNType::URandomRange, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstUdpTable \
    AstUdpTable* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUdpTable*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstUdpTable* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUdpTable*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstUdpTable* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstUdpTable*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstUdpTable* cloneTreePure(bool cloneNext) { \
        return static_cast<AstUdpTable*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstUdpTable* clonep() const { return static_cast<AstUdpTable*>(AstNode::clonep()); } \
    AstUdpTable* addNext(AstUdpTable* nodep) { return static_cast<AstUdpTable*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstUdpTable(*this); } \
    AstUdpTableLine* linesp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), UdpTableLine); } \
    void addLinesp(AstUdpTableLine* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_UdpTable(...) AstNode(VNType::UdpTable, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstUdpTableLine \
    AstUdpTableLine* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUdpTableLine*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstUdpTableLine* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUdpTableLine*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstUdpTableLine* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstUdpTableLine*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstUdpTableLine* cloneTreePure(bool cloneNext) { \
        return static_cast<AstUdpTableLine*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstUdpTableLine* clonep() const { return static_cast<AstUdpTableLine*>(AstNode::clonep()); } \
    AstUdpTableLine* addNext(AstUdpTableLine* nodep) { return static_cast<AstUdpTableLine*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstUdpTableLine(*this); } \
    AstUdpTableLineVal* iFieldsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), UdpTableLineVal); } \
    void addIFieldsp(AstUdpTableLineVal* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstUdpTableLineVal* oFieldsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), UdpTableLineVal); } \
    void addOFieldsp(AstUdpTableLineVal* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_UdpTableLine(...) AstNode(VNType::UdpTableLine, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstUdpTableLineVal \
    AstUdpTableLineVal* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUdpTableLineVal*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstUdpTableLineVal* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUdpTableLineVal*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstUdpTableLineVal* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstUdpTableLineVal*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstUdpTableLineVal* cloneTreePure(bool cloneNext) { \
        return static_cast<AstUdpTableLineVal*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstUdpTableLineVal* clonep() const { return static_cast<AstUdpTableLineVal*>(AstNode::clonep()); } \
    AstUdpTableLineVal* addNext(AstUdpTableLineVal* nodep) { return static_cast<AstUdpTableLineVal*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstUdpTableLineVal(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_UdpTableLineVal(...) AstNode(VNType::UdpTableLineVal, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstUnbounded \
    AstUnbounded* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnbounded*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstUnbounded* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnbounded*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstUnbounded* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstUnbounded*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstUnbounded* cloneTreePure(bool cloneNext) { \
        return static_cast<AstUnbounded*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstUnbounded* clonep() const { return static_cast<AstUnbounded*>(AstNode::clonep()); } \
    AstUnbounded* addNext(AstUnbounded* nodep) { return static_cast<AstUnbounded*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstUnbounded(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Unbounded(...) AstNodeExpr(VNType::Unbounded, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstUnionDType \
    AstUnionDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnionDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstUnionDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnionDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstUnionDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstUnionDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstUnionDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstUnionDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstUnionDType* clonep() const { return static_cast<AstUnionDType*>(AstNode::clonep()); } \
    AstUnionDType* addNext(AstUnionDType* nodep) { return static_cast<AstUnionDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstUnionDType(*this); } \
    AstMemberDType* membersp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), MemberDType); } \
    void addMembersp(AstMemberDType* nodep) { addNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUOrStructDType::membersp; \
    using AstNodeUOrStructDType::addMembersp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_UnionDType(...) AstNodeUOrStructDType(VNType::UnionDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstUnlinkedRef \
    AstUnlinkedRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnlinkedRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstUnlinkedRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnlinkedRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstUnlinkedRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstUnlinkedRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstUnlinkedRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstUnlinkedRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstUnlinkedRef* clonep() const { return static_cast<AstUnlinkedRef*>(AstNode::clonep()); } \
    AstUnlinkedRef* addNext(AstUnlinkedRef* nodep) { return static_cast<AstUnlinkedRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstUnlinkedRef(*this); } \
    AstNode* refp() const VL_MT_STABLE { return op1p(); } \
    void refp(AstNode* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* cellrefp() const VL_MT_STABLE { return op2p(); } \
    void cellrefp(AstNode* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_UnlinkedRef(...) AstNodeExpr(VNType::UnlinkedRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstUnpackArrayDType \
    AstUnpackArrayDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnpackArrayDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstUnpackArrayDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnpackArrayDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstUnpackArrayDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstUnpackArrayDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstUnpackArrayDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstUnpackArrayDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstUnpackArrayDType* clonep() const { return static_cast<AstUnpackArrayDType*>(AstNode::clonep()); } \
    AstUnpackArrayDType* addNext(AstUnpackArrayDType* nodep) { return static_cast<AstUnpackArrayDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstUnpackArrayDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstRange* rangep() const VL_MT_STABLE { return VN_DBG_AS(op2p(), Range); } \
    void rangep(AstRange* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeArrayDType::childDTypep; \
    using AstNodeArrayDType::rangep; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_UnpackArrayDType(...) AstNodeArrayDType(VNType::UnpackArrayDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstUnsigned \
    AstUnsigned* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnsigned*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstUnsigned* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnsigned*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstUnsigned* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstUnsigned*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstUnsigned* cloneTreePure(bool cloneNext) { \
        return static_cast<AstUnsigned*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstUnsigned* clonep() const { return static_cast<AstUnsigned*>(AstNode::clonep()); } \
    AstUnsigned* addNext(AstUnsigned* nodep) { return static_cast<AstUnsigned*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstUnsigned(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeUniop::lhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Unsigned(...) AstNodeUniop(VNType::Unsigned, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstUnsizedArrayDType \
private: \
    AstNodeDType* m_refDTypep = nullptr;public: \
    AstUnsizedArrayDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnsizedArrayDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstUnsizedArrayDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnsizedArrayDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstUnsizedArrayDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstUnsizedArrayDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstUnsizedArrayDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstUnsizedArrayDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstUnsizedArrayDType* clonep() const { return static_cast<AstUnsizedArrayDType*>(AstNode::clonep()); } \
    AstUnsizedArrayDType* addNext(AstUnsizedArrayDType* nodep) { return static_cast<AstUnsizedArrayDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstUnsizedArrayDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_UnsizedArrayDType(...) AstNodeDType(VNType::UnsizedArrayDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstUnsizedRange \
    AstUnsizedRange* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnsizedRange*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstUnsizedRange* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstUnsizedRange*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstUnsizedRange* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstUnsizedRange*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstUnsizedRange* cloneTreePure(bool cloneNext) { \
        return static_cast<AstUnsizedRange*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstUnsizedRange* clonep() const { return static_cast<AstUnsizedRange*>(AstNode::clonep()); } \
    AstUnsizedRange* addNext(AstUnsizedRange* nodep) { return static_cast<AstUnsizedRange*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstUnsizedRange(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_UnsizedRange(...) AstNodeRange(VNType::UnsizedRange, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstVFile \
    AstVFile* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstVFile*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstVFile* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstVFile*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstVFile* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstVFile*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstVFile* cloneTreePure(bool cloneNext) { \
        return static_cast<AstVFile*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstVFile* clonep() const { return static_cast<AstVFile*>(AstNode::clonep()); } \
    AstVFile* addNext(AstVFile* nodep) { return static_cast<AstVFile*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstVFile(*this); } \
    AstTextBlock* tblockp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), TextBlock); } \
    void tblockp(AstTextBlock* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeFile::tblockp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_VFile(...) AstNodeFile(VNType::VFile, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstValuePlusArgs \
    AstValuePlusArgs* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstValuePlusArgs*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstValuePlusArgs* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstValuePlusArgs*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstValuePlusArgs* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstValuePlusArgs*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstValuePlusArgs* cloneTreePure(bool cloneNext) { \
        return static_cast<AstValuePlusArgs*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstValuePlusArgs* clonep() const { return static_cast<AstValuePlusArgs*>(AstNode::clonep()); } \
    AstValuePlusArgs* addNext(AstValuePlusArgs* nodep) { return static_cast<AstValuePlusArgs*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstValuePlusArgs(*this); } \
    AstNode* searchp() const VL_MT_STABLE { return op1p(); } \
    void searchp(AstNode* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* outp() const VL_MT_STABLE { return op2p(); } \
    void outp(AstNode* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_ValuePlusArgs(...) AstNodeExpr(VNType::ValuePlusArgs, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstVar \
private: \
    AstIface* m_sensIfacep = nullptr;public: \
    AstVar* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstVar*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstVar* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstVar*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstVar* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstVar*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstVar* cloneTreePure(bool cloneNext) { \
        return static_cast<AstVar*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstVar* clonep() const { return static_cast<AstVar*>(AstNode::clonep()); } \
    AstVar* addNext(AstVar* nodep) { return static_cast<AstVar*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstVar(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstDelay* delayp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), Delay); } \
    void delayp(AstDelay* nodep) { setNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* valuep() const VL_MT_STABLE { return op3p(); } \
    void valuep(AstNode* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* attrsp() const VL_MT_STABLE { return op4p(); } \
    void addAttrsp(AstNode* nodep) { addNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Var(...) AstNode(VNType::Var, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstVarRef \
    AstVarRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstVarRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstVarRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstVarRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstVarRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstVarRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstVarRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstVarRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstVarRef* clonep() const { return static_cast<AstVarRef*>(AstNode::clonep()); } \
    AstVarRef* addNext(AstVarRef* nodep) { return static_cast<AstVarRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstVarRef(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_VarRef(...) AstNodeVarRef(VNType::VarRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstVarScope \
private: \
    AstScope* m_scopep = nullptr;    AstVar* m_varp = nullptr;public: \
    AstVarScope* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstVarScope*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstVarScope* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstVarScope*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstVarScope* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstVarScope*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstVarScope* cloneTreePure(bool cloneNext) { \
        return static_cast<AstVarScope*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstVarScope* clonep() const { return static_cast<AstVarScope*>(AstNode::clonep()); } \
    AstVarScope* addNext(AstVarScope* nodep) { return static_cast<AstVarScope*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstVarScope(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_VarScope(...) AstNode(VNType::VarScope, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstVarXRef \
    AstVarXRef* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstVarXRef*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstVarXRef* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstVarXRef*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstVarXRef* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstVarXRef*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstVarXRef* cloneTreePure(bool cloneNext) { \
        return static_cast<AstVarXRef*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstVarXRef* clonep() const { return static_cast<AstVarXRef*>(AstNode::clonep()); } \
    AstVarXRef* addNext(AstVarXRef* nodep) { return static_cast<AstVarXRef*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstVarXRef(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_VarXRef(...) AstNodeVarRef(VNType::VarXRef, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstVoidDType \
    AstVoidDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstVoidDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstVoidDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstVoidDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstVoidDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstVoidDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstVoidDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstVoidDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstVoidDType* clonep() const { return static_cast<AstVoidDType*>(AstNode::clonep()); } \
    AstVoidDType* addNext(AstVoidDType* nodep) { return static_cast<AstVoidDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstVoidDType(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_VoidDType(...) AstNodeDType(VNType::VoidDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstWait \
    AstWait* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWait*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstWait* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWait*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstWait* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstWait*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstWait* cloneTreePure(bool cloneNext) { \
        return static_cast<AstWait*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstWait* clonep() const { return static_cast<AstWait*>(AstNode::clonep()); } \
    AstWait* addNext(AstWait* nodep) { return static_cast<AstWait*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstWait(*this); } \
    AstNodeExpr* condp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void condp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* stmtsp() const VL_MT_STABLE { return op2p(); } \
    void addStmtsp(AstNode* nodep) { addNOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_Wait(...) AstNodeStmt(VNType::Wait, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstWaitFork \
    AstWaitFork* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWaitFork*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstWaitFork* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWaitFork*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstWaitFork* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstWaitFork*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstWaitFork* cloneTreePure(bool cloneNext) { \
        return static_cast<AstWaitFork*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstWaitFork* clonep() const { return static_cast<AstWaitFork*>(AstNode::clonep()); } \
    AstWaitFork* addNext(AstWaitFork* nodep) { return static_cast<AstWaitFork*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstWaitFork(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_WaitFork(...) AstNodeStmt(VNType::WaitFork, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstWildcardArrayDType \
private: \
    AstNodeDType* m_refDTypep = nullptr;public: \
    AstWildcardArrayDType* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWildcardArrayDType*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstWildcardArrayDType* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWildcardArrayDType*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstWildcardArrayDType* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstWildcardArrayDType*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstWildcardArrayDType* cloneTreePure(bool cloneNext) { \
        return static_cast<AstWildcardArrayDType*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstWildcardArrayDType* clonep() const { return static_cast<AstWildcardArrayDType*>(AstNode::clonep()); } \
    AstWildcardArrayDType* addNext(AstWildcardArrayDType* nodep) { return static_cast<AstWildcardArrayDType*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void cloneRelinkGen() override; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstWildcardArrayDType(*this); } \
    AstNodeDType* childDTypep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeDType); } \
    void childDTypep(AstNodeDType* nodep) { setNOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_WildcardArrayDType(...) AstNodeDType(VNType::WildcardArrayDType, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstWildcardRange \
    AstWildcardRange* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWildcardRange*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstWildcardRange* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWildcardRange*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstWildcardRange* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstWildcardRange*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstWildcardRange* cloneTreePure(bool cloneNext) { \
        return static_cast<AstWildcardRange*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstWildcardRange* clonep() const { return static_cast<AstWildcardRange*>(AstNode::clonep()); } \
    AstWildcardRange* addNext(AstWildcardRange* nodep) { return static_cast<AstWildcardRange*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstWildcardRange(*this); } \
    static_assert(true, "")
#define ASTGEN_SUPER_WildcardRange(...) AstNodeRange(VNType::WildcardRange, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstWildcardSel \
    AstWildcardSel* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWildcardSel*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstWildcardSel* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWildcardSel*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstWildcardSel* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstWildcardSel*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstWildcardSel* cloneTreePure(bool cloneNext) { \
        return static_cast<AstWildcardSel*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstWildcardSel* clonep() const { return static_cast<AstWildcardSel*>(AstNode::clonep()); } \
    AstWildcardSel* addNext(AstWildcardSel* nodep) { return static_cast<AstWildcardSel*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstWildcardSel(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* bitp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void bitp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSel::fromp; \
    using AstNodeSel::bitp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_WildcardSel(...) AstNodeSel(VNType::WildcardSel, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstWith \
    AstWith* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWith*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstWith* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWith*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstWith* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstWith*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstWith* cloneTreePure(bool cloneNext) { \
        return static_cast<AstWith*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstWith* clonep() const { return static_cast<AstWith*>(AstNode::clonep()); } \
    AstWith* addNext(AstWith* nodep) { return static_cast<AstWith*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstWith(*this); } \
    AstLambdaArgRef* indexArgRefp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), LambdaArgRef); } \
    void indexArgRefp(AstLambdaArgRef* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstLambdaArgRef* valueArgRefp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), LambdaArgRef); } \
    void valueArgRefp(AstLambdaArgRef* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* exprp() const VL_MT_STABLE { return op3p(); } \
    void addExprp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_With(...) AstNodeExpr(VNType::With, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstWithParse \
    AstWithParse* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWithParse*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstWithParse* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWithParse*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstWithParse* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstWithParse*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstWithParse* cloneTreePure(bool cloneNext) { \
        return static_cast<AstWithParse*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstWithParse* clonep() const { return static_cast<AstWithParse*>(AstNode::clonep()); } \
    AstWithParse* addNext(AstWithParse* nodep) { return static_cast<AstWithParse*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstWithParse(*this); } \
    AstNodeExpr* funcrefp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void funcrefp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* exprsp() const VL_MT_STABLE { return op3p(); } \
    void addExprsp(AstNode* nodep) { addNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNode* constraintsp() const VL_MT_STABLE { return op4p(); } \
    void addConstraintsp(AstNode* nodep) { addNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
    static_assert(true, "")
#define ASTGEN_SUPER_WithParse(...) AstNodeExpr(VNType::WithParse, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstWordSel \
    AstWordSel* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWordSel*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstWordSel* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWordSel*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstWordSel* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstWordSel*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstWordSel* cloneTreePure(bool cloneNext) { \
        return static_cast<AstWordSel*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstWordSel* clonep() const { return static_cast<AstWordSel*>(AstNode::clonep()); } \
    AstWordSel* addNext(AstWordSel* nodep) { return static_cast<AstWordSel*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstWordSel(*this); } \
    AstNodeExpr* fromp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void fromp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* bitp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void bitp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeSel::fromp; \
    using AstNodeSel::bitp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_WordSel(...) AstNodeSel(VNType::WordSel, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstWriteMem \
    AstWriteMem* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWriteMem*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstWriteMem* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstWriteMem*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstWriteMem* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstWriteMem*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstWriteMem* cloneTreePure(bool cloneNext) { \
        return static_cast<AstWriteMem*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstWriteMem* clonep() const { return static_cast<AstWriteMem*>(AstNode::clonep()); } \
    AstWriteMem* addNext(AstWriteMem* nodep) { return static_cast<AstWriteMem*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstWriteMem(*this); } \
    AstNodeExpr* filenamep() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void filenamep(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* memp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void memp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* lsbp() const VL_MT_STABLE { return VN_DBG_AS(op3p(), NodeExpr); } \
    void lsbp(AstNodeExpr* nodep) { setNOp3p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* msbp() const VL_MT_STABLE { return VN_DBG_AS(op4p(), NodeExpr); } \
    void msbp(AstNodeExpr* nodep) { setNOp4p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeReadWriteMem::filenamep; \
    using AstNodeReadWriteMem::memp; \
    using AstNodeReadWriteMem::lsbp; \
    using AstNodeReadWriteMem::msbp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_WriteMem(...) AstNodeReadWriteMem(VNType::WriteMem, __VA_ARGS__)

#define ASTGEN_MEMBERS_AstXor \
    AstXor* unlinkFrBack(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstXor*>(AstNode::unlinkFrBack(linkerp)); \
    } \
    AstXor* unlinkFrBackWithNext(VNRelinker* linkerp = nullptr) { \
        return static_cast<AstXor*>(AstNode::unlinkFrBackWithNext(linkerp)); \
    } \
    AstXor* cloneTree(bool cloneNext, bool needPure = false) { \
        return static_cast<AstXor*>(AstNode::cloneTree(cloneNext, needPure)); \
    } \
    AstXor* cloneTreePure(bool cloneNext) { \
        return static_cast<AstXor*>(AstNode::cloneTreePure(cloneNext)); \
    } \
    AstXor* clonep() const { return static_cast<AstXor*>(AstNode::clonep()); } \
    AstXor* addNext(AstXor* nodep) { return static_cast<AstXor*>(AstNode::addNext(this, nodep)); } \
    const char* brokenGen() const override; \
    void foreachLink(std::function<void(AstNode** linkpp, const char* namep)> f) override; \
    bool wouldBreakGen(const AstNode* const oldp, const AstNode* const newp) const override; \
    void dumpTreeJsonOpGen(std::ostream& str, const string& indent) const override; \
    void dumpJsonGen(std::ostream& str) const; \
    void accept(VNVisitorConst& v) override { v.visit(this); } \
    AstNode* clone() override { return new AstXor(*this); } \
    AstNodeExpr* lhsp() const VL_MT_STABLE { return VN_DBG_AS(op1p(), NodeExpr); } \
    void lhsp(AstNodeExpr* nodep) { setOp1p(reinterpret_cast<AstNode*>(nodep)); } \
    AstNodeExpr* rhsp() const VL_MT_STABLE { return VN_DBG_AS(op2p(), NodeExpr); } \
    void rhsp(AstNodeExpr* nodep) { setOp2p(reinterpret_cast<AstNode*>(nodep)); } \
private: \
    using AstNodeBiComAsv::lhsp; \
    using AstNodeBiComAsv::rhsp; \
public: \
    static_assert(true, "")
#define ASTGEN_SUPER_Xor(...) AstNodeBiComAsv(VNType::Xor, __VA_ARGS__)

